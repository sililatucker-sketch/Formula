<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<title>Formula by PRV8</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='10' y='10' width='80' height='80' rx='18' fill='%23000' stroke='%23007bff' stroke-width='8'/><text x='50' y='68' text-anchor='middle' fill='%23007bff' font-size='48' font-weight='900' font-family='sans-serif'>F</text></svg>">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
  html, body { height: 100%; overflow: hidden; background: #0a0a0f; -webkit-overflow-scrolling: touch; }
  #root { width: 100%; height: 100%; }
  input, select, button { font-family: inherit; }
</style>
</head>
<body>
<div id="root"></div>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
<script>
  firebase.initializeApp({
    apiKey: "AIzaSyCmVcH8BMH637D-YTPJpr7Ziph9aqDMzgI",
    authDomain: "formula-e8bc3.firebaseapp.com",
    databaseURL: "https://formula-e8bc3-default-rtdb.firebaseio.com",
    projectId: "formula-e8bc3",
    storageBucket: "formula-e8bc3.firebasestorage.app",
    messagingSenderId: "631822291876",
    appId: "1:631822291876:web:0903a57e9b1606228e6731"
  });
  const fbDb = firebase.database();
</script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef } = React;

// ── CONSTANTS ──────────────────────────────────────────
const POSITIONS = ["OH", "MB", "S", "OPP", "L", "DS"];

// Stats tracked for formula analysis
const FORMULA_STATS = [
  { key: "kill", label: "Kills", scoring: true },
  { key: "stuff_block", label: "Stuff Blocks", scoring: true },
  { key: "ace", label: "Aces", scoring: true },
  { key: "opponent_error", label: "Opp Errors", scoring: true },
  { key: "attack_error", label: "Attack Errors", scoring: false },
  { key: "ball_error", label: "Ball Handling Errors", scoring: false },
  { key: "serve_error", label: "Serve Errors", scoring: false },
  { key: "block", label: "Block Touches", scoring: false },
  { key: "dig", label: "Digs", scoring: false },
  { key: "cvr", label: "Covers", scoring: false },
  { key: "assist", label: "Assists", scoring: false },
];

const defaultRoster = () =>
  Array.from({ length: 14 }, (_, i) => ({
    id: `p${i}`,
    number: "",
    name: "",
    position: "",
  }));

const POS_ORDER = { OH: 0, MB: 1, S: 2, OPP: 3, RS: 3, L: 4, DS: 5 };
const sortByPosition = (players) => [...players].sort((a, b) => {
  const pa = POS_ORDER[a.position] ?? 6;
  const pb = POS_ORDER[b.position] ?? 6;
  return pa !== pb ? pa - pb : 0;
});

const emptyMatch = () => ({
  id: Date.now().toString(),
  opponent: "",
  date: new Date().toISOString().split("T")[0],
  roster: defaultRoster(),
  sets: [],
  complete: false,
  format: 3, // best of 3 or 5
});

const emptySet = (num) => ({
  number: num,
  events: [],
  rallies: [],
  shots: [], // { origin, zone, outcome, timestamp }
  ourScore: 0,
  theirScore: 0,
  complete: false,
  // rotation state
  startingLineup: {}, // { pos1: playerId, pos2: ... pos6: playerId }
  currentLineup: {},
  liberoId: null, // backwards compat
  libero1Id: null,
  libero2Id: null,
  liberoIn: false, // is libero currently on court
  liberoForPlayer: null, // who the libero replaced
  liberoServeForMB: null, // backwards compat
  mbBackRowMap: {}, // { mbId: "libero1"|"libero2"|"self" }
  liberoServeMap: {}, // { liberoId: mbId } — which MB rotation each libero serves for
  liberoSwaps: {}, // runtime overrides from swap button: { mbId: liberoId|"self" }
  rotation: 1, // 1-6
  weServe: true,
  firstServerId: null,
  subs: [], // { inPlayer, outPlayer, rotation, timestamp }
  subCount: 0,
});

// Court position labels
const COURT_POS = {
  4: { label: "Front Left", row: "front", col: 0, short: "FL" },
  3: { label: "Front Mid", row: "front", col: 1, short: "FM" },
  2: { label: "Front Right", row: "front", col: 2, short: "FR" },
  5: { label: "Back Left", row: "back", col: 0, short: "BL" },
  6: { label: "Back Mid", row: "back", col: 1, short: "BM" },
  1: { label: "Back Right", row: "back", col: 2, short: "BR" },
};

const BACK_ROW = [1, 5, 6];
const FRONT_ROW = [2, 3, 4];

function VolleyballStats() {
  const [roomCode, setRoomCode] = useState(null);
  const [roomInput, setRoomInput] = useState("");
  const [recentRooms, setRecentRooms] = useState([]);
  const [screen, setScreenRaw] = useState("home");
  const navStackRef = useRef([]);
  const navigate = (s) => {
    navStackRef.current.push(screen);
    setScreenRaw(s);
  };
  const goBack = () => {
    if (navStackRef.current.length > 0) {
      const prev = navStackRef.current.pop();
      setScreenRaw(prev);
    } else {
      setScreenRaw("home");
    }
  };
  // For cases where we need to set screen without pushing history (e.g., room exit)
  const setScreen = (s) => {
    navStackRef.current = [];
    setScreenRaw(s);
  };
  const [matches, setMatches] = useState([]);
  const [currentMatch, setCurrentMatch] = useState(null);
  const [currentSetIdx, setCurrentSetIdx] = useState(0);
  const [toast, setToast] = useState(null);
  const [loaded, setLoaded] = useState(false);
  const toastRef = useRef(null);


  // Saved teams
  const [savedTeams, setSavedTeams] = useState([]);
  const [editingTeam, setEditingTeam] = useState(null);

  // Standalone scout sessions (accessible from home)
  const [scoutSessions, setScoutSessions] = useState([]);
  const [currentScout, setCurrentScout] = useState(null);
  const [scoutNameInput, setScoutNameInput] = useState(""); // for new scout creation

  // Setup state
  const [setupStep, setSetupStep] = useState("roster"); // roster, lineup, options
  const [lineupSlots, setLineupSlots] = useState({});
  const [lineupPositions, setLineupPositions] = useState({}); // {playerId: "OH"} overrides
  const [selectedLibero, setSelectedLibero] = useState(null);
  const [selectedLibero2, setSelectedLibero2] = useState(null);
  const [mbBackRowMap, setMbBackRowMap] = useState({}); // { mbId: "libero1"|"libero2"|"self" }
  const [weServeFirst, setWeServeFirst] = useState(true);
  const [firstServerPos, setFirstServerPos] = useState(1);
  const [selectingPos, setSelectingPos] = useState(null);
  const [selectingLibero, setSelectingLibero] = useState(null); // null, 1, or 2

  // Match state
  const [tab, setTab] = useState("court"); // court, stats, formula, swings, subs
  const [rallyPhase, setRallyPhase] = useState("idle"); // idle, offense, defense
  const [prevRallyPhase, setPrevRallyPhase] = useState(null); // for undo
  const [currentRally, setCurrentRally] = useState(null);
  const [prevRally, setPrevRally] = useState(null); // for undo
  const [selectedPlayer, setSelectedPlayer] = useState(null);
  const [undoStack, setUndoStack] = useState([]);
  const [assistPrompt, setAssistPrompt] = useState(null);
  const [scoutView, setScoutView] = useState("input");
  const [scoutPending, setScoutPending] = useState(null); // { originZone, outcome } → waiting for landing zone tap
  const [scoutOriginFilter, setScoutOriginFilter] = useState(null); // heatmap filter by origin zone
  const [statsSetView, setStatsSetView] = useState("current"); // "current", "match", or set index
  const [homeTab, setHomeTab] = useState("teams"); // "teams", "formula"
  const [liberoServeChoice, setLiberoServeChoice] = useState(null);
  const [libero2ServeChoice, setLibero2ServeChoice] = useState(null);
  const [showTimeout, setShowTimeout] = useState(false); // timeout overlay
  const [activeTeamId, setActiveTeamId] = useState(null); // for team homepage
  // Practice mode
  const [practices, setPractices] = useState([]);
  const [currentPractice, setCurrentPractice] = useState(null);
  const [practiceRound, setPracticeRound] = useState(null); // { selectedPassers: [], events: [] }
  const [practicePasserPick, setPracticePasserPick] = useState(false); // which MB rotation libero serves for

  // Track active match to prevent Firebase listener overwrites during live tracking
  const activeMatchRef = useRef(false);
  useEffect(() => { activeMatchRef.current = !!currentMatch; }, [currentMatch]);

  // ── FIREBASE DATA NORMALIZATION ──────────────────────
  // Firebase: (1) drops empty arrays entirely ([] → undefined)
  // (2) converts arrays to objects {0: x, 1: y, ...}
  // (3) may create sparse objects if nulls existed {0: x, 2: z} (drops null at index 1)

  const fbNorm = (val) => {
    if (val === null || val === undefined) return val;
    if (typeof val !== "object") return val;
    if (Array.isArray(val)) return val.filter(v => v != null).map(fbNorm);
    const keys = Object.keys(val);
    if (keys.length === 0) return val;
    // Firebase pseudo-array: all keys are non-negative integers AND key "0" exists
    // (lineup objects have keys 1-6, no "0", so they stay as objects)
    const hasZero = keys.includes("0");
    const allNumeric = keys.every((k) => /^\d+$/.test(k));
    if (hasZero && allNumeric) {
      return keys.sort((a, b) => Number(a) - Number(b)).map((k) => fbNorm(val[k])).filter(v => v != null);
    }
    // Regular object — recurse
    const out = {};
    for (const [k, v] of Object.entries(val)) out[k] = fbNorm(v);
    return out;
  };

  const fbArr = (val) => {
    if (!val) return [];
    const normed = fbNorm(val);
    if (Array.isArray(normed)) return normed;
    if (typeof normed === "object") return Object.values(normed);
    return [];
  };

  // Ensure a set has all required array/object properties
  const normalizeSet = (s) => {
    if (!s || typeof s !== "object") return { events: [], rallies: [], shots: [], ourScore: 0, theirScore: 0, currentLineup: {} };
    return {
      ...s,
      events: Array.isArray(s.events) ? s.events : [],
      rallies: Array.isArray(s.rallies) ? s.rallies : [],
      shots: Array.isArray(s.shots) ? s.shots : [],
      subs: Array.isArray(s.subs) ? s.subs : [],
      currentLineup: s.currentLineup && typeof s.currentLineup === "object" ? s.currentLineup : {},
      ourScore: s.ourScore || 0,
      theirScore: s.theirScore || 0,
    };
  };

  const normalizeMatch = (m) => {
    if (!m || typeof m !== "object") return null;
    return {
      ...m,
      sets: Array.isArray(m.sets) ? m.sets.map(normalizeSet) : [],
      roster: Array.isArray(m.roster) ? m.roster : [],
    };
  };

  const normalizeTeam = (t) => {
    if (!t || typeof t !== "object") return null;
    return {
      ...t,
      players: Array.isArray(t.players) ? t.players : [],
    };
  };

  const normalizePractice = (p) => {
    if (!p || typeof p !== "object") return null;
    return {
      ...p,
      rounds: Array.isArray(p.rounds) ? p.rounds.map((r) => ({
        ...r,
        groups: Array.isArray(r.groups) ? r.groups.map((g) => ({
          ...g,
          selectedPassers: Array.isArray(g.selectedPassers) ? g.selectedPassers : [],
          events: Array.isArray(g.events) ? g.events : [],
        })) : [],
        events: Array.isArray(r.events) ? r.events : [],
      })) : [],
    };
  };

  const normalizeFromFb = (type, data) => {
    const arr = fbArr(data);
    switch (type) {
      case "teams": return arr.map(normalizeTeam).filter(Boolean);
      case "matches": return arr.map(normalizeMatch).filter(Boolean);
      case "practices": return arr.map(normalizePractice).filter(Boolean);
      default: return arr;
    }
  };

  // Load recent rooms on mount (before room selection) — stays in localStorage (per-device)
  useEffect(() => {
    try {
      const saved = localStorage.getItem("formula_recent_rooms");
      if (saved) setRecentRooms(JSON.parse(saved));
      const lastRoom = localStorage.getItem("formula_last_room");
      if (lastRoom) setRoomInput(lastRoom);
    } catch (e) {}
  }, []);

  // Firebase listeners — attach on room select, detach on room change
  useEffect(() => {
    if (!roomCode) return;
    setLoaded(false);

    const base = `rooms/${roomCode}`;
    const refs = {
      teams: fbDb.ref(`${base}/teams`),
      matches: fbDb.ref(`${base}/matches`),
      scout: fbDb.ref(`${base}/scout`),
      practices: fbDb.ref(`${base}/practices`),
    };

    // Track initial load (need all 4 to fire at least once)
    let loadFlags = { teams: false, matches: false, scout: false, practices: false };
    const checkLoaded = () => {
      if (Object.values(loadFlags).every(Boolean)) setLoaded(true);
    };

    const handlers = {};

    handlers.teams = refs.teams.on('value', (snap) => {
      const raw = snap.val();
      const normalized = normalizeFromFb("teams", raw);
      console.log("[Firebase] teams raw:", raw, "→ normalized:", normalized);
      setSavedTeams(normalized);
      loadFlags.teams = true;
      checkLoaded();
    });

    handlers.matches = refs.matches.on('value', (snap) => {
      const raw = snap.val();
      if (activeMatchRef.current) {
        if (!loadFlags.matches) { loadFlags.matches = true; checkLoaded(); }
        console.log("[Firebase] matches update skipped (active match)");
        return;
      }
      const normalized = normalizeFromFb("matches", raw);
      console.log("[Firebase] matches raw:", raw, "→ normalized:", normalized);
      if (normalized.length > 0) {
        console.log("[Firebase] match[0] teamId:", normalized[0].teamId, "sets:", normalized[0].sets?.length, "roster:", normalized[0].roster?.length);
      }
      setMatches(normalized);
      loadFlags.matches = true;
      checkLoaded();
    });

    handlers.scout = refs.scout.on('value', (snap) => {
      const raw = snap.val();
      const normalized = normalizeFromFb("scout", raw);
      console.log("[Firebase] scout:", normalized.length, "sessions");
      setScoutSessions(normalized);
      loadFlags.scout = true;
      checkLoaded();
    });

    handlers.practices = refs.practices.on('value', (snap) => {
      const raw = snap.val();
      const normalized = normalizeFromFb("practices", raw);
      console.log("[Firebase] practices:", normalized.length, "sessions");
      setPractices(normalized);
      loadFlags.practices = true;
      checkLoaded();
    });

    // Save room to recents (localStorage — per device)
    try {
      localStorage.setItem("formula_last_room", roomCode);
      const rooms = JSON.parse(localStorage.getItem("formula_recent_rooms") || "[]");
      const updated = [roomCode, ...rooms.filter((r) => r !== roomCode)].slice(0, 10);
      localStorage.setItem("formula_recent_rooms", JSON.stringify(updated));
      setRecentRooms(updated);
    } catch (e) {}

    // Cleanup listeners on room change
    return () => {
      refs.teams.off('value', handlers.teams);
      refs.matches.off('value', handlers.matches);
      refs.scout.off('value', handlers.scout);
      refs.practices.off('value', handlers.practices);
    };
  }, [roomCode]);

  // Save functions — write to Firebase
  const save = (m) => {
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/matches`).set(m); } catch (e) {}
  };

  const saveScoutSessions = (sessions) => {
    setScoutSessions(sessions);
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/scout`).set(sessions); } catch (e) {}
  };

  const deleteMatch = (matchId) => {
    const updated = matches.filter((m) => m.id !== matchId);
    setMatches(updated);
    save(updated);
    showToast("Match deleted");
  };

  const saveTeams = (teams) => {
    setSavedTeams(teams);
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/teams`).set(teams); } catch (e) {}
  };

  const savePractices = (p) => {
    setPractices(p);
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/practices`).set(p); } catch (e) {}
  };

  const deletePractice = (practiceId) => {
    const updated = practices.filter((p) => p.id !== practiceId);
    savePractices(updated);
    showToast("Practice deleted");
  };

  const createTeam = () => {
    setEditingTeam({
      id: Date.now().toString(),
      name: "",
      players: Array.from({ length: 16 }, (_, i) => ({
        id: `t${Date.now()}-p${i}`,
        number: "",
        name: "",
        position: "",
      })),
    });
    navigate("editTeam");
  };

  const saveCurrentTeam = () => {
    if (!editingTeam || !editingTeam.name.trim()) {
      showToast("Enter a team name");
      return;
    }
    const exists = savedTeams.find((t) => t.id === editingTeam.id);
    let updated;
    if (exists) {
      updated = savedTeams.map((t) => (t.id === editingTeam.id ? editingTeam : t));
    } else {
      updated = [...savedTeams, editingTeam];
    }
    saveTeams(updated);
    setEditingTeam(null);
    setScreen("home");
    showToast(`${editingTeam.name} saved!`);
  };

  const deleteTeam = (teamId) => {
    const updated = savedTeams.filter((t) => t.id !== teamId);
    saveTeams(updated);
    showToast("Team deleted");
  };

  const startMatchWithTeam = (team) => {
    const match = emptyMatch();
    // Copy team roster into match with fresh IDs
    match.roster = ((team.players||[])).filter((p) => p.number).map((p, i) => ({
      ...p,
      id: `m${Date.now()}-p${i}`,
    }));
    // Pad to 14 if fewer
    while (match.roster.length < 14) {
      match.roster.push({ id: `m${Date.now()}-px${match.roster.length}`, number: "", name: "", position: "" });
    }
    match.teamName = team.name;
    match.teamId = team.id;
    setCurrentMatch(match);
    setSetupStep("roster");
    navigate("setup");
  };

  const showToast = (msg) => {
    if (toastRef.current) clearTimeout(toastRef.current);
    setToast(msg);
    toastRef.current = setTimeout(() => setToast(null), 1500);
  };

  const persistMatch = (updated) => {
    setCurrentMatch(updated);
    setMatches((prev) => {
      const all = prev.map((m) => (m.id === updated.id ? updated : m));
      if (!all.find((m) => m.id === updated.id)) all.push(updated);
      save(all);
      return all;
    });
  };

  const getCurrentSet = () => {
    if (!currentMatch || !currentMatch.sets[currentSetIdx]) return null;
    return currentMatch.sets[currentSetIdx];
  };

  // CRITICAL: use functional updater to avoid stale closure issues
  // when multiple updates fire in the same tick (recordEvent + scorePoint)
  const updateCurrentSet = (updater) => {
    setCurrentMatch((prev) => {
      if (!prev || !prev.sets[currentSetIdx]) return prev;
      const sets = [...prev.sets];
      sets[currentSetIdx] = updater(sets[currentSetIdx]);
      const updated = { ...prev, sets };
      // Persist async
      setMatches((prevMatches) => {
        const all = prevMatches.map((m) => (m.id === updated.id ? updated : m));
        if (!all.find((m) => m.id === updated.id)) all.push(updated);
        save(all);
        return all;
      });
      return updated;
    });
  };

  // ── ROTATION LOGIC ──────────────────────────────────
  const rotate = (lineup) => {
    // Clockwise rotation: 1→6→5→4→3→2→1
    const newLineup = {};
    newLineup[1] = lineup[2];
    newLineup[2] = lineup[3];
    newLineup[3] = lineup[4];
    newLineup[4] = lineup[5];
    newLineup[5] = lineup[6];
    newLineup[6] = lineup[1];
    return newLineup;
  };

  const getPlayerById = (id) => {
    if (!currentMatch) return null;
    return ((currentMatch.roster||[])).find((p) => p.id === id);
  };

  // Get effective position: check match overrides first, then roster position
  const getEffectivePosition = (id) => {
    const set = currentMatch?.sets?.[currentMatch.sets.length - 1];
    const overrides = set?.positionOverrides || lineupPositions;
    if (overrides[id]) return overrides[id];
    const p = getPlayerById(id);
    return p?.position || "";
  };

  // Get libero IDs from set (backwards compatible with old single-libero sets)
  const getSetLiberos = (set) => {
    if (!set) return { lib1: null, lib2: null };
    return {
      lib1: set.libero1Id || set.liberoId || null,
      lib2: set.libero2Id || null,
    };
  };

  const isLiberoId = (pid, set) => {
    const { lib1, lib2 } = getSetLiberos(set);
    return pid === lib1 || pid === lib2;
  };

  // Determine which player should be in for a given MB in the back row
  const getBackRowSubFor = (set, mbId, zone) => {
    const { lib1, lib2 } = getSetLiberos(set);
    if (!lib1 && !lib2) return mbId; // no liberos

    // Check runtime swap override first
    const swapOverride = set.liberoSwaps?.[mbId];
    if (swapOverride === "self") return mbId;
    if (swapOverride && (swapOverride === lib1 || swapOverride === lib2)) {
      // Zone 1 serving: only sub if this libero serves for this MB
      if (zone === 1 && set.weServe) {
        const serveMap = set.liberoServeMap || {};
        const oldServeForMB = set.liberoServeForMB; // backwards compat
        if (serveMap[swapOverride] === mbId || (swapOverride === lib1 && oldServeForMB === mbId)) {
          return swapOverride;
        }
        return mbId; // MB serves themselves
      }
      return swapOverride;
    }

    // Check setup assignment
    const backRowMap = set.mbBackRowMap || {};
    const assignment = backRowMap[mbId];
    let liberoToSub = null;

    if (assignment === "libero2" && lib2) liberoToSub = lib2;
    else if (assignment === "libero1" && lib1) liberoToSub = lib1;
    else if (assignment === "self") return mbId;
    else if (lib1) liberoToSub = lib1; // default: use libero 1
    else return mbId;

    // Zone 1 serving: only sub if this libero serves for this MB
    if (zone === 1 && set.weServe) {
      const serveMap = set.liberoServeMap || {};
      const oldServeForMB = set.liberoServeForMB;
      if (serveMap[liberoToSub] === mbId || (liberoToSub === lib1 && oldServeForMB === mbId)) {
        return liberoToSub;
      }
      return mbId;
    }

    return liberoToSub;
  };

  const getOnCourtLineup = (set) => {
    if (!set) return {};
    const lineup = { ...set.currentLineup };
    const { lib1, lib2 } = getSetLiberos(set);
    if (!lib1 && !lib2) return lineup;

    for (const pos of BACK_ROW) {
      const playerId = lineup[pos];
      if (getEffectivePosition(playerId) === "MB") {
        const sub = getBackRowSubFor(set, playerId, pos);
        if (sub !== playerId) {
          lineup[pos] = sub;
          lineup._liberoFor = playerId;
          lineup._liberoPos = pos;
        }
        break; // only one MB in back row at a time
      }
    }
    return lineup;
  };

  const getCurrentServer = (set) => {
    if (!set) return null;
    if (!set.weServe) return null;
    const basePlayerId = set.currentLineup[1]; // who is in zone 1 by rotation
    if (!basePlayerId || !currentMatch) return basePlayerId;
    const { lib1, lib2 } = getSetLiberos(set);
    // If an MB is in zone 1 and we have liberos
    if (getEffectivePosition(basePlayerId) === "MB" && (lib1 || lib2)) {
      const sub = getBackRowSubFor(set, basePlayerId, 1);
      return sub; // either the libero (if serves for this MB) or the MB themselves
    }
    // If a libero is in zone 1 somehow
    if (isLiberoId(basePlayerId, set)) return basePlayerId;
    return basePlayerId;
  };

  const getNextServer = (set) => {
    // When receiving, the player in zone 2 will rotate to zone 1 on sideout
    if (!set || set.weServe) return null;
    const lineup = getOnCourtLineup(set);
    return lineup[2];
  };

  // Identify serve-receive passers: typically OHs + Libero
  // Front-row OHs pull back to pass, libero always passes
  // Any player with position OH, L, or DS is a primary passer
  const isPrimaryPasser = (playerId, set) => {
    if (!set || !currentMatch) return false;
    // Either libero always passes
    if (isLiberoId(playerId, set)) return true;
    // OHs and DS are primary passers
    const pos = getEffectivePosition(playerId);
    if (["OH", "L", "DS"].includes(pos)) return true;
    return false;
  };

  // Get all on-court players for receive phase, with primary passer flag
  const getPassers = (set) => {
    if (!set) return [];
    const lineup = getOnCourtLineup(set);
    const passers = [];
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (pid && typeof pid === "string") {
        passers.push({ pos, playerId: pid, player: getPlayerById(pid), primary: isPrimaryPasser(pid, set) });
      }
    }
    return passers;
  };

  // ── SCORING ──────────────────────────────────────────
  const scorePoint = (forUs) => {
    updateCurrentSet((set) => {
      let newSet = { ...set };
      if (forUs) {
        newSet.ourScore = set.ourScore + 1;
        if (!set.weServe) {
          // Sideout! We rotate and now serve
          newSet.currentLineup = rotate(set.currentLineup);
          newSet.rotation = (set.rotation % 6) + 1;
          newSet.weServe = true;
        }
        // If already serving, stay same rotation
      } else {
        newSet.theirScore = set.theirScore + 1;
        if (set.weServe) {
          // Lost serve
          newSet.weServe = false;
        }
      }
      return newSet;
    });
  };

  const recordEvent = (playerId, stat, extra = {}) => {
    const event = {
      id: Date.now().toString() + Math.random().toString(36).slice(2, 5),
      player: playerId,
      stat,
      timestamp: Date.now(),
      rotation: getCurrentSet()?.rotation,
      weServing: getCurrentSet()?.weServe,
      ...extra,
      _prevPhase: rallyPhase, // save phase for undo
      _prevRally: currentRally ? { ...currentRally } : null,
    };
    updateCurrentSet((set) => ({ ...set, events: [...(set.events || []), event] }));
    setUndoStack((prev) => [...prev, event]);
    return event;
  };

  // ── ONE-TAP STAT RECORDING ──────────────────────────

  const recordRally = (rally) => {
    updateCurrentSet((set) => ({ ...set, rallies: [...(set.rallies || []), rally] }));
  };

  const endRally = (weWon, rally) => {
    // Save score snapshot to last undo entry for proper undo
    const set = getCurrentSet();
    if (set) {
      setUndoStack((prev) => {
        if (prev.length === 0) return prev;
        const last = { ...prev[prev.length - 1] };
        last._undoScore = {
          ourScore: set.ourScore,
          theirScore: set.theirScore,
          weServe: set.weServe,
          currentLineup: { ...set.currentLineup },
          rotation: set.rotation,
        };
        last._undoRally = !!rally;
        return [...prev.slice(0, -1), last];
      });
    }
    // Capture on-court players for +/- before score changes lineup
    const onCourtNow = set ? getOnCourtLineup(set) : {};
    const onCourtIds = [1,2,3,4,5,6].map((p) => onCourtNow[p]).filter((v) => typeof v === "string");
    if (rally) recordRally({ ...rally, weWon, onCourt: onCourtIds });
    scorePoint(weWon);
    setRallyPhase("idle");
    setCurrentRally(null);
    setSelectedPlayer(null);
  };

  const getSetterOnCourt = (set) => {
    if (!set || !currentMatch) return null;
    const lineup = getOnCourtLineup(set);
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (getEffectivePosition(pid) === "S") return pid;
    }
    return null;
  };

  const getHittersOnCourt = (set) => {
    if (!set || !currentMatch) return [];
    const lineup = getOnCourtLineup(set);
    const hitters = [];
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (!pid || typeof pid !== "string") continue;
      const ePos = getEffectivePosition(pid);
      if (!["S", "L", "DS"].includes(ePos)) hitters.push(pid);
    }
    return hitters;
  };


  // ── UNDO ────────────────────────────────────────────
  const undoLastAction = () => {
    if (undoStack.length === 0) return;
    const last = undoStack[undoStack.length - 1];
    // Remove the event
    updateCurrentSet((set) => ({
      ...set,
      events: (set.events || []).filter((e) => e.id !== last.id),
    }));
    // Revert rally phase if saved
    if (last._prevPhase !== undefined) {
      setRallyPhase(last._prevPhase);
    }
    if (last._prevRally !== undefined) {
      setCurrentRally(last._prevRally);
    }
    // If this was a rally-ending event that changed score, also undo the rally and score
    if (last._undoScore) {
      updateCurrentSet((set) => {
        const newSet = { ...set };
        newSet.ourScore = last._undoScore.ourScore;
        newSet.theirScore = last._undoScore.theirScore;
        newSet.weServe = last._undoScore.weServe;
        newSet.currentLineup = last._undoScore.currentLineup;
        newSet.rotation = last._undoScore.rotation;
        if (last._undoRally) {
          newSet.rallies = (set.rallies || []).slice(0, -1);
        }
        return newSet;
      });
    }
    setUndoStack((prev) => prev.slice(0, -1));
    showToast("Undone");
  };

  // ── SUBS ────────────────────────────────────────────
  const makeSub = (inPlayerId, outPlayerId) => {
    updateCurrentSet((set) => {
      const newLineup = { ...set.currentLineup };
      for (const pos of Object.keys(newLineup)) {
        if (newLineup[pos] === outPlayerId) {
          newLineup[pos] = inPlayerId;
          break;
        }
      }
      return {
        ...set,
        currentLineup: newLineup,
        subs: [
          ...set.subs,
          { inPlayer: inPlayerId, outPlayer: outPlayerId, rotation: set.rotation, timestamp: Date.now() },
        ],
        subCount: set.subCount + 1,
      };
    });
    const inP = getPlayerById(inPlayerId);
    const outP = getPlayerById(outPlayerId);
    showToast(`SUB: ${inP?.name?.split(" ")[0]} in for ${outP?.name?.split(" ")[0]}`);
  };

  // ── END SET ─────────────────────────────────────────
  const endCurrentSet = () => {
    updateCurrentSet((set) => ({ ...set, complete: true }));
    setRallyPhase("idle");
    setCurrentRally(null);
    setUndoStack([]);
    setSelectingPos(null);
    setSelectingLibero(null);

    // Check if match is over
    const setsToWin = currentMatch?.format === 5 ? 3 : 2;
    const completedSets = [...(currentMatch?.sets || [])];
    // The current set just got marked complete but state hasn't propagated yet,
    // so count from what we have plus the current set result
    const set = currentMatch?.sets?.[currentSetIdx];
    const weWonThisSet = set && set.ourScore > set.theirScore;
    let setsWon = completedSets.filter((s, i) => i !== currentSetIdx && s.complete && s.ourScore > s.theirScore).length + (weWonThisSet ? 1 : 0);
    let setsLost = completedSets.filter((s, i) => i !== currentSetIdx && s.complete && s.ourScore < s.theirScore).length + (weWonThisSet ? 0 : 1);

    if (setsWon >= setsToWin || setsLost >= setsToWin) {
      // Match is over — mark complete and show summary
      setCurrentMatch((prev) => {
        const updated = { ...prev, complete: true, result: { setsWon, setsLost, won: setsWon >= setsToWin } };
        setMatches((prevM) => {
          const all = prevM.map((m) => (m.id === updated.id ? updated : m));
          save(all);
          return all;
        });
        return updated;
      });
      navigate("matchComplete");
    } else {
      // More sets to play — go to new set setup
      setSetupStep("lineup");
      navigate("setup");
    }
  };

  const endMatchEarly = () => {
    if (!confirm("End this match? You can still view stats.")) return;
    const completedSets = (currentMatch?.sets || []).filter((s) => s.complete);
    const setsWon = completedSets.filter((s) => s.ourScore > s.theirScore).length;
    const setsLost = completedSets.filter((s) => s.ourScore < s.theirScore).length;
    // Also complete the current set if it has any score
    const set = currentMatch?.sets?.[currentSetIdx];
    if (set && !set.complete && (set.ourScore > 0 || set.theirScore > 0)) {
      updateCurrentSet((s) => ({ ...s, complete: true }));
    }
    setCurrentMatch((prev) => {
      const updated = { ...prev, complete: true, result: { setsWon, setsLost, won: setsWon > setsLost } };
      setMatches((prevM) => {
        const all = prevM.map((m) => (m.id === updated.id ? updated : m));
        save(all);
        return all;
      });
      return updated;
    });
    setRallyPhase("idle");
    setCurrentRally(null);
    setUndoStack([]);
    navigate("matchComplete");
  };

  // ── CORRELATION ANALYSIS ────────────────────────────
  const getServeCorrelation = () => {
    if (!currentMatch) return { data: [], summary: "" };
    const allRallies = ((currentMatch.sets||[])).flatMap((s) => s.rallies || []);

    const ourServes = allRallies.filter((r) => r.type === "our_serve" && r.serveForced);
    const byQuality = { 1: { total: 0, won: 0 }, 2: { total: 0, won: 0 }, 3: { total: 0, won: 0 } };

    for (const r of ourServes) {
      const q = r.serveForced;
      if (byQuality[q]) {
        byQuality[q].total++;
        if (r.weWon) byQuality[q].won++;
      }
    }

    const theirServes = allRallies.filter((r) => r.type === "their_serve" && r.passQuality !== undefined);
    const byPassQ = { 1: { total: 0, won: 0 }, 2: { total: 0, won: 0 }, 3: { total: 0, won: 0 } };

    for (const r of theirServes) {
      const q = r.passQuality;
      if (byPassQ[q]) {
        byPassQ[q].total++;
        if (r.weWon) byPassQ[q].won++;
      }
    }

    return { ourServes: byQuality, theirServes: byPassQ };
  };

  // ── STATS HELPERS ───────────────────────────────────
  const getSetTotals = (setData) => {
    const totals = {};
    if (!setData) return totals;
    for (const event of (setData.events || [])) {
      if (event.stat === "serve_in") continue;
      totals[event.stat] = (totals[event.stat] || 0) + 1;
    }
    return totals;
  };

  const getMatchTotals = () => {
    const totals = {};
    if (!currentMatch) return totals;
    for (const set of (currentMatch.sets || [])) {
      for (const event of (set.events || [])) {
        if (event.stat === "serve_in") continue;
        totals[event.stat] = (totals[event.stat] || 0) + 1;
      }
    }
    return totals;
  };

  const getPlayerSetStats = (playerId, setData) => {
    const stats = {};
    if (!setData) return stats;
    for (const event of (setData.events || [])) {
      if (event.player === playerId && event.stat !== "serve_in") {
        stats[event.stat] = (stats[event.stat] || 0) + 1;
      }
    }
    return stats;
  };

  // Weighted passing: 3→1.5, 2→1.0, 1→0.5, 0→0
  const PASS_WEIGHTS = { 3: 1.5, 2: 1.0, 1: 0.5, 0: 0 };
  const getPlayerPassingStats = (playerId, setData) => {
    if (!setData) return null;
    const passes = { 0: 0, 1: 0, 2: 0, 3: 0 };
    let total = 0;
    for (const ev of (setData.events || [])) {
      if (ev.player === playerId && ev.stat === "reception" && ev.quality !== undefined) {
        passes[ev.quality] = (passes[ev.quality] || 0) + 1;
        total++;
      }
    }
    if (total === 0) return null;
    let weightedSum = 0;
    let weightTotal = 0;
    for (const [q, count] of Object.entries(passes)) {
      const w = PASS_WEIGHTS[q] || 0;
      weightedSum += Number(q) * w * count;
      weightTotal += w * count;
    }
    const weightedScore = weightTotal > 0 ? weightedSum / weightTotal : 0;
    const simpleAvg = (passes[0]*0 + passes[1]*1 + passes[2]*2 + passes[3]*3) / total;
    return { passes, total, weightedScore, simpleAvg };
  };

  const getSwingDistribution = (setData) => {
    if (!currentMatch || !setData) return [];
    const dist = [];
    for (const player of currentMatch.roster) {
      if (!player.number) continue;
      const ps = getPlayerSetStats(player.id, setData);
      const attacks = (ps.kill || 0) + (ps.attack_error || 0) + (ps.attack_blocked || 0);
      dist.push({
        player,
        attacks,
        kills: ps.kill || 0,
        errors: ps.attack_error || 0,
        blocked: ps.attack_blocked || 0,
        killPct: attacks > 0 ? ((ps.kill || 0) - (ps.attack_error || 0)) / attacks : null,
      });
    }
    dist.sort((a, b) => b.attacks - a.attacks);
    return dist;
  };

  // Dynamic formula: analyze all historical sets to find win/loss stat differences
  const getFormulaAnalysis = () => {
    const allSets = [];
    for (const m of matches) {
      for (const s of (m.sets || [])) {
        if (s.complete) {
          const totals = getSetTotals(s);
          // Use stuff_block as the scoring block stat
          allSets.push({
            won: s.ourScore > s.theirScore,
            ourScore: s.ourScore,
            theirScore: s.theirScore,
            stats: totals,
          });
        }
      }
    }

    const wonSets = allSets.filter((s) => s.won);
    const lostSets = allSets.filter((s) => !s.won);

    // Calculate averages per stat for won and lost sets
    const calcAvg = (sets, key) => {
      if (sets.length === 0) return 0;
      return sets.reduce((sum, s) => sum + (s.stats[key] || 0), 0) / sets.length;
    };

    const analysis = FORMULA_STATS.map((fs) => {
      const winAvg = calcAvg(wonSets, fs.key);
      const lossAvg = calcAvg(lostSets, fs.key);
      const diff = winAvg - lossAvg;
      return {
        ...fs,
        winAvg: Math.round(winAvg * 10) / 10,
        lossAvg: Math.round(lossAvg * 10) / 10,
        diff: Math.round(diff * 10) / 10,
        target: Math.round(winAvg), // winning avg becomes the target
      };
    });

    // Sort by absolute impact (biggest differentiators first)
    analysis.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));

    return {
      analysis,
      wonSets: wonSets.length,
      lostSets: lostSets.length,
      totalSets: allSets.length,
      hasEnoughData: allSets.length >= 3 && wonSets.length >= 1 && lostSets.length >= 1,
    };
  };

  // Current set progress (works regardless of history)
  const getCurrentSetProgress = (setData) => {
    const totals = getSetTotals(setData);
    let totalScored = (totals.kill || 0) + (totals.stuff_block || 0) + (totals.ace || 0) + (totals.opponent_error || 0);
    return {
      totals,
      totalScored,
      remaining: Math.max(0, 25 - totalScored),
      stats: FORMULA_STATS.map((fs) => ({
        ...fs,
        actual: fs.key === "stuff_block" ? (totals.stuff_block || 0) : (totals[fs.key] || 0),
      })),
    };
  };

  const getServeRisk = (setData) => {
    const totals = getSetTotals(setData);
    const aces = totals.ace || 0;
    const errors = totals.serve_error || 0;
    const total = aces + errors;
    if (total === 0) return { ratio: 0, aces, errors, net: 0, recommendation: "No serve data yet" };
    const net = aces - errors;
    const ratio = aces / Math.max(1, errors);
    let rec = "";
    if (ratio >= 2) rec = "Serving is a weapon. Keep the pressure on.";
    else if (ratio >= 1) rec = "Serving net positive. Stay aggressive.";
    else if (ratio >= 0.5) rec = "Errors outpacing aces. Consider backing off.";
    else rec = "Too many errors. Prioritize getting serves in.";
    return { ratio, aces, errors, net, recommendation: rec };
  };

  // Player +/- : point differential while on court
  const getPlayerPlusMinus = (setData) => {
    const pm = {};
    if (!setData?.rallies) return pm;
    for (const r of setData.rallies) {
      if (!r.onCourt) continue;
      const val = r.weWon ? 1 : -1;
      for (const pid of r.onCourt) {
        pm[pid] = (pm[pid] || 0) + val;
      }
    }
    return pm;
  };

  const getMatchPlusMinus = () => {
    const pm = {};
    if (!currentMatch) return pm;
    for (const s of (currentMatch.sets || [])) {
      const setPm = getPlayerPlusMinus(s);
      for (const [pid, val] of Object.entries(setPm)) {
        pm[pid] = (pm[pid] || 0) + val;
      }
    }
    return pm;
  };

  // Formula budget: total surplus/deficit across scoring stats at current pace
  const getFormulaBudget = (setData, fa) => {
    if (!fa?.hasEnoughData || !setData) return null;
    const st = getSetTotals(setData);
    const totalPts = (setData.ourScore || 0) + (setData.theirScore || 0);
    const paceThrough = totalPts > 0 ? Math.min(totalPts / 50, 1) : 0;
    if (paceThrough === 0) return null;
    let total = 0;
    for (const s of fa.analysis) {
      if (!s.scoring || Math.abs(s.diff) < 0.3) continue;
      const current = st[s.key] || 0;
      const expected = parseFloat(s.winAvg) * paceThrough;
      total += current - expected;
    }
    return Math.round(total * 10) / 10;
  };

  // ═══════════════════════════════════════════════════
  // RENDER
  // ═══════════════════════════════════════════════════

  // ── ROOM SELECTION SCREEN ────────────────────────────
  if (!roomCode) {
    const enterRoom = (code) => {
      const clean = code.trim().toUpperCase().replace(/[^A-Z0-9]/g, "");
      if (clean.length < 2) return;
      setRoomCode(clean);
      setLoaded(false);
    };
    const generateCode = () => {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    };

    return (
      <div style={{ minHeight: "100vh", minHeight: "100dvh", background: "#0a0a0f", color: "#e2e8f0", fontFamily: "'SF Pro Display',-apple-system,BlinkMacSystemFont,sans-serif", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", padding: 20 }}>
        <h1 style={{ fontSize: 26, fontWeight: 800, letterSpacing: 3, color: "#fff", marginBottom: 2 }}>FORMULA</h1>
        <p style={{ fontSize: 10, opacity: 0.5, letterSpacing: 1, color: "#fff", marginBottom: 28 }}>by PRV<span style={{ color: "#007bff" }}>8</span></p>

        <div style={{ width: "100%", maxWidth: 260 }}>
          <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>ENTER ROOM CODE</div>
          <input
            style={{ display: "block", width: "100%", padding: 12, background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", fontSize: 18, fontWeight: 700, letterSpacing: 3, textTransform: "uppercase", textAlign: "center", marginBottom: 8, boxSizing: "border-box" }}
            value={roomInput}
            onChange={(e) => setRoomInput(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 16))}
            placeholder="ROOM"
            onKeyDown={(e) => { if (e.key === "Enter") enterRoom(roomInput); }}
          />
          <button
            style={{ display: "block", width: "100%", padding: 12, background: "#007bff", border: "none", borderRadius: 10, color: "#fff", fontSize: 15, fontWeight: 800, cursor: "pointer", marginBottom: 10, opacity: roomInput.trim().length < 2 ? 0.3 : 1, boxSizing: "border-box" }}
            disabled={roomInput.trim().length < 2}
            onClick={() => enterRoom(roomInput)}>
            JOIN ROOM
          </button>
          <button
            style={{ display: "block", width: "100%", padding: 10, background: "none", border: "1px solid #007bff", borderRadius: 10, color: "#007bff", fontSize: 13, fontWeight: 700, cursor: "pointer", letterSpacing: 1, marginBottom: 20, boxSizing: "border-box" }}
            onClick={() => { const c = generateCode(); setRoomInput(c); enterRoom(c); }}>
            CREATE NEW ROOM
          </button>

          {recentRooms.length > 0 && (
            <div style={{ marginBottom: 20 }}>
              <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>RECENT ROOMS</div>
              <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
                {recentRooms.map((r) => (
                  <button key={r} style={{ padding: "6px 12px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", fontSize: 12, fontWeight: 700, letterSpacing: 2, cursor: "pointer" }}
                    onClick={() => enterRoom(r)}>{r}</button>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  if (!loaded) {
    return <div style={S.container}><div style={S.loading}>Loading...</div></div>;
  }


  // ── HOME SCREEN ─────────────────────────────────────
  if (screen === "home") {
    return (
      <div style={S.container}>
        <div style={S.header}>
          <div style={S.logoRow}>
            <div>
              <h1 style={S.logoTitle}>FORMULA</h1>
              <p style={S.logoSub}>by PRV<span style={{ color: "#007bff" }}>8</span></p>
            </div>
          </div>
          <button style={{ background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#007bff", padding: "6px 12px", fontSize: 11, fontWeight: 700, letterSpacing: 2, cursor: "pointer" }}
            onClick={() => { setRoomCode(null); setLoaded(false); setMatches([]); setSavedTeams([]); setScoutSessions([]); setPractices([]); setCurrentMatch(null); setScreen("home"); setActiveTeamId(null); setRoomInput(""); }}>
            {roomCode}
          </button>
        </div>

        <div style={S.pad}>
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 14 }}>
            <h3 style={{ ...S.sectionTitle, margin: 0 }}>My Teams</h3>
            <button style={S.addTeamBtn} onClick={createTeam}>+ New Team</button>
          </div>

          {savedTeams.length === 0 ? (
            <div style={S.emptyTeam}>
              <p style={{ margin: 0, fontSize: 14, opacity: 0.5 }}>No teams yet</p>
              <p style={{ margin: "4px 0 0", fontSize: 12, opacity: 0.35 }}>Create a team to start tracking stats</p>
            </div>
          ) : (
            savedTeams.map((team) => {
              const playerCount = ((team.players||[])).filter((p) => p.number).length;
              const teamMatches = matches.filter((m) => m.teamId === team.id);
              if (matches.length > 0 && teamMatches.length === 0) {
                console.log("[Debug] Team has 0 matches. team.id:", JSON.stringify(team.id), "typeof:", typeof team.id);
                console.log("[Debug] All match teamIds:", matches.map((m) => ({ teamId: m.teamId, type: typeof m.teamId })));
              }
              const setsW = teamMatches.reduce((t, m) => t + ((m.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length, 0);
              const setsL = teamMatches.reduce((t, m) => t + ((m.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length, 0);
              return (
                <div key={team.id} style={{ ...S.teamCard, cursor: "pointer" }}
                  onClick={() => { setActiveTeamId(team.id); navigate("teamHome"); }}>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <span style={{ fontWeight: 700, fontSize: 16 }}>{team.name}</span>
                    {teamMatches.length > 0 && (
                      <span style={{ fontSize: 12, fontWeight: 700, color: setsW >= setsL ? "#22c55e" : "#ef4444" }}>{setsW}W - {setsL}L</span>
                    )}
                  </div>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 6 }}>
                    <div style={{ display: "flex", flexWrap: "wrap", gap: 4 }}>
                      {((team.players||[])).filter((p) => p.number).slice(0, 6).map((p, i) => (
                        <span key={i} style={S.rosterChip}>#{p.number}</span>
                      ))}
                      {playerCount > 6 && <span style={{ ...S.rosterChip, opacity: 0.4 }}>+{playerCount - 6}</span>}
                    </div>
                    <span style={{ fontSize: 11, opacity: 0.3 }}>{teamMatches.length} match{teamMatches.length !== 1 ? "es" : ""}</span>
                  </div>
                </div>
              );
            })
          )}

          {/* Quick match without team */}
          <button style={{ ...S.newMatchBtn, marginTop: 16 }} onClick={() => { setCurrentMatch(emptyMatch()); setSetupStep("roster"); navigate("setup"); }}>
            + Quick Match
          </button>
        </div>
      </div>
    );
  }

  // ── TEAM HOMEPAGE SCREEN ────────────────────────────
  if (screen === "teamHome" && activeTeamId) {
    const team = savedTeams.find((t) => t.id === activeTeamId);
    if (!team) { console.log("[Debug] Team not found, id:", activeTeamId, "savedTeams:", savedTeams.map(t => t.id)); setScreen("home"); return null; }
    const teamMatches = matches.filter((m) => m.teamId === team.id);
    const teamPractices = practices.filter((p) => p.teamId === team.id);
    const rosterP = (team.players || []).filter((p) => p.number);
    console.log("[Debug] Team homepage:", team.name, "id:", team.id, "teamMatches:", teamMatches.length, "players:", rosterP.length);

    try {

    // Aggregate completed sets for formula
    const wonSets = [], lostSets = [];
    for (const m of teamMatches) {
      for (const s of (m.sets || [])) {
        if (!s.complete) continue;
        const totals = getSetTotals(s);
        if (s.ourScore > s.theirScore) wonSets.push(totals);
        else lostSets.push(totals);
      }
    }
    const totalSets = wonSets.length + lostSets.length;
    const hasFormula = wonSets.length >= 1 && lostSets.length >= 1;

    // Build formula analysis for this team
    const statKeys = [
      { key: "kill", label: "Kills", scoring: true },
      { key: "ace", label: "Aces", scoring: true },
      { key: "stuff_block", label: "Stuff Blocks", scoring: true },
      { key: "opponent_error", label: "Opp Errors", scoring: true },
      { key: "attack_error", label: "Attack Errors", scoring: false },
      { key: "ball_error", label: "Ball Handling Errors", scoring: false },
      { key: "serve_error", label: "Serve Errors", scoring: false },
      { key: "attack_blocked", label: "Attacks Blocked", scoring: false },
      { key: "dig", label: "Digs", scoring: true },
      { key: "cvr", label: "Covers", scoring: true },
      { key: "assist", label: "Assists", scoring: true },
    ];
    const formulaRows = [];
    const lossRows = [];
    if (hasFormula) {
      for (const sk of statKeys) {
        const wAvg = wonSets.reduce((t, s) => t + (s[sk.key] || 0), 0) / wonSets.length;
        const lAvg = lostSets.reduce((t, s) => t + (s[sk.key] || 0), 0) / lostSets.length;
        const diff = parseFloat((wAvg - lAvg).toFixed(1));
        formulaRows.push({ ...sk, wAvg: wAvg.toFixed(1), lAvg: lAvg.toFixed(1), diff, target: wAvg.toFixed(1) });
      }
      formulaRows.sort((a, b) => Math.abs(b.diff) - Math.abs(a.diff));
    }

    // Cumulative player stats across all team matches
    const playerSeasonStats = {};
    for (const m of teamMatches) {
      for (const s of (m.sets || [])) {
        for (const ev of (s.events || [])) {
          if (ev.stat === "serve_in") continue;
          const pid = ev.player;
          if (!playerSeasonStats[pid]) playerSeasonStats[pid] = {};
          playerSeasonStats[pid][ev.stat] = (playerSeasonStats[pid][ev.stat] || 0) + 1;
        }
      }
    }

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={goBack}>&#8592;</button>
          <h1 style={{ ...S.headerTitle, flex: 1 }}>{team.name}</h1>
          <button style={{ background: "none", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", padding: "6px 10px", cursor: "pointer", fontSize: 13 }}
            onClick={() => { setEditingTeam({ ...team, players: [...team.players] }); navigate("editTeam"); }}>
            Settings
          </button>
        </div>

        <div style={S.pad}>
          {/* Record summary */}
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 8, marginBottom: 16 }}>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800 }}>{teamMatches.length}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>MATCHES</div>
            </div>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{wonSets.length}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>SETS WON</div>
            </div>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{lostSets.length}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>SETS LOST</div>
            </div>
          </div>

          {/* WINNING FORMULA */}
          <div style={S.card}>
            <h3 style={S.cardTitle}>WINNING FORMULA</h3>
            {!hasFormula ? (
              <div style={{ textAlign: "center", padding: "12px 8px" }}>
                <div style={{ fontSize: 12, opacity: 0.5, marginBottom: 4 }}>
                  {totalSets === 0 ? "No completed sets yet." : `${totalSets} set${totalSets > 1 ? "s" : ""} completed — need both wins and losses to build formula.`}
                </div>
                <div style={{ fontSize: 11, opacity: 0.35 }}>Play more matches to unlock your team's winning formula.</div>
              </div>
            ) : (
              <>
                <p style={S.cardSub}>Stat targets based on {wonSets.length} won sets</p>
                {formulaRows.filter((r) => r.scoring && Math.abs(r.diff) >= 0.3).slice(0, 5).map((r) => (
                  <div key={r.key} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "6px 0", borderBottom: "1px solid #1a1a24" }}>
                    <span style={{ fontWeight: 700, fontSize: 12 }}>{r.label}</span>
                    <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                      <span style={{ fontSize: 18, fontWeight: 800, color: "#22c55e" }}>{r.target}</span>
                      <span style={{ fontSize: 10, opacity: 0.4 }}>per set</span>
                    </div>
                  </div>
                ))}
              </>
            )}
          </div>

          {/* LOSS PATTERNS */}
          {hasFormula && (
            <div style={S.card}>
              <h3 style={{ ...S.cardTitle, color: "#ef4444" }}>LOSS PATTERNS</h3>
              <p style={S.cardSub}>Common stat lines in {lostSets.length} lost sets</p>
              {formulaRows.filter((r) => !r.scoring && Math.abs(r.diff) >= 0.3).slice(0, 4).map((r) => (
                <div key={r.key} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "6px 0", borderBottom: "1px solid #1a1a24" }}>
                  <span style={{ fontWeight: 700, fontSize: 12 }}>{r.label}</span>
                  <div style={{ display: "flex", gap: 12, alignItems: "center" }}>
                    <span style={{ fontSize: 11, color: "#ef4444" }}>Loss avg: {r.lAvg}</span>
                    <span style={{ fontSize: 11, color: "#22c55e" }}>Win avg: {r.wAvg}</span>
                  </div>
                </div>
              ))}
              {/* Top scoring stat that drops in losses */}
              {(() => {
                const drop = formulaRows.find((r) => r.scoring && r.diff > 1);
                if (!drop) return null;
                return (
                  <div style={{ ...S.insightBox, marginTop: 8 }}>
                    <div style={S.insightLabel}>KEY FACTOR</div>
                    <div style={{ fontSize: 12, opacity: 0.8 }}>
                      In losses, {drop.label.toLowerCase()} drop to {drop.lAvg}/set vs {drop.wAvg}/set in wins — a difference of {Math.abs(drop.diff).toFixed(1)}.
                    </div>
                  </div>
                );
              })()}
            </div>
          )}

          {/* ACTION BUTTONS */}
          <div style={{ display: "flex", gap: 8, marginBottom: 8, marginTop: 4 }}>
            <button style={{ ...S.primaryBtn, flex: 1, margin: 0 }} onClick={() => startMatchWithTeam(team)}>
              New Match
            </button>
            <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#0056b3" }} onClick={() => {
              const practice = {
                id: Date.now().toString(), teamId: team.id, teamName: team.name,
                date: new Date().toISOString().split("T")[0],
                name: "Practice " + new Date().toLocaleDateString(), rounds: [],
              };
              setCurrentPractice(practice);
              setPracticeRound(null);
              setPracticePasserPick(true);
              navigate("practice");
            }}>
              Practice
            </button>
          </div>

          {/* PLAYER STATS */}
          {Object.keys(playerSeasonStats).length > 0 && (
            <div style={S.card}>
              <h3 style={S.cardTitle}>SEASON PLAYER STATS</h3>
              <p style={S.cardSub}>Cumulative across {teamMatches.length} match{teamMatches.length !== 1 ? "es" : ""}</p>
              <div style={{ overflowX: "auto" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>K</th>
                      <th style={S.sth}>AE</th>
                      <th style={S.sth}>ATT</th>
                      <th style={S.sth}>PCT</th>
                      <th style={S.sth}>A</th>
                      <th style={S.sth}>SA</th>
                      <th style={S.sth}>SE</th>
                      <th style={S.sth}>DIG</th>
                      <th style={S.sth}>CV</th>
                      <th style={S.sth}>BS</th>
                      <th style={S.sth}>BE</th>
                    </tr>
                  </thead>
                  <tbody>
                    {Object.entries(playerSeasonStats)
                      .map(([pid, stats]) => {
                        // Find player name from any match roster
                        let pName = pid, pNum = "";
                        for (const m of teamMatches) {
                          const found = m.roster?.find((r) => r.id === pid);
                          if (found) { pName = found.name?.split(" ")[0] || pid; pNum = found.number; break; }
                        }
                        const k = stats.kill || 0, e = stats.attack_error || 0, blkd = stats.attack_blocked || 0;
                        const att = k + e + blkd;
                        const pct = att > 0 ? (k - e) / att : null;
                        return { pid, pName, pNum, k, e, att, pct, a: stats.assist || 0, sa: stats.ace || 0, se: stats.serve_error || 0, dig: stats.dig || 0, cvr: stats.cvr || 0, bs: stats.stuff_block || 0, be: stats.ball_error || 0 };
                      })
                      .sort((a, b) => b.k - a.k)
                      .map((p) => (
                        <tr key={p.pid}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap", textAlign: "left" }}>{p.pName} <span style={{ opacity: 0.4, fontWeight: 400 }}>#{p.pNum}</span></td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{p.k}</td>
                          <td style={{ ...S.std, color: "#ef4444" }}>{p.e}</td>
                          <td style={S.std}>{p.att}</td>
                          <td style={{ ...S.std, fontWeight: 700, color: p.pct !== null ? (p.pct >= 0.2 ? "#22c55e" : p.pct >= 0 ? "#fff" : "#ef4444") : "#6b7280" }}>
                            {p.pct !== null ? (p.pct >= 0 ? "." : "-.") + Math.abs(Math.round(p.pct * 1000)).toString().padStart(3, "0") : "-"}
                          </td>
                          <td style={S.std}>{p.a || "-"}</td>
                          <td style={S.std}>{p.sa || "-"}</td>
                          <td style={S.std}>{p.se || "-"}</td>
                          <td style={S.std}>{p.dig || "-"}</td>
                          <td style={{ ...S.std, color: "#60a5fa" }}>{p.cvr || "-"}</td>
                          <td style={S.std}>{p.bs || "-"}</td>
                          <td style={{ ...S.std, color: p.be > 0 ? "#ef4444" : "#6b7280" }}>{p.be || "-"}</td>
                        </tr>
                      ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {/* SCOUT OPPONENT */}
          <div style={{ marginBottom: 16 }}>
            <h3 style={S.sectionTitle}>Scout Opponent</h3>
            <div style={{ display: "flex", gap: 6, marginBottom: 10 }}>
              <input
                style={{ ...S.input, flex: 1, margin: 0 }}
                placeholder="Opponent name..."
                value={scoutNameInput}
                onChange={(e) => setScoutNameInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && scoutNameInput.trim()) {
                    const session = { id: Date.now().toString(), name: scoutNameInput.trim(), shots: [], created: new Date().toISOString().split("T")[0] };
                    setCurrentScout(session);
                    setScoutView("input");
                    setScoutPending(null);
                    setScoutNameInput("");
                    navigate("scout");
                  }
                }}
              />
              <button style={S.addTeamBtn} onClick={() => {
                if (!scoutNameInput.trim()) { showToast("Enter opponent name"); return; }
                const session = { id: Date.now().toString(), name: scoutNameInput.trim(), shots: [], created: new Date().toISOString().split("T")[0] };
                setCurrentScout(session);
                setScoutView("input");
                setScoutPending(null);
                setScoutNameInput("");
                navigate("scout");
              }}>+ Scout</button>
            </div>
            {scoutSessions.map((s) => {
              const kills = (s.shots || []).filter((sh) => sh.outcome === "kill").length;
              const total = (s.shots || []).length;
              return (
                <div key={s.id} style={S.teamCard}>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <div>
                      <span style={{ fontWeight: 700, fontSize: 14 }}>{s.name}</span>
                      <span style={{ fontSize: 11, opacity: 0.4, marginLeft: 8 }}>{s.created}</span>
                    </div>
                    <span style={{ fontSize: 11, opacity: 0.5 }}>{total} shots</span>
                  </div>
                  <div style={{ display: "flex", gap: 6, marginTop: 8 }}>
                    <button style={S.teamActionBtn} onClick={() => {
                      setCurrentScout({ ...s });
                      setScoutView(total > 0 ? "heatmap" : "input");
                      setScoutPending(null);
                      navigate("scout");
                    }}>
                      {total > 0 ? "View / Edit" : "Start Scouting"}
                    </button>
                    <button style={{ ...S.teamActionBtn, background: "#1a1a24", color: "#ef4444" }}
                      onClick={() => { saveScoutSessions(scoutSessions.filter((x) => x.id !== s.id)); showToast("Deleted"); }}>
                      Remove
                    </button>
                  </div>
                </div>
              );
            })}
          </div>

          {/* RECENT MATCHES */}
          <h3 style={S.sectionTitle}>Match History</h3>
          {teamMatches.length === 0 ? (
            <div style={{ textAlign: "center", padding: 20, opacity: 0.4, fontSize: 13 }}>No matches yet</div>
          ) : (
            teamMatches.slice().reverse().map((m) => {
              const setScores = ((m.sets||[])).map((s) => `${s.ourScore}-${s.theirScore}`).join(", ");
              const won = ((m.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length;
              const lost = ((m.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length;
              const isComplete = m.complete;
              const matchWon = won > lost;
              return (
                <div key={m.id} style={{ ...S.card, marginBottom: 8, display: "flex", alignItems: "center", gap: 8, borderLeft: isComplete ? `3px solid ${matchWon ? "#22c55e" : "#ef4444"}` : "3px solid #007bff" }}>
                  <div style={{ flex: 1, cursor: "pointer" }}
                    onClick={() => {
                      setCurrentMatch(m);
                      setCurrentSetIdx(Math.max(0, ((m.sets||[])).length - 1));
                      if (isComplete) {
                        navigate("matchComplete");
                      } else {
                        setTab("court");
                        navigate("match");
                      }
                    }}>
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                      <div>
                        <span style={{ fontWeight: 700, fontSize: 14 }}>vs {m.opponent || "\u2014"}</span>
                        {!isComplete && <span style={{ fontSize: 9, fontWeight: 800, color: "#007bff", marginLeft: 6, padding: "1px 5px", border: "1px solid #007bff", borderRadius: 4 }}>LIVE</span>}
                        <span style={{ fontSize: 11, opacity: 0.4, marginLeft: 8 }}>{m.date}</span>
                      </div>
                      <div style={{ textAlign: "right" }}>
                        <div style={{ fontWeight: 800, color: won > lost ? "#22c55e" : won < lost ? "#ef4444" : "#007bff" }}>
                          {won}-{lost}
                        </div>
                        {isComplete && <div style={{ fontSize: 9, fontWeight: 700, color: matchWon ? "#22c55e" : "#ef4444" }}>{matchWon ? "W" : "L"}</div>}
                      </div>
                    </div>
                    <div style={{ fontSize: 11, opacity: 0.5, marginTop: 4 }}>{setScores}</div>
                  </div>
                  <button style={{ background: "none", border: "none", color: "#ef4444", fontSize: 18, padding: "4px 8px", cursor: "pointer", opacity: 0.4, flexShrink: 0 }}
                    onClick={(e) => { e.stopPropagation(); if (confirm(`Delete match vs ${m.opponent || "—"}?`)) deleteMatch(m.id); }}>
                    ✕
                  </button>
                </div>
              );
            })
          )}

          {/* Practice history */}
          {teamPractices.length > 0 && (
            <>
              <h3 style={{ ...S.sectionTitle, marginTop: 16 }}>Practice History</h3>
              {teamPractices.slice().reverse().map((p) => {
                const totalPasses = ((p.rounds||[])).reduce((t, r) => t + (r.events||[]).length, 0);
                return (
                  <div key={p.id} style={{ ...S.card, marginBottom: 8, display: "flex", alignItems: "center", gap: 8 }}>
                    <div style={{ flex: 1, cursor: "pointer" }}
                      onClick={() => { setCurrentPractice(p); setPracticeRound(null); setPracticePasserPick(true); navigate("practice"); }}>
                      <div style={{ display: "flex", justifyContent: "space-between" }}>
                        <span style={{ fontWeight: 700 }}>{p.name}</span>
                        <span style={{ fontSize: 11, opacity: 0.4 }}>{p.date}</span>
                      </div>
                      <div style={{ fontSize: 11, opacity: 0.5, marginTop: 2 }}>{((p.rounds||[])).length} rounds / {totalPasses} passes</div>
                    </div>
                    <button style={{ background: "none", border: "none", color: "#ef4444", fontSize: 18, padding: "4px 8px", cursor: "pointer", opacity: 0.4, flexShrink: 0 }}
                      onClick={(e) => { e.stopPropagation(); if (confirm(`Delete practice "${p.name}"?`)) deletePractice(p.id); }}>
                      ✕
                    </button>
                  </div>
                );
              })}
            </>
          )}
        </div>
      </div>
    );
    } catch (err) {
      console.error("[TeamHome] Render error:", err);
      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={goBack}>&#8592;</button>
            <h1 style={S.headerTitle}>Error</h1>
          </div>
          <div style={S.pad}>
            <p style={{ color: "#ef4444" }}>Error loading team page. Check browser console for details.</p>
            <p style={{ fontSize: 12, opacity: 0.5, marginTop: 8 }}>{String(err)}</p>
          </div>
        </div>
      );
    }
  }

  // ── EDIT TEAM SCREEN ────────────────────────────────
  if (screen === "editTeam" && editingTeam) {
    const playerCount = editingTeam.players.filter((p) => p.number).length;
    return (
      <div style={S.container}>
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => { setEditingTeam(null); goBack(); }}>&#8592;</button>
          <h1 style={S.headerTitle}>{editingTeam.name ? `Edit: ${editingTeam.name}` : "New Team"}</h1>
        </div>
        <div style={S.pad}>
          <div style={{ marginBottom: 16 }}>
            <label style={S.label}>Team Name</label>
            <input style={S.input} placeholder="e.g. Pulse 18s, SJB Varsity"
              value={editingTeam.name}
              onChange={(e) => setEditingTeam((prev) => ({ ...prev, name: e.target.value }))} />
          </div>

          <h3 style={S.sectionTitle}>Players ({playerCount})</h3>
          <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
            {editingTeam.players.map((p, i) => (
              <div key={i} style={{ display: "flex", gap: 6, alignItems: "center" }}>
                <input style={{ ...S.input, width: 50, textAlign: "center", padding: "8px 4px" }}
                  placeholder="#" value={p.number} inputMode="numeric"
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, number: val } : pl);
                      return { ...prev, players };
                    });
                  }} />
                <input style={{ ...S.input, flex: 1 }} placeholder="Name" value={p.name}
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, name: val } : pl);
                      return { ...prev, players };
                    });
                  }} />
                <select style={{ ...S.input, width: 62, padding: "8px 2px" }} value={p.position}
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, position: val } : pl);
                      return { ...prev, players };
                    });
                  }}>
                  <option value="">Pos</option>
                  {POSITIONS.map((pos) => <option key={pos} value={pos}>{pos}</option>)}
                </select>
              </div>
            ))}
          </div>

          {/* Add more player rows */}
          <button style={{ ...S.clearBtn, marginTop: 12, borderStyle: "dashed" }}
            onClick={() => {
              setEditingTeam((prev) => ({
                ...prev,
                players: [...prev.players, ...Array.from({ length: 2 }, (_, i) => ({
                  id: `t${Date.now()}-px${prev.players.length + i}`,
                  number: "",
                  name: "",
                  position: "",
                }))],
              }));
            }}>
            + Add More Rows
          </button>

          <button style={{ ...S.primaryBtn, marginTop: 20 }} onClick={saveCurrentTeam}>
            Save Team
          </button>
        </div>
      </div>
    );
  }

  // ── SETUP SCREENS ───────────────────────────────────
  // ── MATCH COMPLETE SCREEN ────────────────────────────
  if (screen === "matchComplete") {
    const completedSets = (currentMatch?.sets || []).filter((s) => s.complete);
    const setsWon = completedSets.filter((s) => s.ourScore > s.theirScore).length;
    const setsLost = completedSets.filter((s) => s.ourScore < s.theirScore).length;
    const weWon = setsWon > setsLost;
    const rosterPlayers = ((currentMatch?.roster||[])).filter((p) => p.number);

    // Aggregate all player stats from completed sets
    const playerMatchStats = {};
    for (const s of completedSets) {
      for (const ev of (s.events || [])) {
        if (ev.stat === "serve_in") continue;
        const pid = ev.player;
        if (!pid) continue;
        if (!playerMatchStats[pid]) playerMatchStats[pid] = {};
        playerMatchStats[pid][ev.stat] = (playerMatchStats[pid][ev.stat] || 0) + 1;
      }
    }

    // Player +/- across all sets
    const matchPM = {};
    for (const s of completedSets) {
      for (const r of (s.rallies || [])) {
        if (!r.onCourt) continue;
        for (const pid of r.onCourt) {
          matchPM[pid] = (matchPM[pid] || 0) + (r.weWon ? 1 : -1);
        }
      }
    }

    // Find MVP (highest +/- with meaningful playing time)
    let mvpId = null, mvpPM = -Infinity;
    for (const [pid, pm] of Object.entries(matchPM)) {
      if (pm > mvpPM) { mvpPM = pm; mvpId = pid; }
    }
    const mvpPlayer = rosterPlayers.find((p) => p.id === mvpId);
    const mvpStats = playerMatchStats[mvpId] || {};

    return (
      <div style={S.container}>
        <div style={S.header}>
          <button style={S.backBtn} onClick={goBack}>{"\u2190"}</button>
          <h1 style={S.headerTitle}>Match Complete</h1>
        </div>
        <div style={S.pad}>
          {/* Result banner */}
          <div style={{
            ...S.card, textAlign: "center", padding: 24, marginBottom: 16,
            borderLeft: `4px solid ${weWon ? "#22c55e" : "#ef4444"}`,
          }}>
            <div style={{ fontSize: 13, opacity: 0.5, marginBottom: 4 }}>vs {currentMatch?.opponent}</div>
            <div style={{
              fontSize: 40, fontWeight: 900, letterSpacing: 2,
              color: weWon ? "#22c55e" : "#ef4444",
            }}>
              {weWon ? "WIN" : "LOSS"}
            </div>
            <div style={{ fontSize: 28, fontWeight: 800, margin: "8px 0" }}>
              {setsWon} - {setsLost}
            </div>
            <div style={{ fontSize: 12, opacity: 0.5 }}>
              {completedSets.map((s) => `${s.ourScore}-${s.theirScore}`).join("  |  ")}
            </div>
            {currentMatch?.tournament && (
              <div style={{ fontSize: 11, opacity: 0.4, marginTop: 6 }}>{currentMatch.tournament}</div>
            )}
          </div>

          {/* MVP */}
          {mvpPlayer && (
            <div style={{ ...S.card, padding: 16, marginBottom: 16, borderLeft: "4px solid #007bff" }}>
              <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 6 }}>MATCH MVP</div>
              <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
                <div>
                  <div style={{ fontSize: 18, fontWeight: 800 }}>{mvpPlayer.name?.split(" ")[0]}</div>
                  <div style={{ fontSize: 11, opacity: 0.5 }}>#{mvpPlayer.number} {mvpPlayer.position}</div>
                </div>
                <div style={{ marginLeft: "auto", textAlign: "right" }}>
                  <div style={{ fontSize: 20, fontWeight: 800, color: mvpPM > 0 ? "#22c55e" : "#ef4444" }}>
                    {mvpPM > 0 ? "+" : ""}{mvpPM}
                  </div>
                  <div style={{ fontSize: 9, opacity: 0.4 }}>+/-</div>
                </div>
              </div>
              <div style={{ display: "flex", gap: 8, marginTop: 8, flexWrap: "wrap" }}>
                {mvpStats.kill > 0 && <span style={{ fontSize: 11, color: "#22c55e", fontWeight: 700 }}>{mvpStats.kill}K</span>}
                {mvpStats.ace > 0 && <span style={{ fontSize: 11, color: "#007bff", fontWeight: 700 }}>{mvpStats.ace}A</span>}
                {mvpStats.stuff_block > 0 && <span style={{ fontSize: 11, color: "#22c55e", fontWeight: 700 }}>{mvpStats.stuff_block}SB</span>}
                {mvpStats.dig > 0 && <span style={{ fontSize: 11, fontWeight: 700 }}>{mvpStats.dig}D</span>}
                {mvpStats.assist > 0 && <span style={{ fontSize: 11, color: "#5ba3ff", fontWeight: 700 }}>{mvpStats.assist}AS</span>}
                {mvpStats.block > 0 && <span style={{ fontSize: 11, fontWeight: 700 }}>{mvpStats.block}BT</span>}
              </div>
            </div>
          )}

          {/* Set-by-set breakdown */}
          <div style={{ ...S.card, padding: 16, marginBottom: 16 }}>
            <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 10 }}>SET BREAKDOWN</div>
            {completedSets.map((s) => {
              const won = s.ourScore > s.theirScore;
              const setTotals = {};
              for (const ev of (s.events || [])) {
                if (ev.stat !== "serve_in") setTotals[ev.stat] = (setTotals[ev.stat] || 0) + 1;
              }
              return (
                <div key={s.number} style={{
                  display: "flex", alignItems: "center", gap: 12, padding: "8px 0",
                  borderBottom: "1px solid #1e1e28",
                }}>
                  <div style={{ width: 50 }}>
                    <span style={{ fontSize: 11, opacity: 0.4 }}>Set {s.number}</span>
                  </div>
                  <div style={{ fontSize: 18, fontWeight: 800, width: 60, color: won ? "#22c55e" : "#ef4444" }}>
                    {s.ourScore}-{s.theirScore}
                  </div>
                  <div style={{ flex: 1, display: "flex", gap: 6, flexWrap: "wrap", fontSize: 10, opacity: 0.6 }}>
                    <span>{setTotals.kill || 0}K</span>
                    <span>{setTotals.attack_error || 0}AE</span>
                    <span>{setTotals.ace || 0}A</span>
                    <span>{setTotals.serve_error || 0}SE</span>
                    <span>{setTotals.stuff_block || 0}SB</span>
                    <span>{setTotals.dig || 0}D</span>
                  </div>
                </div>
              );
            })}
          </div>

          {/* Team stat summary */}
          <div style={{ ...S.card, padding: 16, marginBottom: 16 }}>
            <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 10 }}>MATCH TOTALS</div>
            {(() => {
              const t = {};
              for (const s of completedSets) {
                for (const ev of (s.events || [])) {
                  if (ev.stat !== "serve_in") t[ev.stat] = (t[ev.stat] || 0) + 1;
                }
              }
              const att = (t.kill||0) + (t.attack_error||0) + (t.attack_blocked||0);
              const pct = att > 0 ? ((t.kill||0) - (t.attack_error||0)) / att : null;
              return (
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 10 }}>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{t.kill || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>KILLS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{t.attack_error || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ATT ERR</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: pct !== null && pct >= 0.2 ? "#22c55e" : pct !== null && pct >= 0 ? "#fff" : "#ef4444" }}>
                      {pct !== null ? (pct >= 0 ? "." : "-.") + Math.abs(Math.round(pct * 1000)).toString().padStart(3, "0") : "-"}
                    </div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>HIT%</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{att}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ATT</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#007bff" }}>{t.ace || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ACES</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{t.serve_error || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>SRV ERR</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{t.dig || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>DIGS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{t.stuff_block || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>STUFF BLK</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{t.block || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>BLK TCH</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#5ba3ff" }}>{t.assist || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ASSISTS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#60a5fa" }}>{t.cvr || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>COVERS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{(t.ball_error || 0) + (t.attack_error || 0)}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>TOTAL ERR</div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Actions */}
          <button style={{ ...S.primaryBtn, marginBottom: 10 }} onClick={() => {
            setTab("stats");
            navigate("match");
          }}>
            View Full Stats
          </button>
          <button style={{ ...S.clearBtn, marginBottom: 10 }} onClick={() => {
            navigate("teamHome");
          }}>
            Back to Team
          </button>
        </div>
      </div>
    );
  }

  if (screen === "setup") {
    const rosterPlayers = ((currentMatch?.roster||[])).filter((p) => p.number) || [];
    const assignedIds = Object.values(lineupSlots);
    const availableForLineup = rosterPlayers.filter((p) => !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2);
    const benchPlayers = rosterPlayers.filter((p) => !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2);

    // ROSTER
    if (setupStep === "roster") {
      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={goBack}>←</button>
            <h1 style={S.headerTitle}>Roster</h1>
          </div>
          <div style={S.pad}>
            <div style={{ marginBottom: 16 }}>
              <label style={S.label}>Opponent</label>
              <input style={S.input} placeholder="Team name" value={currentMatch?.opponent || ""}
                onChange={(e) => setCurrentMatch((p) => ({ ...p, opponent: e.target.value }))} />
            </div>
            <h3 style={S.sectionTitle}>Players</h3>
            <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
              {((currentMatch?.roster||[])).map((p, i) => (
                <div key={i} style={{ display: "flex", gap: 6, alignItems: "center" }}>
                  <input style={{ ...S.input, width: 50, textAlign: "center", padding: "8px 4px" }}
                    placeholder="#" value={p.number} inputMode="numeric"
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, number: val } : pl);
                        return { ...prev, roster };
                      });
                    }} />
                  <input style={{ ...S.input, flex: 1 }} placeholder="Name" value={p.name}
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, name: val } : pl);
                        return { ...prev, roster };
                      });
                    }} />
                  <select style={{ ...S.input, width: 62, padding: "8px 2px" }} value={p.position}
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, position: val } : pl);
                        return { ...prev, roster };
                      });
                    }}>
                    <option value="">Pos</option>
                    {POSITIONS.map((pos) => <option key={pos} value={pos}>{pos}</option>)}
                  </select>
                </div>
              ))}
            </div>
            <button style={{ ...S.primaryBtn, marginTop: 20 }}
              onClick={() => { setLineupSlots({}); setLineupPositions({}); setSelectedLibero(null); setSelectedLibero2(null); setMbBackRowMap({}); setSelectingPos(null); setSelectingLibero(null); setSetupStep("lineup"); }}
              disabled={rosterPlayers.length < 6}>
              Set Lineup →
            </button>
          </div>
        </div>
      );
    }

    // LINEUP
    if (setupStep === "lineup") {

      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={() => setSetupStep("roster")}>←</button>
            <h1 style={S.headerTitle}>Starting Lineup</h1>
          </div>
          <div style={S.pad}>
            {/* Court diagram */}
            <div style={S.courtSetup}>
              <div style={S.netLabel}>── NET ──</div>
              <div style={S.courtGrid}>
                {[4, 3, 2, 5, 6, 1].map((pos) => {
                  const player = lineupSlots[pos] ? getPlayerById(lineupSlots[pos]) || rosterPlayers.find(p => p.id === lineupSlots[pos]) : null;
                  const slot = COURT_POS[pos];
                  const effPos = player ? (lineupPositions[player.id] || player.position) : "";
                  return (
                    <button key={pos} style={{
                      ...S.courtSlot,
                      ...(selectingPos === pos ? S.courtSlotActive : {}),
                      ...(player ? S.courtSlotFilled : {}),
                    }}
                      onClick={() => { setSelectingPos(pos); setSelectingLibero(null); }}>
                      <span style={S.courtPosLabel}>{pos}</span>
                      {player ? (
                        <>
                          <span style={S.courtPlayerNum}>{player.name?.split(" ")[0] || player.position}</span>
                          <span style={{ fontSize: 9, color: "#007bff", fontWeight: 700 }}>{effPos}</span>
                          <span style={S.courtPlayerName}>#{player.number}</span>
                        </>
                      ) : (
                        <span style={{ fontSize: 11, opacity: 0.4 }}>Tap to set</span>
                      )}
                    </button>
                  );
                })}
              </div>
            </div>

            {/* Position overrides */}
            {Object.keys(lineupSlots).length > 0 && (
              <div style={{ marginBottom: 12 }}>
                <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
                  MATCH POSITIONS
                </span>
                <div style={{ fontSize: 10, opacity: 0.4, marginBottom: 6 }}>
                  Defaults to roster position. Tap to change for this match.
                </div>
                <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                  {Object.entries(lineupSlots).map(([pos, pid]) => {
                    const p = rosterPlayers.find((r) => r.id === pid);
                    if (!p) return null;
                    const effPos = lineupPositions[pid] || p.position;
                    const isChanged = effPos !== p.position;
                    return (
                      <div key={pos} style={{ display: "flex", alignItems: "center", gap: 8, padding: "6px 10px", background: "#111118", borderRadius: 8, border: isChanged ? "1px solid #007bff" : "1px solid #1e1e28" }}>
                        <span style={{ fontSize: 12, fontWeight: 700, width: 70 }}>{p.name?.split(" ")[0]}</span>
                        <div style={{ display: "flex", gap: 4, flex: 1 }}>
                          {POSITIONS.filter((pos) => pos !== "L" && pos !== "DS").map((posOpt) => (
                            <button key={posOpt} style={{
                              padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                              background: effPos === posOpt ? "#007bff" : "#1a1a24",
                              color: effPos === posOpt ? "#fff" : "#6b7280",
                            }} onClick={() => {
                              setLineupPositions((prev) => ({ ...prev, [pid]: posOpt }));
                            }}>{posOpt}</button>
                          ))}
                        </div>
                        {isChanged && <span style={{ fontSize: 9, color: "#007bff", opacity: 0.6 }}>was {p.position}</span>}
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Libero slots */}
            <div style={{ marginTop: 12, marginBottom: 12 }}>
              <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>LIBEROS</span>
              <div style={{ display: "flex", gap: 8 }}>
                {/* Libero 1 */}
                <button style={{
                  ...S.courtSlot, flex: 1,
                  ...(selectingLibero === 1 ? S.courtSlotActive : {}),
                  ...(selectedLibero ? S.courtSlotFilled : {}),
                  background: selectedLibero ? "#1e3320" : "#111118",
                  borderColor: selectedLibero ? "#22c55e" : selectingLibero === 1 ? "#007bff" : "#1e1e28",
                }}
                  onClick={() => { setSelectingLibero(1); setSelectingPos(null); }}>
                  <span style={{ ...S.courtPosLabel, color: "#22c55e" }}>L1</span>
                  {selectedLibero ? (
                    <>
                      <span style={S.courtPlayerNum}>{rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "Libero"}</span>
                      <span style={S.courtPlayerName}>#{rosterPlayers.find(p => p.id === selectedLibero)?.number}</span>
                    </>
                  ) : (
                    <span style={{ fontSize: 11, opacity: 0.4 }}>Tap to set</span>
                  )}
                </button>
                {/* Libero 2 */}
                <button style={{
                  ...S.courtSlot, flex: 1,
                  ...(selectingLibero === 2 ? S.courtSlotActive : {}),
                  ...(selectedLibero2 ? S.courtSlotFilled : {}),
                  background: selectedLibero2 ? "#1e3320" : "#111118",
                  borderColor: selectedLibero2 ? "#22c55e" : selectingLibero === 2 ? "#007bff" : "#1e1e28",
                }}
                  onClick={() => { if (!selectedLibero) { showToast("Set Libero 1 first"); return; } setSelectingLibero(2); setSelectingPos(null); }}>
                  <span style={{ ...S.courtPosLabel, color: "#22c55e" }}>L2</span>
                  {selectedLibero2 ? (
                    <>
                      <span style={S.courtPlayerNum}>{rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "Libero 2"}</span>
                      <span style={S.courtPlayerName}>#{rosterPlayers.find(p => p.id === selectedLibero2)?.number}</span>
                    </>
                  ) : (
                    <span style={{ fontSize: 10, opacity: 0.3 }}>Optional</span>
                  )}
                </button>
              </div>
              {/* Remove libero buttons */}
              {(selectedLibero || selectedLibero2) && (
                <div style={{ display: "flex", gap: 6, marginTop: 6 }}>
                  {selectedLibero && (
                    <button style={{ ...S.clearBtn, fontSize: 10, padding: "4px 8px" }} onClick={() => {
                      setSelectedLibero(null); setSelectedLibero2(null); setMbBackRowMap({});
                    }}>Remove L1</button>
                  )}
                  {selectedLibero2 && (
                    <button style={{ ...S.clearBtn, fontSize: 10, padding: "4px 8px" }} onClick={() => {
                      setSelectedLibero2(null);
                      // Reset any MB assignments to libero2
                      setMbBackRowMap((prev) => {
                        const n = { ...prev };
                        for (const k of Object.keys(n)) { if (n[k] === "libero2") n[k] = "libero1"; }
                        return n;
                      });
                    }}>Remove L2</button>
                  )}
                </div>
              )}
            </div>

            {/* MB Back Row Assignment — only show if liberos are set and MBs exist */}
            {selectedLibero && (() => {
              const mbsInLineup = Object.entries(lineupSlots).map(([pos, pid]) => {
                const p = rosterPlayers.find((r) => r.id === pid);
                const effPos = lineupPositions[pid] || p?.position;
                return p && effPos === "MB" ? { pos: Number(pos), player: p } : null;
              }).filter(Boolean);
              if (mbsInLineup.length === 0) return null;
              const lib1Name = rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "L1";
              const lib2Name = selectedLibero2 ? (rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "L2") : null;
              return (
                <div style={{ marginBottom: 12 }}>
                  <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
                    MB BACK ROW REPLACEMENT
                  </span>
                  <div style={{ fontSize: 10, opacity: 0.4, marginBottom: 6 }}>
                    Choose who replaces each MB when they rotate to the back row.
                  </div>
                  {mbsInLineup.map((mb) => {
                    const assignment = mbBackRowMap[mb.player.id] || "libero1";
                    return (
                      <div key={mb.player.id} style={{ display: "flex", alignItems: "center", gap: 6, padding: "8px 10px", background: "#111118", borderRadius: 8, marginBottom: 4, border: "1px solid #1e1e28" }}>
                        <span style={{ fontSize: 12, fontWeight: 700, width: 60 }}>{mb.player.name?.split(" ")[0]}</span>
                        <div style={{ display: "flex", gap: 4, flex: 1 }}>
                          <button style={{
                            padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                            background: assignment === "libero1" ? "#22c55e" : "#1a1a24",
                            color: assignment === "libero1" ? "#000" : "#6b7280",
                          }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "libero1" }))}>{lib1Name}</button>
                          {selectedLibero2 && (
                            <button style={{
                              padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                              background: assignment === "libero2" ? "#22c55e" : "#1a1a24",
                              color: assignment === "libero2" ? "#000" : "#6b7280",
                            }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "libero2" }))}>{lib2Name}</button>
                          )}
                          <button style={{
                            padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                            background: assignment === "self" ? "#854d0e" : "#1a1a24",
                            color: assignment === "self" ? "#fff" : "#6b7280",
                          }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "self" }))}>Plays BR</button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              );
            })()}

            {/* Player picker */}
            {(selectingPos || selectingLibero) && (
              <div style={S.pickerBox}>
                <span style={S.pickerLabel}>
                  {selectingLibero ? `Select Libero ${selectingLibero}` : `Select player for position ${selectingPos}`}
                </span>
                <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
                  {sortByPosition(rosterPlayers
                    .filter((p) => {
                      if (selectingLibero) return !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2;
                      return !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2;
                    }))
                    .map((p) => (
                      <button key={p.id} style={S.pickerPlayer} onClick={() => {
                        if (selectingLibero === 1) {
                          setSelectedLibero(p.id);
                          setSelectingLibero(null);
                        } else if (selectingLibero === 2) {
                          setSelectedLibero2(p.id);
                          setSelectingLibero(null);
                        } else {
                          setLineupSlots((prev) => ({ ...prev, [selectingPos]: p.id }));
                          setLineupPositions((prev) => ({ ...prev, [p.id]: p.position }));
                          setSelectingPos(null);
                        }
                      }}>
                        <span style={{ fontWeight: 800, fontSize: 14 }}>{p.name?.split(" ")[0]}</span>
                        <span style={{ fontSize: 10, opacity: 0.5 }}>#{p.number}</span>
                        <span style={{ fontSize: 10, color: "#007bff" }}>{p.position}</span>
                      </button>
                    ))}
                </div>
                {/* Also allow removing current assignment */}
                {selectingPos && lineupSlots[selectingPos] && (
                  <button style={{ ...S.clearBtn, marginTop: 8, padding: "6px 12px" }} onClick={() => {
                    const pid = lineupSlots[selectingPos];
                    setLineupSlots(prev => { const n = { ...prev }; delete n[selectingPos]; return n; });
                    if (pid) setLineupPositions(prev => { const n = { ...prev }; delete n[pid]; return n; });
                    setSelectingPos(null);
                  }}>Remove from position</button>
                )}
              </div>
            )}

            <button style={{ ...S.primaryBtn, marginTop: 16 }}
              onClick={() => setSetupStep("options")}
              disabled={Object.keys(lineupSlots).length < 6}>
              Set Options →
            </button>
          </div>
        </div>
      );
    }

    // OPTIONS
    if (setupStep === "options") {
      const firstServerId = weServeFirst ? lineupSlots[1] : lineupSlots[2];
      const serverPlayer = firstServerId ? (getPlayerById(firstServerId) || rosterPlayers.find(p => p.id === firstServerId)) : null;

      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={() => setSetupStep("lineup")}>←</button>
            <h1 style={S.headerTitle}>Set Options</h1>
          </div>
          <div style={S.pad}>
            {/* Match Format */}
            <div style={{ display: "flex", gap: 8, marginBottom: 20 }}>
              <button style={{ ...S.optionBtn, ...(currentMatch?.format === 3 ? S.optionBtnActive : {}) }}
                onClick={() => setCurrentMatch((p) => ({ ...p, format: 3 }))}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Best of 3</span>
              </button>
              <button style={{ ...S.optionBtn, ...(currentMatch?.format === 5 ? S.optionBtnActive : {}) }}
                onClick={() => setCurrentMatch((p) => ({ ...p, format: 5 }))}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Best of 5</span>
              </button>
            </div>

            {/* Serve or Receive */}
            <div style={{ display: "flex", gap: 8, marginBottom: 20 }}>
              <button style={{ ...S.optionBtn, ...(weServeFirst ? S.optionBtnActive : {}) }}
                onClick={() => setWeServeFirst(true)}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Serve</span>
              </button>
              <button style={{ ...S.optionBtn, ...(!weServeFirst ? S.optionBtnActive : {}) }}
                onClick={() => setWeServeFirst(false)}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Receive</span>
              </button>
            </div>

            {/* First server info */}
            <div style={S.infoCard}>
              <span style={{ fontSize: 12, opacity: 0.5, display: "block", marginBottom: 4 }}>
                {weServeFirst ? "FIRST SERVER" : "FIRST SERVER (on sideout)"}
              </span>
              <span style={{ fontSize: 20, fontWeight: 800 }}>
                {serverPlayer?.name?.split(" ")[0]} <span style={{ fontSize: 14, opacity: 0.5 }}>#{serverPlayer?.number}</span>
              </span>
              <span style={{ fontSize: 12, opacity: 0.5, marginTop: 4, display: "block" }}>
                {weServeFirst
                  ? "Player in zone 1 serves first."
                  : "Player in zone 2 — rotates into zone 1 on sideout."}
              </span>
            </div>

            {/* Libero Serving — pick which MB rotation each libero serves for */}
            {selectedLibero && (() => {
              const mbsInLineup = Object.entries(lineupSlots).map(([pos, pid]) => {
                const p = rosterPlayers.find((r) => r.id === pid);
                const effPos = lineupPositions[pid] || p?.position;
                return p && effPos === "MB" ? { pos: Number(pos), player: p } : null;
              }).filter(Boolean);
              if (mbsInLineup.length < 2) return null;

              // Get liberos that are assigned to at least one MB
              const lib1Name = rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "L1";
              const lib2Name = selectedLibero2 ? (rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "L2") : null;
              const lib1HasMBs = Object.values(mbBackRowMap).includes("libero1") || Object.keys(mbBackRowMap).length === 0;
              const lib2HasMBs = selectedLibero2 && Object.values(mbBackRowMap).includes("libero2");

              return (
                <div style={{ marginTop: 20 }}>
                  <h3 style={S.sectionTitle}>Libero Serving</h3>
                  <div style={{ fontSize: 11, opacity: 0.5, marginBottom: 8 }}>
                    Each libero can serve in one MB's rotation.
                  </div>
                  {/* Libero 1 serve choice */}
                  {lib1HasMBs && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4 }}>{lib1Name} serves for:</div>
                      <div style={{ display: "flex", gap: 8 }}>
                        {mbsInLineup.filter(mb => (mbBackRowMap[mb.player.id] || "libero1") === "libero1").map((mb) => (
                          <button key={mb.player.id} style={{
                            ...S.optionBtn,
                            ...(liberoServeChoice === mb.player.id ? S.optionBtnActive : {}),
                          }} onClick={() => setLiberoServeChoice(mb.player.id)}>
                            <span style={{ fontWeight: 800, fontSize: 14 }}>{mb.player.name?.split(" ")[0]}</span>
                            <span style={{ fontSize: 9, opacity: 0.5 }}>Zone {mb.pos}</span>
                          </button>
                        ))}
                        <button style={{
                          ...S.optionBtn,
                          ...(liberoServeChoice === "none" ? S.optionBtnActive : {}),
                        }} onClick={() => setLiberoServeChoice("none")}>
                          <span style={{ fontSize: 11 }}>No serve</span>
                        </button>
                      </div>
                    </div>
                  )}
                  {/* Libero 2 serve choice */}
                  {lib2HasMBs && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4 }}>{lib2Name} serves for:</div>
                      <div style={{ display: "flex", gap: 8 }}>
                        {mbsInLineup.filter(mb => mbBackRowMap[mb.player.id] === "libero2").map((mb) => (
                          <button key={mb.player.id} style={{
                            ...S.optionBtn,
                            ...(libero2ServeChoice === mb.player.id ? S.optionBtnActive : {}),
                          }} onClick={() => setLibero2ServeChoice(mb.player.id)}>
                            <span style={{ fontWeight: 800, fontSize: 14 }}>{mb.player.name?.split(" ")[0]}</span>
                            <span style={{ fontSize: 9, opacity: 0.5 }}>Zone {mb.pos}</span>
                          </button>
                        ))}
                        <button style={{
                          ...S.optionBtn,
                          ...(libero2ServeChoice === "none" ? S.optionBtnActive : {}),
                        }} onClick={() => setLibero2ServeChoice("none")}>
                          <span style={{ fontSize: 11 }}>No serve</span>
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}

            <button style={{ ...S.primaryBtn, marginTop: 24 }} onClick={() => {
              try {
                const setNum = (currentMatch?.sets?.length || 0) + 1;
                const newSet = emptySet(setNum);
                newSet.startingLineup = { ...lineupSlots };
                newSet.currentLineup = { ...lineupSlots };
                newSet.positionOverrides = { ...lineupPositions };
                newSet.liberoId = selectedLibero || null; // backwards compat
                newSet.libero1Id = selectedLibero || null;
                newSet.libero2Id = selectedLibero2 || null;
                newSet.liberoServeForMB = liberoServeChoice || null; // backwards compat
                newSet.mbBackRowMap = { ...mbBackRowMap };
                newSet.liberoServeMap = {};
                if (selectedLibero && liberoServeChoice && liberoServeChoice !== "none") {
                  newSet.liberoServeMap[selectedLibero] = liberoServeChoice;
                }
                if (selectedLibero2 && libero2ServeChoice && libero2ServeChoice !== "none") {
                  newSet.liberoServeMap[selectedLibero2] = libero2ServeChoice;
                }
                newSet.liberoSwaps = {};
                newSet.weServe = weServeFirst;
                newSet.rotation = 1;
                newSet.firstServerId = weServeFirst ? lineupSlots[1] : lineupSlots[2];

                const sets = [...(currentMatch?.sets || []), newSet];
                const updated = { ...currentMatch, sets };
                setCurrentMatch(updated);
                setMatches((prev) => {
                  const all = prev.map((m) => (m.id === updated.id ? updated : m));
                  if (!all.find((m) => m.id === updated.id)) all.push(updated);
                  save(all);
                  return all;
                });
                setCurrentSetIdx(sets.length - 1);
                setRallyPhase("idle");
                setCurrentRally(null);
                setSelectedPlayer(null);
                setUndoStack([]);
                setTab("court");
                navigate("match");
                showToast(`Set ${setNum} — Let's go!`);
              } catch (e) {
                showToast(`Error: ${e.message}`);
              }
            }}>
              Start Set →
            </button>
          </div>
        </div>
      );
    }
  }

  // ── STANDALONE SCOUT SCREEN ─────────────────────────
  if (screen === "scout" && currentScout) {
    const shots = currentScout.shots || [];
    const ZONES = [
      { id: 1, label: "Z1" },
      { id: 6, label: "Z6" },
      { id: 5, label: "Z5" },
      { id: 2, label: "Z2" },
      { id: 3, label: "Z3" },
      { id: 4, label: "Z4" },
    ];

    const handleCourtTap = (e, manualX, manualY) => {
      if (!scoutPending) return;
      let x, y;
      if (e && e.currentTarget) {
        const rect = e.currentTarget.getBoundingClientRect();
        x = ((e.clientX - rect.left) / rect.width) * 100;
        y = ((e.clientY - rect.top) / rect.height) * 100;
      } else {
        x = manualX; y = manualY;
      }
      const shot = {
        id: Date.now().toString(),
        originZone: scoutPending.originZone,
        outcome: scoutPending.outcome,
        x: Math.round(x * 10) / 10,
        y: Math.round(y * 10) / 10,
        timestamp: Date.now(),
      };
      const updated = { ...currentScout, shots: [...shots, shot] };
      setCurrentScout(updated);
      const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
      if (!sessions.find((s) => s.id === updated.id)) sessions.push(updated);
      saveScoutSessions(sessions);
      const isOOB = x < 0 || x > 100 || y < 0 || y > 100;
      showToast(`${({ kill: "KILL", dug: "DUG", error: "ERR" })[scoutPending.outcome]}${isOOB ? " (OUT)" : ""} from Z${scoutPending.originZone}`);
      setScoutPending(null);
    };

    const undoScoutShot = () => {
      const updated = { ...currentScout, shots: shots.slice(0, -1) };
      setCurrentScout(updated);
      const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
      saveScoutSessions(sessions);
      showToast("Shot removed");
    };

    const getOriginStats = () => {
      const stats = {};
      for (const z of ZONES) {
        const zShots = shots.filter((s) => s.originZone === z.id);
        stats[z.id] = { kills: zShots.filter((s) => s.outcome === "kill").length, dug: zShots.filter((s) => s.outcome === "dug").length, errors: zShots.filter((s) => s.outcome === "error").length, total: zShots.length };
      }
      return stats;
    };
    const originStats = getOriginStats();
    const filteredShots = scoutOriginFilter !== null ? shots.filter((s) => s.originZone === scoutOriginFilter) : shots;

    const outcomeColor = { kill: "#ef4444", dug: "#007bff", error: "#3b82f6" };
    const COURT_H = 200;

    const courtSvg = (shotList, interactive) => {
      const W = 300, H = COURT_H;
      const PAD = 14;
      const TW = W + PAD * 2, TH = H + PAD * 2;
      const outcomeGlow = { kill: [239,68,68], dug: [245,158,11], error: [59,130,246] };
      const inBounds = shotList.filter((s) => s.x >= 0 && s.x <= 100 && s.y >= 0 && s.y <= 100);
      const oob = shotList.filter((s) => s.x < 0 || s.x > 100 || s.y < 0 || s.y > 100);

      const handleSvgClick = (e) => {
        if (!scoutPending) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const rawX = (e.clientX - rect.left) / rect.width * TW;
        const rawY = (e.clientY - rect.top) / rect.height * TH;
        const x = ((rawX - PAD) / W) * 100;
        const y = ((rawY - PAD) / H) * 100;
        handleCourtTap(null, x, y);
      };

      // Weather-channel density heatmap
      const COLS = 20, ROWS = 14;
      const cellW = W / COLS, cellH = H / ROWS;
      const RADIUS = 3.5; // influence radius in cells
      const heatCells = [];
      if (!interactive && inBounds.length > 0) {
        const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let maxD = 0;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            let density = 0;
            for (const s of inBounds) {
              const sc = s.x / 100 * COLS;
              const sr = s.y / 100 * ROWS;
              const dist = Math.sqrt((c - sc) ** 2 + (r - sr) ** 2);
              if (dist < RADIUS) density += Math.exp(-(dist * dist) / (RADIUS * 0.7));
            }
            grid[r][c] = density;
            if (density > maxD) maxD = density;
          }
        }
        // Color scale: transparent → blue → cyan → green → yellow → orange → red
        const heatColor = (val) => {
          if (maxD === 0) return "transparent";
          const t = val / maxD;
          if (t < 0.05) return "transparent";
          const stops = [
            [0.05, 0, 0, 180, 0.3],
            [0.2, 0, 100, 255, 0.45],
            [0.35, 0, 200, 200, 0.55],
            [0.5, 0, 220, 0, 0.65],
            [0.65, 180, 220, 0, 0.7],
            [0.8, 255, 180, 0, 0.8],
            [1.0, 255, 40, 0, 0.9],
          ];
          let lo = stops[0], hi = stops[stops.length - 1];
          for (let i = 0; i < stops.length - 1; i++) {
            if (t >= stops[i][0] && t <= stops[i + 1][0]) { lo = stops[i]; hi = stops[i + 1]; break; }
          }
          const f = (t - lo[0]) / (hi[0] - lo[0] || 1);
          const lerp = (a, b) => Math.round(a + (b - a) * f);
          return `rgba(${lerp(lo[1], hi[1])},${lerp(lo[2], hi[2])},${lerp(lo[3], hi[3])},${(lo[4] + (hi[4] - lo[4]) * f).toFixed(2)})`;
        };
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c] > maxD * 0.05) {
              heatCells.push(<rect key={`h${r}-${c}`} x={PAD + c * cellW} y={PAD + r * cellH} width={cellW + 0.5} height={cellH + 0.5} fill={heatColor(grid[r][c])} />);
            }
          }
        }
      }

      return (
        <div style={{ position: "relative", width: "100%", cursor: interactive && scoutPending ? "crosshair" : "default", userSelect: "none", touchAction: "none", borderRadius: 8, overflow: "hidden" }}
          onClick={interactive ? handleSvgClick : undefined}>
          <svg width="100%" viewBox={`0 0 ${TW} ${TH}`} style={{ display: "block" }}>
            {/* OOB area */}
            <rect x="0" y="0" width={TW} height={TH} fill="#0a0a0f" />
            {/* Court */}
            <rect x={PAD} y={PAD} width={W} height={H} fill="#0d1118" stroke="#2a2a34" strokeWidth="2" />
            {/* OOB label */}
            {interactive && scoutPending && <>
              <text x={TW / 2} y={PAD / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text>
              <text x={TW / 2} y={TH - PAD / 2 + 4} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text>
              <text x={PAD / 2} y={TH / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text>
              <text x={TW - PAD / 2} y={TH / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text>
            </>}
            {/* Density heatmap */}
            {heatCells}
            {/* Court lines */}
            <line x1={PAD} y1={PAD + H * 0.33} x2={PAD + W} y2={PAD + H * 0.33} stroke={interactive ? "#2a2a34" : "#ffffff33"} strokeWidth="2" strokeDasharray="8,4" />
            <line x1={PAD + 100} y1={PAD} x2={PAD + 100} y2={PAD + H} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            <line x1={PAD + 200} y1={PAD} x2={PAD + 200} y2={PAD + H} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            <line x1={PAD} y1={PAD + H * 0.5} x2={PAD + W} y2={PAD + H * 0.5} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            {/* Input dots */}
            {interactive && inBounds.map((s, i) => (
              <circle key={s.id || i} cx={PAD + s.x * W / 100} cy={PAD + s.y * H / 100} r={5}
                fill={outcomeColor[s.outcome] || "#999"} opacity={0.9} stroke="#000" strokeWidth="0.5" />
            ))}
            {/* OOB dots in border */}
            {interactive && oob.map((s, i) => {
              const ox = Math.max(3, Math.min(TW - 3, PAD + s.x * W / 100));
              const oy = Math.max(3, Math.min(TH - 3, PAD + s.y * H / 100));
              return <circle key={`o${i}`} cx={ox} cy={oy} r={4} fill={outcomeColor[s.outcome] || "#999"} opacity={0.7} stroke="#ef4444" strokeWidth="0.5" />;
            })}
            {/* Heatmap white markers */}
            {!interactive && inBounds.map((s, i) => (
              <circle key={s.id || i} cx={PAD + s.x * W / 100} cy={PAD + s.y * H / 100} r={2} fill="#fff" opacity={0.7} />
            ))}
          </svg>
          {interactive && scoutPending && shotList.length === 0 && (
            <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%,-50%)", pointerEvents: "none", fontSize: 11, fontWeight: 700, color: "#007bff", opacity: 0.4, letterSpacing: 1, textAlign: "center" }}>TAP EXACT SPOT<br/>BALL LANDED</div>
          )}
        </div>
      );
    };

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => {
            const sessions = scoutSessions.map((s) => s.id === currentScout.id ? currentScout : s);
            if (!sessions.find((s) => s.id === currentScout.id)) sessions.push(currentScout);
            saveScoutSessions(sessions);
            setCurrentScout(null);
            setScoutPending(null);
            goBack();
          }}>&larr;</button>
          <h1 style={S.headerTitle}>Scout: {currentScout.name}</h1>
          <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length}</span>
        </div>

        <div style={S.pad}>
          <div style={{ display: "flex", gap: 4, marginBottom: 8 }}>
            <button style={{ ...S.gb, flex: 1, background: scoutView === "input" ? "#007bff" : "#1a1a24", color: scoutView === "input" ? "#000" : "#fff" }}
              onClick={() => { setScoutView("input"); setScoutPending(null); setScoutOriginFilter(null); }}>+ Log Attacks</button>
            <button style={{ ...S.gb, flex: 1, background: scoutView === "heatmap" ? "#007bff" : "#1a1a24", color: scoutView === "heatmap" ? "#000" : "#fff" }}
              onClick={() => { setScoutView("heatmap"); setScoutPending(null); setScoutOriginFilter(null); }}>Heat Map ({shots.length})</button>
          </div>

          {/* ═══ INPUT MODE ═══ */}
          {scoutView === "input" && (
            <div>
              <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 6 }}>
                {!scoutPending ? "STEP 1: TAP ORIGIN + OUTCOME" : "STEP 2: TAP WHERE BALL LANDED"}
              </div>

              {/* Their court - 6 zones with K/D/E */}
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr", gap: 2, background: "#0f1218", borderRadius: "8px", overflow: "hidden", border: "2px solid #2a2a34"}}>
                {ZONES.map((z) => {
                  const os = originStats[z.id];
                  const isPending = scoutPending?.originZone === z.id;
                  return (
                    <div key={z.id} style={{ background: isPending ? "#0a1929" : "#0d0d14", padding: 4, minHeight: 54, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", opacity: scoutPending ? (isPending ? 1 : 0.25) : 1, position: "relative", border: isPending ? "2px solid #007bff" : "1px solid transparent" }}>
                      <span style={{ fontSize: 8, opacity: 0.3, position: "absolute", top: 2, left: 4 }}>{z.id}</span>
                      <div style={{ display: "flex", gap: 4 }}>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #ef4444", background: isPending && scoutPending.outcome === "kill" ? "#ef4444" : "transparent", color: isPending && scoutPending.outcome === "kill" ? "#000" : "#ef4444", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "kill" })}>K</button>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #007bff", background: isPending && scoutPending.outcome === "dug" ? "#007bff" : "transparent", color: isPending && scoutPending.outcome === "dug" ? "#000" : "#007bff", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "dug" })}>D</button>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #3b82f6", background: isPending && scoutPending.outcome === "error" ? "#3b82f6" : "transparent", color: isPending && scoutPending.outcome === "error" ? "#000" : "#3b82f6", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "error" })}>E</button>
                      </div>
                      {os.total > 0 && !scoutPending && (
                        <div style={{ display: "flex", gap: 3, marginTop: 2, fontSize: 7 }}>
                          {os.kills > 0 && <span style={{ color: "#ef4444" }}>{os.kills}K</span>}
                          {os.dug > 0 && <span style={{ color: "#007bff" }}>{os.dug}D</span>}
                          {os.errors > 0 && <span style={{ color: "#3b82f6" }}>{os.errors}E</span>}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>

              {/* NET */}
              <div style={{ background: scoutPending ? "#007bff" : "#2a2a34", textAlign: "center", fontSize: 9, fontWeight: 900, color: scoutPending ? "#000" : "#9ca3af", padding: "4px 0", letterSpacing: 3, margin: "4px 0", borderRadius: 4 }}>
                {scoutPending ? "\u25bc TAP EXACT LANDING SPOT \u25bc" : "\u2500\u2500\u2500 NET \u2500\u2500\u2500"}
              </div>

              
              {courtSvg(shots, true)}

              {/* Footer */}
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 8 }}>
                <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length} shots</span>
                <div style={{ display: "flex", gap: 6 }}>
                  {scoutPending && <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} onClick={() => setScoutPending(null)}>Cancel</button>}
                  <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} disabled={shots.length === 0} onClick={undoScoutShot}>Undo</button>
                </div>
              </div>

              {/* Legend */}
              <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
              </div>
            </div>
          )}

          {/* ═══ HEAT MAP MODE ═══ */}
          {scoutView === "heatmap" && (
            <div>
              {shots.length === 0 ? (
                <div style={{ textAlign: "center", padding: 32, opacity: 0.4 }}>No shots yet. Log attacks first.</div>
              ) : (
                <>
                  {/* Origin filter */}
                  <div style={{ fontSize: 10, fontWeight: 700, color: "#9ca3af", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>FILTER BY ATTACK ORIGIN</div>
                  <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "auto auto", gap: 2, background: "#0f1218", border: "2px solid #2a2a34", borderRadius: "8px", overflow: "hidden", marginBottom: 4 }}>
                    {ZONES.map((z) => {
                      const os = originStats[z.id];
                      const isActive = scoutOriginFilter === z.id;
                      return (
                        <button key={z.id} style={{ background: isActive ? "#0a1929" : "#0d0d14", padding: 5, border: "none", color: "#fff", cursor: "pointer", textAlign: "center", borderBottom: isActive ? "2px solid #007bff" : "2px solid transparent" }}
                          onClick={() => setScoutOriginFilter(isActive ? null : z.id)}>
                          <div style={{ fontSize: 8, opacity: 0.4 }}>Z{z.id}</div>
                          {os.total > 0 && <div style={{ fontSize: 10, fontWeight: 700 }}>{os.total} <span style={{ fontSize: 7, opacity: 0.5 }}>({os.kills}K)</span></div>}
                        </button>
                      );
                    })}
                  </div>
                  {scoutOriginFilter !== null && (
                    <button style={{ ...S.gb, background: "#2a2a34", width: "100%", marginBottom: 4, fontSize: 10 }} onClick={() => setScoutOriginFilter(null)}>Zone {scoutOriginFilter} filter &mdash; tap to clear</button>
                  )}

                  <div style={{ background: "#007bff", textAlign: "center", fontSize: 9, fontWeight: 900, color: "#000", padding: "3px 0", letterSpacing: 3, margin: "2px 0", borderRadius: 4 }}>{"\u2500\u2500\u2500"} NET {"\u2500\u2500\u2500"}</div>

                  {/* Heat map court */}
                  {courtSvg(filteredShots, false)}

                  {/* Summary */}
                  <div style={{ ...S.card, marginTop: 8 }}>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, textAlign: "center" }}>
                      <div><div style={{ fontSize: 20, fontWeight: 800 }}>{filteredShots.length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Attacks</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#ef4444" }}>{filteredShots.filter((s) => s.outcome === "kill").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Kills</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#22c55e" }}>{filteredShots.filter((s) => s.outcome === "dug").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Digs</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#3b82f6" }}>{filteredShots.filter((s) => s.outcome === "error").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Errors</div></div>
                    </div>
                  </div>

                  {/* Legend */}
                  <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                  </div>
                </>
              )}

              {/* Scout Notes */}
              <div style={{ marginTop: 16 }}>
                <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>SCOUTING NOTES</div>
                <textarea
                  style={{ width: "100%", minHeight: 120, padding: 12, background: "#111118", border: "1px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", fontSize: 13, lineHeight: 1.5, resize: "vertical", outline: "none", boxSizing: "border-box", fontFamily: "inherit" }}
                  placeholder="Add notes about tendencies, key players, rotation patterns..."
                  value={currentScout.notes || ""}
                  onChange={(e) => {
                    const updated = { ...currentScout, notes: e.target.value };
                    setCurrentScout(updated);
                    const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
                    if (!sessions.find((s) => s.id === updated.id)) sessions.push(updated);
                    saveScoutSessions(sessions);
                  }}
                />
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ── PRACTICE SCREEN ──────────────────────────────────
  if (screen === "practice" && currentPractice) {
    const team = savedTeams.find((t) => t.id === currentPractice.teamId);
    const rosterP = team ? ((team.players||[])).filter((p) => p.number) : [];

    // Gather all events across all saved rounds + active round for live stats
    const practicePlayerStats = {};
    const addEvt = (ev) => {
      if (!practicePlayerStats[ev.playerId]) practicePlayerStats[ev.playerId] = { 0: 0, 1: 0, 2: 0, 3: 0, total: 0 };
      const ps = practicePlayerStats[ev.playerId];
      ps[ev.quality] = (ps[ev.quality] || 0) + 1;
      ps.total++;
    };
    for (const r of currentPractice.rounds) {
      for (const g of (r.groups || [])) {
        for (const ev of (g.events || [])) addEvt(ev);
      }
      // Legacy flat events support
      if (r.events) for (const ev of (r.events || [])) addEvt(ev);
    }
    // Active round groups
    if (practiceRound) {
      for (const g of (practiceRound.groups || [])) {
        for (const ev of (g.events || [])) addEvt(ev);
      }
    }

    const savePracticeData = (prac) => {
      setCurrentPractice(prac);
      const all = practices.map((p) => p.id === prac.id ? prac : p);
      if (!all.find((p) => p.id === prac.id)) all.push(prac);
      savePractices(all);
    };

    // Active group is last in practiceRound.groups
    const activeGroup = practiceRound?.groups?.length > 0 ? practiceRound.groups[practiceRound.groups.length - 1] : null;
    const isStatting = practiceRound && !practicePasserPick && activeGroup;
    const roundNum = ((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0);

    // Round-level stats (all groups in current active round)
    const roundPlayerStats = {};
    if (practiceRound) {
      for (const g of (practiceRound.groups || [])) {
        for (const ev of (g.events || [])) {
          if (!roundPlayerStats[ev.playerId]) roundPlayerStats[ev.playerId] = { 0: 0, 1: 0, 2: 0, 3: 0, total: 0 };
          const ps = roundPlayerStats[ev.playerId];
          ps[ev.quality] = (ps[ev.quality] || 0) + 1;
          ps.total++;
        }
      }
    }

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => {
            if (practiceRound && practiceRound.groups?.some((g) => ((g.events||[])).length > 0)) {
              const { _pendingPassers, ...cleanRound } = practiceRound;
              const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
              savePracticeData(updated);
            } else {
              savePracticeData(currentPractice);
            }
            setCurrentPractice(null);
            setPracticeRound(null);
            setPracticePasserPick(false);
            goBack();
          }}>&#8592;</button>
          <h1 style={{ ...S.headerTitle, flex: 1 }}>{currentPractice.name}</h1>
          {practiceRound && (
            <span style={{ fontSize: 11, color: "#007bff", fontWeight: 700 }}>R{roundNum} / G{practiceRound.groups?.length || 0}</span>
          )}
        </div>

        <div style={S.pad}>
          {/* NO ACTIVE ROUND — show round list + start button */}
          {!practiceRound && (
            <div>
              <button style={{ ...S.primaryBtn, margin: "0 0 16px" }} onClick={() => {
                setPracticeRound({ id: Date.now().toString(), groups: [], _pendingPassers: [] });
                setPracticePasserPick(true);
              }}>
                Start Round {((currentPractice.rounds||[])).length + 1}
              </button>

              {((currentPractice.rounds||[])).length > 0 && (
                <>
                  <h3 style={S.sectionTitle}>COMPLETED ROUNDS</h3>
                  {((currentPractice.rounds||[])).map((r, ri) => {
                    const groups = r.groups || [];
                    const totalEvts = groups.reduce((t, g) => t + ((g.events||[])).length, 0) + (r.events?.length || 0);
                    const uniquePassers = new Set();
                    for (const g of groups) for (const e of (g.events || [])) uniquePassers.add(e.playerId);
                    if (r.events) for (const e of (r.events || [])) uniquePassers.add(e.playerId);
                    return (
                      <div key={r.id || ri} style={{ ...S.card, marginBottom: 8 }}>
                        <div style={{ display: "flex", justifyContent: "space-between" }}>
                          <span style={{ fontWeight: 700 }}>Round {ri + 1}</span>
                          <span style={{ fontSize: 11, opacity: 0.4 }}>{groups.length} group{groups.length !== 1 ? "s" : ""} / {totalEvts} passes</span>
                        </div>
                        <div style={{ fontSize: 11, opacity: 0.5, marginTop: 2 }}>{uniquePassers.size} player{uniquePassers.size !== 1 ? "s" : ""}</div>
                      </div>
                    );
                  })}
                </>
              )}
            </div>
          )}

          {/* ACTIVE ROUND — passer selection for new group */}
          {practiceRound && practicePasserPick && (
            <div>
              <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>
                ROUND {roundNum} — {practiceRound.groups?.length > 0 ? "NEW GROUP" : "SET UP FIRST GROUP"}
              </div>
              <h3 style={S.sectionTitle}>SELECT PASSERS</h3>
              <div style={{ fontSize: 11, opacity: 0.5, marginBottom: 8 }}>Tap all players passing in this group</div>
              <div style={{ display: "flex", flexWrap: "wrap", gap: 6, marginBottom: 16 }}>
                {sortByPosition(rosterP).map((p) => {
                  const selected = (practiceRound._pendingPassers || []).includes(p.id);
                  return (
                    <button key={p.id} style={{
                      padding: "8px 12px", borderRadius: 8, border: "2px solid", cursor: "pointer",
                      borderColor: selected ? "#007bff" : "#2a2a34",
                      background: selected ? "#0a1929" : "#0d0d14",
                      color: "#e2e8f0",
                    }} onClick={() => {
                      setPracticeRound((prev) => {
                        const pending = prev._pendingPassers || [];
                        const has = pending.includes(p.id);
                        return { ...prev, _pendingPassers: has ? pending.filter((x) => x !== p.id) : [...pending, p.id] };
                      });
                    }}>
                      <span style={{ fontWeight: 800, fontSize: 14 }}>{p.name?.split(" ")[0]}</span>
                      <span style={{ fontSize: 10, marginLeft: 4, opacity: 0.5 }}>#{p.number}</span>
                      <span style={{ fontSize: 9, marginLeft: 4, color: "#007bff" }}>{p.position}</span>
                    </button>
                  );
                })}
              </div>
              <button style={{ ...S.primaryBtn, margin: 0 }}
                disabled={!(practiceRound._pendingPassers?.length > 0)}
                onClick={() => {
                  const newGroup = { id: Date.now().toString(), selectedPassers: [...practiceRound._pendingPassers], events: [] };
                  setPracticeRound((prev) => {
                    const { _pendingPassers, ...rest } = prev;
                    return { ...rest, groups: [...(rest.groups || []), newGroup], _pendingPassers: [] };
                  });
                  setPracticePasserPick(false);
                }}>
                Start Group ({practiceRound._pendingPassers?.length || 0} passers)
              </button>

              {practiceRound.groups?.length > 0 && (
                <button style={{ ...S.cancelBtn, marginTop: 8 }} onClick={() => {
                  if (practiceRound.groups.some((g) => ((g.events||[])).length > 0)) {
                    const { _pendingPassers, ...cleanRound } = practiceRound;
                    const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
                    savePracticeData(updated);
                  }
                  setPracticeRound(null);
                  setPracticePasserPick(false);
                }}>End Round</button>
              )}
            </div>
          )}

          {/* ACTIVE GROUP — stat passes */}
          {isStatting && (
            <div>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 }}>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1 }}>
                  ROUND {roundNum} / GROUP {practiceRound.groups.length}
                </div>
                <span style={{ fontSize: 10, opacity: 0.4 }}>{((activeGroup.events||[])).length} passes</span>
              </div>

              {activeGroup.selectedPassers.map((pid) => {
                const player = rosterP.find((p) => p.id === pid);
                if (!player) return null;
                const groupEvts = ((activeGroup.events||[])).filter((e) => e.playerId === pid);
                const groupTotal = groupEvts.length;
                const groupAvg = groupTotal > 0 ? groupEvts.reduce((s, e) => s + e.quality, 0) / groupTotal : 0;
                return (
                  <div key={pid} style={{ ...S.card, marginBottom: 8, padding: 10 }}>
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 6 }}>
                      <span style={{ fontWeight: 700, fontSize: 14 }}>{player.name?.split(" ")[0]} <span style={{ fontWeight: 400, fontSize: 11, opacity: 0.5 }}>#{player.number}</span></span>
                      <span style={{ fontSize: 11, opacity: 0.5 }}>{groupTotal} {groupTotal > 0 ? `(${groupAvg.toFixed(1)} avg)` : ""}</span>
                    </div>
                    <div style={{ display: "flex", gap: 6 }}>
                      {[0, 1, 2, 3].map((q) => (
                        <button key={q} style={{
                          flex: 1, padding: "14px 0", borderRadius: 8, border: "none", cursor: "pointer", fontWeight: 800, fontSize: 20,
                          background: q === 0 ? "#7f1d1d" : q === 1 ? "#991b1b" : q === 2 ? "#854d0e" : "#166534",
                          color: "#fff",
                        }} onClick={() => {
                          const ev = { playerId: pid, quality: q, timestamp: Date.now() };
                          setPracticeRound((prev) => {
                            const groups = [...prev.groups];
                            const lastG = { ...groups[groups.length - 1] };
                            lastG.events = [...(lastG.events||[]), ev];
                            groups[groups.length - 1] = lastG;
                            return { ...prev, groups };
                          });
                          showToast(`${player.name?.split(" ")[0]} / ${q}`);
                        }}>{q}</button>
                      ))}
                    </div>
                  </div>
                );
              })}

              {((activeGroup.events||[])).length > 0 && (
                <button style={{ ...S.gb, width: "100%", marginBottom: 8, background: "#2a2a34" }} onClick={() => {
                  setPracticeRound((prev) => {
                    const groups = [...prev.groups];
                    const lastG = { ...groups[groups.length - 1] };
                    lastG.events = ((lastG.events||[])).slice(0, -1);
                    groups[groups.length - 1] = lastG;
                    return { ...prev, groups };
                  });
                  showToast("Undone");
                }}>Undo Last</button>
              )}

              <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#0056b3" }} onClick={() => {
                  setPracticePasserPick(true);
                  setPracticeRound((prev) => ({ ...prev, _pendingPassers: [] }));
                }}>New Group</button>
                <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#991b1b" }} onClick={() => {
                  if (practiceRound.groups.some((g) => ((g.events||[])).length > 0)) {
                    const { _pendingPassers, ...cleanRound } = practiceRound;
                    const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
                    savePracticeData(updated);
                  }
                  setPracticeRound(null);
                  setPracticePasserPick(false);
                }}>End Round</button>
              </div>
            </div>
          )}

          {/* ROUND STATS — current active round */}
          {practiceRound && Object.keys(roundPlayerStats).length > 0 && (
            <div style={{ ...S.card, marginTop: 16 }}>
              <h3 style={S.cardTitle}>ROUND {roundNum} STATS</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead><tr><th style={S.sth}>Player</th><th style={S.sth}>Tot</th><th style={S.sth}>3s</th><th style={S.sth}>2s</th><th style={S.sth}>1s</th><th style={S.sth}>0s</th><th style={S.sth}>Avg</th></tr></thead>
                  <tbody>
                    {Object.entries(roundPlayerStats).sort((a, b) => b[1].total - a[1].total).map(([pid, ps]) => {
                      const player = rosterP.find((p) => p.id === pid);
                      if (!player) return null;
                      const avg = ps.total > 0 ? (ps[1]*1 + ps[2]*2 + ps[3]*3) / ps.total : 0;
                      const avgColor = avg >= 2.5 ? "#22c55e" : avg >= 2.0 ? "#007bff" : "#ef4444";
                      return (<tr key={pid}><td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>#{player.number} {player.name?.split(" ")[0]}</td><td style={S.std}>{ps.total}</td><td style={{ ...S.std, color: "#22c55e" }}>{ps[3]}</td><td style={{ ...S.std, color: "#007bff" }}>{ps[2]}</td><td style={{ ...S.std, color: "#ef4444" }}>{ps[1]}</td><td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps[0]}</td><td style={{ ...S.std, fontWeight: 800, color: avgColor }}>{avg.toFixed(1)}</td></tr>);
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {/* FULL PRACTICE STATS */}
          {Object.keys(practicePlayerStats).length > 0 && (
            <div style={{ ...S.card, marginTop: 12 }}>
              <h3 style={S.cardTitle}>FULL PRACTICE STATS</h3>
              <p style={S.cardSub}>{((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0)} round{((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0) !== 1 ? "s" : ""}</p>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead><tr><th style={S.sth}>Player</th><th style={S.sth}>Tot</th><th style={S.sth}>3s</th><th style={S.sth}>2s</th><th style={S.sth}>1s</th><th style={S.sth}>0s</th><th style={S.sth}>Avg</th></tr></thead>
                  <tbody>
                    {Object.entries(practicePlayerStats).sort((a, b) => b[1].total - a[1].total).map(([pid, ps]) => {
                      const player = rosterP.find((p) => p.id === pid);
                      if (!player) return null;
                      const avg = ps.total > 0 ? (ps[1]*1 + ps[2]*2 + ps[3]*3) / ps.total : 0;
                      const avgColor = avg >= 2.5 ? "#22c55e" : avg >= 2.0 ? "#007bff" : "#ef4444";
                      return (<tr key={pid}><td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>#{player.number} {player.name?.split(" ")[0]}</td><td style={S.std}>{ps.total}</td><td style={{ ...S.std, color: "#22c55e" }}>{ps[3]}</td><td style={{ ...S.std, color: "#007bff" }}>{ps[2]}</td><td style={{ ...S.std, color: "#ef4444" }}>{ps[1]}</td><td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps[0]}</td><td style={{ ...S.std, fontWeight: 800, color: avgColor }}>{avg.toFixed(1)}</td></tr>);
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ── MATCH SCREEN ────────────────────────────────────
  if (screen === "match" && currentMatch) {
    const set = getCurrentSet();
    if (!set) {
      return <div style={S.container}><div style={S.loading}>Loading set...</div></div>;
    }
    const onCourt = getOnCourtLineup(set) || {};
    const server = getCurrentServer(set);
    const nextServer = getNextServer(set);
    const passers = getPassers(set) || [];
    const passerIds = passers.map((p) => p.playerId);
    const primaryPasserIds = passers.filter((p) => p.primary).map((p) => p.playerId);
    const setTotals = getSetTotals(set);
    const formulaAnalysis = getFormulaAnalysis();
    const setProgress = getCurrentSetProgress(set);
    const swingDist = getSwingDistribution(set);
    const totalSwings = swingDist.reduce((s, d) => s + d.attacks, 0);
    const serveRisk = getServeRisk(set);
    const rosterPlayers = ((currentMatch.roster||[])).filter((p) => p.number);
    const onCourtIds = Object.values(onCourt).filter((v) => typeof v === "string");
    const benchPlayers = rosterPlayers.filter((p) => !Object.values(set?.currentLineup || {}).includes(p.id) && !isLiberoId(p.id, set));

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}

        {/* TIMEOUT OVERLAY */}
        {showTimeout && (() => {
          // Current set stats
          const st = getSetTotals(set);
          const att = (st.kill||0)+(st.attack_error||0)+(st.attack_blocked||0);
          const kPct = att > 0 ? ((st.kill||0)-(st.attack_error||0))/att : 0;
          // Full match stats
          const mt = getMatchTotals();
          const mAtt = (mt.kill||0)+(mt.attack_error||0)+(mt.attack_blocked||0);
          const mKPct = mAtt > 0 ? ((mt.kill||0)-(mt.attack_error||0))/mAtt : 0;
          const topH = rosterPlayers.map((p) => {
            const ps = getPlayerSetStats(p.id, set);
            const a = (ps.kill||0)+(ps.attack_error||0)+(ps.attack_blocked||0);
            return { name: p.name?.split(" ")[0]||`#${p.number}`, k: ps.kill||0, e: ps.attack_error||0, att: a, pct: a > 0 ? ((ps.kill||0)-(ps.attack_error||0))/a : null };
          }).filter((h) => h.att > 0).sort((a,b) => b.k - a.k).slice(0, 4);

          // Formula comparison
          const fa = formulaAnalysis;
          const totalPts = (set?.ourScore || 0) + (set?.theirScore || 0);
          const paceThrough = totalPts > 0 ? Math.min(totalPts / 50, 1) : 0;
          const formulaSurplus = {};
          const formulaDeficit = {};
          if (fa.hasEnoughData) {
            for (const s of fa.analysis) {
              const current = st[s.key] || 0;
              const target = parseFloat(s.winAvg);
              const expected = target * paceThrough;
              if (s.scoring) {
                const diff = current - expected;
                if (diff >= 1) formulaSurplus[s.key] = { label: s.label, surplus: Math.round(diff * 10) / 10 };
                else if (diff <= -1) formulaDeficit[s.key] = { label: s.label, deficit: Math.round(Math.abs(diff) * 10) / 10 };
              } else {
                const lossTarget = parseFloat(s.lossAvg);
                const expectedErr = lossTarget * paceThrough;
                if (current > expectedErr + 1) formulaDeficit[s.key] = { label: s.label, deficit: Math.round((current - expectedErr) * 10) / 10 };
              }
            }
          }

          // Build suggestions from match + formula context
          const sug = [];
          const scoreDiff = (set?.ourScore || 0) - (set?.theirScore || 0);
          const matchSetsWon = ((currentMatch.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length;
          const matchSetsLost = ((currentMatch.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length;

          // Formula-driven suggestions
          if (fa.hasEnoughData) {
            const surplusKeys = Object.keys(formulaSurplus);
            const deficitKeys = Object.keys(formulaDeficit);
            if (surplusKeys.length > 0) {
              const best = surplusKeys.sort((a,b) => formulaSurplus[b].surplus - formulaSurplus[a].surplus)[0];
              sug.push(`${formulaSurplus[best].label} ahead of formula pace by +${formulaSurplus[best].surplus} — keep riding this.`);
            }
            if (deficitKeys.length > 0) {
              const worst = deficitKeys.sort((a,b) => formulaDeficit[b].deficit - formulaDeficit[a].deficit)[0];
              sug.push(`${formulaDeficit[worst].label} behind formula target by ${formulaDeficit[worst].deficit} — need to make up ground.`);
            }
          }

          // Performance-driven suggestions
          if (kPct < 0.10 && att > 5) sug.push("Attack efficiency critically low — run middles/quicks to open the pins.");
          else if (kPct < 0.20 && att > 5) sug.push("Hitting below .200 — consider spreading offense to force defensive adjustments.");
          if ((st.serve_error||0) > (st.ace||0) + 1) sug.push("Serve errors exceed aces — dial back risk, prioritize placement.");
          if ((st.ball_error||0) >= 3) sug.push(`${st.ball_error} ball handling errors — clean up passing and setting contacts.`);

          // Individual player analysis
          const hot = topH.find((h) => h.pct !== null && h.pct > 0.3 && h.att >= 3);
          if (hot) sug.push(`${hot.name} is hitting .${Math.round(hot.pct*1000).toString().padStart(3,"0")} — keep feeding them.`);
          const cold = topH.find((h) => h.pct !== null && h.pct < 0 && h.att >= 3);
          if (cold) sug.push(`${cold.name} negative hitting (${cold.k}K/${cold.e}E) — reduce their swings or move them.`);

          // Score-driven suggestions
          if (scoreDiff <= -5) sug.push("Down 5+ — consider lineup change or aggressive serving to break their rhythm.");
          else if (scoreDiff <= -3) sug.push("Down 3 — stay disciplined, minimize unforced errors, make them earn it.");
          else if (scoreDiff >= 5 && (set?.ourScore||0) >= 20) sug.push("Commanding lead — stay aggressive, close it out.");

          // Match context
          if (matchSetsLost > matchSetsWon && ((currentMatch.sets||[])).length > 1) sug.push("Down in match — consider adjustments from earlier sets.");
          if ((st.dig||0) < 3 && (set?.theirScore||0) >= 10) sug.push("Low digs — adjust defensive base positions.");
          if ((st.stuff_block||0) === 0 && (set?.theirScore||0) >= 10) sug.push("No stuff blocks — re-evaluate blocking scheme and assignments.");
          if (sug.length === 0) sug.push("Stats tracking with the formula — stay aggressive, trust the process.");

          return (
          <div style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.92)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center" }}>
            <div style={{ background: "#0a0a0f", border: "2px solid #007bff", borderRadius: 12, padding: 16, width: "92%", maxWidth: 400, maxHeight: "85vh", overflowY: "auto" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 }}>
                <span style={{ fontWeight: 800, fontSize: 16, color: "#007bff", letterSpacing: 2 }}>TIMEOUT</span>
                <button style={{ background: "#2a2a34", border: "none", color: "#fff", padding: "6px 14px", borderRadius: 6, fontWeight: 700, cursor: "pointer" }} onClick={() => setShowTimeout(false)}>CLOSE</button>
              </div>
              {/* Score */}
              <div style={{ display: "flex", justifyContent: "center", gap: 20, marginBottom: 4, fontSize: 28, fontWeight: 800 }}>
                <span style={{ color: set.ourScore >= set.theirScore ? "#22c55e" : "#ef4444" }}>{set.ourScore}</span>
                <span style={{ opacity: 0.3 }}>-</span>
                <span>{set.theirScore}</span>
              </div>
              {((currentMatch.sets||[])).length > 1 && (
                <div style={{ textAlign: "center", fontSize: 10, opacity: 0.4, marginBottom: 10 }}>Match: {matchSetsWon}-{matchSetsLost}</div>
              )}
              {/* Quick stats */}
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 6, marginBottom: 12 }}>
                {[
                  { v: att > 0 ? (kPct >= 0 ? "." : "-.") + Math.abs(Math.round(kPct*1000)).toString().padStart(3,"0") : "-", l: "HIT%", c: kPct >= 0.2 ? "#22c55e" : kPct >= 0 ? "#007bff" : "#ef4444" },
                  { v: st.kill||0, l: "KILLS", c: "#22c55e" },
                  { v: `${st.ace||0}/${st.serve_error||0}`, l: "SA/SE", c: "#007bff" },
                  { v: st.stuff_block||0, l: "STUFFS", c: "#22c55e" },
                ].map((d, i) => (
                  <div key={i} style={{ textAlign: "center", background: "#0d1118", borderRadius: 6, padding: 6 }}>
                    <div style={{ fontSize: 18, fontWeight: 800, color: d.c }}>{d.v}</div>
                    <div style={{ fontSize: 8, opacity: 0.5 }}>{d.l}</div>
                  </div>
                ))}
              </div>
              {/* Formula vs actual mini bars */}
              {fa.hasEnoughData && (
                <div style={{ marginBottom: 12 }}>
                  <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4, letterSpacing: 1 }}>VS FORMULA</div>
                  {fa.analysis.filter((s) => s.scoring && Math.abs(s.diff) >= 0.3).slice(0, 4).map((s) => {
                    const current = st[s.key] || 0;
                    const target = parseFloat(s.winAvg);
                    const expected = Math.round(target * paceThrough * 10) / 10;
                    const diff = current - expected;
                    const ahead = diff >= 0;
                    return (
                      <div key={s.key} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", fontSize: 11, padding: "3px 0", borderBottom: "1px solid #1a1a24" }}>
                        <span style={{ fontWeight: 600, flex: 1 }}>{s.label}</span>
                        <span style={{ fontWeight: 800, color: ahead ? "#22c55e" : "#ef4444", marginRight: 6 }}>{current}</span>
                        <span style={{ fontSize: 9, opacity: 0.4, minWidth: 50, textAlign: "right" }}>{ahead ? "+" : ""}{diff.toFixed(1)} pace</span>
                      </div>
                    );
                  })}
                </div>
              )}
              {/* Top hitters */}
              {topH.length > 0 && (
                <div style={{ marginBottom: 12 }}>
                  <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4, letterSpacing: 1 }}>TOP HITTERS</div>
                  {topH.map((h, i) => (
                    <div key={i} style={{ display: "flex", justifyContent: "space-between", fontSize: 12, padding: "3px 0", borderBottom: "1px solid #1a1a24" }}>
                      <span style={{ fontWeight: 700 }}>{h.name}</span>
                      <span>{h.k}K / {h.e}E / {h.att}att {h.pct !== null ? (h.pct >= 0 ? "." : "-.") + Math.abs(Math.round(h.pct*1000)).toString().padStart(3,"0") : ""}</span>
                    </div>
                  ))}
                </div>
              )}
              {/* Suggestions */}
              <div style={{ background: "#0a1a0a", borderRadius: 8, padding: 10, border: "1px solid #22c55e44" }}>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#22c55e", marginBottom: 6, letterSpacing: 1 }}>ADJUSTMENTS</div>
                {sug.map((s, i) => (
                  <div key={i} style={{ fontSize: 11, marginBottom: 4, paddingLeft: 8, borderLeft: "2px solid #22c55e44" }}>{s}</div>
                ))}
              </div>
            </div>
          </div>
          );
        })()}

        {/* Score header */}
        <div style={S.matchHeader}>
          <button style={S.backBtn} onClick={goBack}>←</button>
          <div style={S.scoreBoard}>
            <div style={S.teamCol}>
              <span style={S.teamLabel}>US</span>
              <span style={S.bigScore}>{set?.ourScore || 0}</span>
            </div>
            <div style={S.setChip}>
              S{set?.number || 1}
              <span style={{ fontSize: 9, display: "block", opacity: 0.7 }}>
                {(() => {
                  const sw = (currentMatch.sets||[]).filter((s) => s.complete && s.ourScore > s.theirScore).length;
                  const sl = (currentMatch.sets||[]).filter((s) => s.complete && s.ourScore < s.theirScore).length;
                  return sw > 0 || sl > 0 ? `${sw}-${sl}` : `R${set?.rotation || 1}`;
                })()}
              </span>
            </div>
            <div style={S.teamCol}>
              <span style={S.teamLabel}>{currentMatch.opponent?.slice(0, 5)?.toUpperCase() || "THEM"}</span>
              <span style={S.bigScore}>{set?.theirScore || 0}</span>
            </div>
          </div>
          <button style={S.undoBtn} onClick={undoLastAction} disabled={undoStack.length === 0}>↩</button>
          <button style={{ ...S.undoBtn, background: "#991b1b", marginLeft: 4 }} onClick={() => setShowTimeout(true)}>T/O</button>
        </div>

        {/* Serve indicator */}
        <div style={{ ...S.serveIndicator, background: set?.weServe ? "#0a1a0a" : "#1a0a0a" }}>
          {set?.weServe ? (
            <span>Our serve — <strong>{getPlayerById(server)?.name?.split(" ")[0] || `#${getPlayerById(server)?.number}`}</strong> serving</span>
          ) : (
            <span>Receiving — Next server: <strong>{getPlayerById(nextServer)?.name?.split(" ")[0] || `#${getPlayerById(nextServer)?.number}`}</strong> (zone 2)</span>
          )}
        </div>

        {/* Formula budget badge */}
        {(() => {
          const budget = getFormulaBudget(set, formulaAnalysis);
          if (budget === null) return null;
          const color = budget >= 0 ? "#22c55e" : "#ef4444";
          const bg = budget >= 0 ? "#0a1a0a" : "#1a0a0a";
          return (
            <div style={{ display: "flex", justifyContent: "center", alignItems: "center", gap: 6, padding: "3px 0", background: bg, borderBottom: "1px solid #1a1a24" }}>
              <span style={{ fontSize: 9, fontWeight: 700, opacity: 0.5, letterSpacing: 1 }}>FORMULA</span>
              <span style={{ fontSize: 13, fontWeight: 800, color }}>{budget >= 0 ? "+" : ""}{budget}</span>
              <span style={{ fontSize: 9, opacity: 0.4 }}>{budget >= 0 ? "ahead" : "behind"}</span>
            </div>
          );
        })()}

        {/* Tabs */}
        <div style={S.tabs}>
          {[
            { key: "court", label: "Court" },
            { key: "stats", label: "Stats" },
            { key: "formula", label: "Formula" },
            { key: "offense", label: "Offense" },
            { key: "scout", label: "Scout" },
            { key: "subs", label: "Subs" },
          ].map((t) => (
            <button key={t.key} style={{ ...S.tab, ...(tab === t.key ? S.tabActive : {}) }}
              onClick={() => setTab(t.key)}>
              {t.label}
              {t.key === "subs" && set?.subCount > 0 && (
                <span style={S.badge}>{set.subCount}</span>
              )}
            </button>
          ))}
        </div>

        {/* COURT TAB - PLAYER LIST VIEW */}
        {tab === "court" && (() => {
          try {
          const setter = getSetterOnCourt(set);
          const hitterIds = getHittersOnCourt(set) || [];
          const phase = rallyPhase === "idle" ? "pre_rally" : rallyPhase;
          const positions = [4, 3, 2, 5, 6, 1];
          const onCourtPlayerIds = Object.values(onCourt).filter((v) => typeof v === "string");

          return (
          <div style={S.matchContent}>
            {/* Assist selection popup */}
            {assistPrompt && (
              <div style={S.overlay}>
                <div style={S.popup}>
                  <div style={{ fontSize: 13, fontWeight: 800, color: "#007bff", marginBottom: 10, textAlign: "center" }}>
                    Who got the assist?
                  </div>
                  <div style={{ display: "flex", flexWrap: "wrap", gap: 6, justifyContent: "center" }}>
                    {/* Sort setter first */}
                    {onCourtPlayerIds
                      .filter((id) => id !== assistPrompt.killerId)
                      .sort((a, b) => (a === setter ? -1 : b === setter ? 1 : 0))
                      .map((id) => {
                      const p = getPlayerById(id);
                      const isSt = id === setter;
                      return (
                        <button key={id} style={{
                          ...S.ib,
                          background: isSt ? "#0056b3" : "#0a1929",
                          padding: isSt ? "10px 16px" : "8px 12px",
                          fontSize: isSt ? 14 : 12,
                          border: isSt ? "2px solid #5ba3ff" : "none",
                        }} onClick={() => {
                          recordEvent(id, "assist");
                          recordEvent(id, "set_attempt");
                          showToast(`${p?.name?.split(" ")[0]} AST`);
                          endRally(true, { ...assistPrompt.rally, endStat: "kill", attacker: assistPrompt.killerId, assister: id });
                          setAssistPrompt(null);
                        }}>
                          {p?.name?.split(" ")[0] || `#${p?.number}`}
                          {isSt && <span style={{ fontSize: 9, opacity: 0.7, display: "block" }}>SETTER</span>}
                        </button>
                      );
                    })}
                  </div>
                  <button style={{ ...S.gb, marginTop: 10, background: "#2a2a34", width: "100%" }} onClick={() => {
                    endRally(true, { ...assistPrompt.rally, endStat: "kill", attacker: assistPrompt.killerId });
                    setAssistPrompt(null);
                  }}>No Assist</button>
                </div>
              </div>
            )}

            {/* Phase bar */}
            <div style={{
              padding: "6px 12px", borderRadius: 8, textAlign: "center", marginBottom: 6,
              background: phase === "offense" ? "#0a1a0a" : phase === "defense" ? "#1a0a0a" : set?.weServe ? "#0a1020" : "#0a1525",
            }}>
              <span style={{ fontSize: 11, fontWeight: 800, letterSpacing: 2, color: "#007bff" }}>
                {phase === "pre_rally" && set?.weServe && `SERVING \u2014 ${getPlayerById(server)?.name?.split(" ")[0] || ""}`}
                {phase === "pre_rally" && !set?.weServe && "RECEIVE"}
                {phase === "offense" && "OFFENSE \u2014 tap a stat"}
                {phase === "defense" && "DEFENSE \u2014 tap a stat"}
              </span>
            </div>

            <div style={S.rowDivider}>&mdash; FRONT ROW &mdash;</div>

            {positions.map((pos, idx) => {
              const pid = onCourt[pos];
              const player = pid ? getPlayerById(pid) : null;
              if (!player) return null;

              const isServer = pid === server && set?.weServe;
              const isLibero = isLiberoId(pid, set);
              const isSetter = pid === setter;
              const isHitter = hitterIds.includes(pid);
              const isPasser = passerIds.includes(pid);
              const isPrimary = primaryPasserIds.includes(pid);
              const isFront = [4, 3, 2].includes(pos);
              const firstName = player.name?.split(" ")[0] || `#${player.number}`;

              let active = true;
              if (phase === "pre_rally" && set?.weServe) active = isServer;
              else if (phase === "pre_rally" && !set?.weServe) active = true; // everyone active on receive
              else if (phase === "offense") active = true;

              const ps = {};
              for (const ev of (set?.events || [])) {
                if (ev.player === pid && ev.stat !== "serve_in") {
                  ps[ev.stat] = (ps[ev.stat] || 0) + 1;
                }
              }

              const borderColor = isServer ? "#007bff" : (phase === "pre_rally" && !set?.weServe && isPrimary) ? "#007bff" : isLibero ? "#22c55e" : isSetter ? "#5ba3ff" : isHitter && phase === "offense" ? "#007bff" : "#1e1e28";

              return (
                <div key={pos}>
                  {idx === 3 && <div style={S.rowDivider}>&mdash; BACK ROW &mdash;</div>}
                  <div style={{
                    ...S.pRow,
                    opacity: active ? 1 : 0.3,
                    borderLeftColor: borderColor,
                  }}>
                    <div style={S.pId}>
                      <div style={{ display: "flex", alignItems: "baseline", gap: 4 }}>
                        <span style={S.pName}>{firstName}</span>
                        <span style={{ fontSize: 9, color: isLibero ? "#22c55e" : isSetter ? "#5ba3ff" : "#007bff", fontWeight: 700 }}>
                          {isLibero ? (() => {
                            const { lib1, lib2 } = getSetLiberos(set);
                            if (lib2 && pid === lib1) return "L1";
                            if (lib2 && pid === lib2) return "L2";
                            return "LIB";
                          })() : getEffectivePosition(pid)}
                        </span>
                        <span style={{ fontSize: 8, opacity: 0.3 }}>Z{pos}</span>
                        {isServer && <span style={{ fontSize: 9, color: "#007bff" }}>SRV</span>}
                        {/* Libero swap button — back row positions where an MB's rotation is active */}
                        {!isFront && (() => {
                          const { lib1, lib2 } = getSetLiberos(set);
                          if (!lib1 && !lib2) return null; // no liberos at all
                          // Only show on positions where an MB would normally be
                          const mbId = onCourt._liberoFor || (getEffectivePosition(pid) === "MB" ? pid : null);
                          if (!mbId) return null; // not an MB rotation position
                          
                          // Build cycle options: all assigned liberos for this MB + the MB themselves
                          const options = [];
                          const backRowMap = set.mbBackRowMap || {};
                          const assignment = backRowMap[mbId];
                          // Add liberos that could sub for this MB
                          if (lib1 && assignment !== "libero2") options.push(lib1);
                          if (lib2 && (assignment === "libero2" || !assignment)) options.push(lib2);
                          // If only lib1 exists and no specific assignment, lib1 is default
                          if (lib1 && !lib2 && !assignment) { /* lib1 already added */ }
                          // Always include MB self as option
                          options.push("self");
                          // If both liberos exist, make sure both are options regardless of assignment
                          if (lib1 && lib2) {
                            if (!options.includes(lib1)) options.splice(0, 0, lib1);
                            if (!options.includes(lib2)) options.splice(1, 0, lib2);
                          }
                          // Deduplicate
                          const uniqueOptions = [...new Set(options)];
                          if (uniqueOptions.length < 2) return null; // nothing to swap between
                          
                          // Find current in cycle
                          const currentSub = isLiberoId(pid, set) ? pid : "self";
                          const currentIdx = uniqueOptions.indexOf(currentSub);
                          const nextSub = uniqueOptions[(currentIdx + 1) % uniqueOptions.length];
                          
                          // Label
                          const nextLabel = nextSub === "self" 
                            ? getPlayerById(mbId)?.name?.split(" ")[0] || "MB"
                            : getPlayerById(nextSub)?.name?.split(" ")[0] || "LIB";
                          
                          return (
                            <button style={{
                              fontSize: 8, fontWeight: 700, color: "#22c55e", background: "#0a1a0a",
                              border: "1px solid #22c55e", borderRadius: 4, padding: "1px 5px",
                              cursor: "pointer", marginLeft: 2,
                            }} onClick={(e) => {
                              e.stopPropagation();
                              updateCurrentSet((s) => ({
                                ...s,
                                liberoSwaps: { ...(s.liberoSwaps || {}), [mbId]: nextSub },
                              }));
                              showToast(`SWAP → ${nextLabel}`);
                            }}>SWAP</button>
                          );
                        })()}
                      </div>
                      <div style={{ display: "flex", gap: 3, flexWrap: "wrap", marginTop: 1 }}>
                        {ps.kill > 0 && <span style={S.mSt}>{ps.kill}K</span>}
                        {ps.attack_error > 0 && <span style={{ ...S.mSt, color: "#ef4444" }}>{ps.attack_error}AE</span>}
                        {ps.ball_error > 0 && <span style={{ ...S.mSt, color: "#ef4444" }}>{ps.ball_error}BE</span>}
                        {ps.attack_blocked > 0 && <span style={{ ...S.mSt, color: "#60a5fa" }}>{ps.attack_blocked}AB</span>}
                        {ps.block > 0 && <span style={{ ...S.mSt, color: "#60a5fa" }}>{ps.block}BT</span>}
                        {ps.stuff_block > 0 && <span style={{ ...S.mSt, color: "#22c55e" }}>{ps.stuff_block}SB</span>}
                        {ps.dig > 0 && <span style={S.mSt}>{ps.dig}D</span>}
                        {ps.cvr > 0 && <span style={{ ...S.mSt, color: "#60a5fa" }}>{ps.cvr}CV</span>}
                        {ps.ace > 0 && <span style={{ ...S.mSt, color: "#007bff" }}>{ps.ace}A</span>}
                        {ps.serve_error > 0 && <span style={{ ...S.mSt, color: "#ef4444" }}>{ps.serve_error}SE</span>}
                        {ps.assist > 0 && <span style={{ ...S.mSt, color: "#5ba3ff" }}>{ps.assist}AS</span>}
                        {ps.reception > 0 && <span style={S.mSt}>{ps.reception}R</span>}
                      </div>
                    </div>

                    <div style={S.pBtns}>
                      {/* SERVE */}
                      {phase === "pre_rally" && set?.weServe && isServer && (
                        <>
                          <button style={{ ...S.ib, background: "#581c87" }} onClick={() => {
                            recordEvent(pid, "ace"); showToast(`${firstName} ACE`);
                            endRally(true, { type: "our_serve", server: pid, result: "ace" });
                          }}>ACE</button>
                          <button style={{ ...S.ib, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "serve_error"); showToast(`${firstName} ERR`);
                            endRally(false, { type: "our_serve", server: pid, result: "serve_error" });
                          }}>ERR</button>
                          <button style={{ ...S.ib, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 1 }); showToast("\u21921");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 1 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}1</button>
                          <button style={{ ...S.ib, background: "#854d0e" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 2 }); showToast("\u21922");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 2 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}2</button>
                          <button style={{ ...S.ib, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 3 }); showToast("\u21923");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 3 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}3</button>
                        </>
                      )}

                      {/* RECEIVE — all players can pass, primary passers emphasized */}
                      {phase === "pre_rally" && !set?.weServe && isPasser && (
                        <div style={{ display: "flex", gap: 3, opacity: isPrimary ? 1 : 0.55 }}>
                          <button style={{ ...S.ib, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 0 }); recordEvent(pid, "reception_error");
                            showToast(`${firstName} ACED`);
                            endRally(false, { type: "their_serve", passer: pid, passQuality: 0 });
                          }}>0</button>
                          <button style={{ ...S.ib, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 1 }); showToast(`${firstName} 1`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 1 });
                            setRallyPhase("offense");
                          }}>1</button>
                          <button style={{ ...S.ib, background: "#854d0e" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 2 }); showToast(`${firstName} 2`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 2 });
                            setRallyPhase("offense");
                          }}>2</button>
                          <button style={{ ...S.ib, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 3 }); showToast(`${firstName} 3`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 3 });
                            setRallyPhase("offense");
                          }}>3</button>
                        </div>
                      )}

                      {/* OFFENSE: hitters */}
                      {phase === "offense" && isHitter && (
                        <>
                          <button style={{ ...S.ib, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "kill"); showToast(`${firstName} KILL`);
                            setAssistPrompt({ killerId: pid, rally: { ...currentRally } });
                          }}>KILL</button>
                          <button style={{ ...S.ib, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "attack_error"); showToast(`${firstName} ATT E`);
                            endRally(false, { ...currentRally, endStat: "attack_error", attacker: pid });
                          }}>ATT E</button>
                          <button style={{ ...S.ib, background: "#0a1929" }} onClick={() => {
                            recordEvent(pid, "attack_blocked"); showToast(`${firstName} BLKD`);
                            endRally(false, { ...currentRally, endStat: "attack_blocked", attacker: pid });
                          }}>BLKD</button>
                          <button style={{ ...S.ib, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); recordEvent(pid, "dig"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.ib, background: "#854d0e" }} onClick={() => {
                            showToast("Dug \u2192 DEF");
                            setRallyPhase("defense");
                          }}>DUG</button>
                          <button style={{ ...S.ib, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* OFFENSE: setter — SET + KILL/ATT E/BLKD/CVR/DUG/ERR (dumps + errors) */}
                      {phase === "offense" && isSetter && (
                        <>
                          <button style={{ ...S.ib, background: "#0056b3" }} onClick={() => {
                            recordEvent(pid, "set_attempt"); showToast(`${firstName} SET`);
                          }}>SET</button>
                          <button style={{ ...S.ib, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "kill"); showToast(`${firstName} KILL`);
                            setAssistPrompt({ killerId: pid, rally: { ...currentRally } });
                          }}>KILL</button>
                          <button style={{ ...S.ib, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "attack_error"); showToast(`${firstName} ATT E`);
                            endRally(false, { ...currentRally, endStat: "attack_error", attacker: pid });
                          }}>ATT E</button>
                          <button style={{ ...S.ib, background: "#0a1929" }} onClick={() => {
                            recordEvent(pid, "attack_blocked"); showToast(`${firstName} BLKD`);
                            endRally(false, { ...currentRally, endStat: "attack_blocked", attacker: pid });
                          }}>BLKD</button>
                          <button style={{ ...S.ib, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); recordEvent(pid, "dig"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.ib, background: "#854d0e" }} onClick={() => {
                            showToast("Dug \u2192 DEF");
                            setRallyPhase("defense");
                          }}>DUG</button>
                          <button style={{ ...S.ib, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* OFFENSE: any player — CVR + generic error */}
                      {phase === "offense" && !isHitter && !isSetter && (
                        <>
                          <button style={{ ...S.ib, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); recordEvent(pid, "dig"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.ib, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* DEFENSE */}
                      {phase === "defense" && (
                        <>
                          {isFront && (
                            <>
                              <button style={{ ...S.ib, background: "#0a1929" }} onClick={() => {
                                recordEvent(pid, "block"); showToast(`${firstName} BLK TOUCH`);
                                // Ball still alive on their side — stay on defense
                              }}>BLK</button>
                              <button style={{ ...S.ib, background: "#16a34a" }} onClick={() => {
                                recordEvent(pid, "stuff_block"); showToast(`${firstName} STUFF`);
                                endRally(true, { ...currentRally, endStat: "stuff_block", blocker: pid });
                              }}>STUFF</button>
                            </>
                          )}
                          <button style={{ ...S.ib, background: "#365314" }} onClick={() => {
                            recordEvent(pid, "dig"); showToast(`${firstName} DIG`);
                            setRallyPhase("offense");
                          }}>DIG</button>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              );
            })}

            {/* Global buttons */}
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 4, marginTop: 8 }}>
              <button style={S.gb} onClick={() => {
                showToast("Opp Error +1");
                if (phase !== "pre_rally") endRally(true, { ...currentRally, endStat: "opponent_error" });
                else scorePoint(true);
              }}>OPP ERROR +1</button>
              <button style={{ ...S.gb, background: "#991b1b" }} onClick={() => {
                showToast("Their Kill");
                if (phase !== "pre_rally") endRally(false, { ...currentRally, endStat: "their_kill" });
                else scorePoint(false);
              }}>THEIR KILL</button>
              <button style={{ ...S.gb, background: "#1a1a24" }} onClick={() => { scorePoint(true); showToast("+1 Us"); }}>+ OUR PT</button>
              <button style={{ ...S.gb, background: "#1a1a24" }} onClick={() => { scorePoint(false); showToast("+1 Them"); }}>+ THEIR PT</button>
              <button style={{ ...S.gb, background: "#1a3a1a", gridColumn: "1 / -1" }} onClick={() => {
                if (phase === "offense") {
                  showToast("Free Ball → DEF");
                  setRallyPhase("defense");
                } else if (phase === "defense") {
                  showToast("Free Ball → OFF");
                  setRallyPhase("offense");
                } else {
                  // pre_rally — opponent free balls after serve
                  if (set?.weServe) {
                    showToast("Free Ball → DEF");
                    setCurrentRally({ type: "our_serve", server: server });
                    setRallyPhase("defense");
                  } else {
                    showToast("Free Ball → OFF");
                    setCurrentRally({ type: "their_serve" });
                    setRallyPhase("offense");
                  }
                }
              }}>FREE BALL</button>
            </div>

            <button style={S.endSetBtn} onClick={endCurrentSet}>
              End Set {set?.number} &rarr;
            </button>
            <button style={{ width: "100%", padding: 10, background: "none", border: "1px solid #ef4444", borderRadius: 12, color: "#ef4444", fontSize: 12, fontWeight: 600, cursor: "pointer", marginTop: 6, opacity: 0.6 }} onClick={endMatchEarly}>
              End Match
            </button>
          </div>
          );
          } catch (e) {
            return <div style={{ padding: 16, color: "#ef4444" }}>Court error: {e.message}. <button onClick={() => setRallyPhase("idle")} style={{ color: "#007bff", background: "none", border: "1px solid #007bff", borderRadius: 8, padding: "4px 12px", cursor: "pointer" }}>Reset</button></div>;
          }
        })()}

        {/* STATS TAB */}
        {tab === "stats" && (() => {
          // Determine which data to show
          const viewSets = currentMatch?.sets || [];
          const isMatchView = statsSetView === "match";
          const viewSetData = isMatchView ? null : (statsSetView === "current" ? set : viewSets[Number(statsSetView)]);

          // Build stats for the selected view
          const getViewStats = (playerId) => {
            const stats = {};
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.player === playerId && ev.stat !== "serve_in") stats[ev.stat] = (stats[ev.stat] || 0) + 1;
              }
            }
            return stats;
          };

          const getViewTotals = () => {
            const totals = {};
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.stat !== "serve_in") totals[ev.stat] = (totals[ev.stat] || 0) + 1;
              }
            }
            return totals;
          };

          const getViewPassingStats = (playerId) => {
            const passes = { 0: 0, 1: 0, 2: 0, 3: 0 };
            let total = 0;
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.player === playerId && ev.stat === "reception" && ev.quality !== undefined) {
                  passes[ev.quality] = (passes[ev.quality] || 0) + 1;
                  total++;
                }
              }
            }
            if (total === 0) return null;
            let weightedSum = 0, weightTotal = 0;
            for (const [q, count] of Object.entries(passes)) {
              const w = PASS_WEIGHTS[q] || 0;
              weightedSum += Number(q) * w * count;
              weightTotal += w * count;
            }
            return { passes, total, weightedScore: weightTotal > 0 ? weightedSum / weightTotal : 0, simpleAvg: (passes[0]*0+passes[1]*1+passes[2]*2+passes[3]*3)/total };
          };

          const vTotals = getViewTotals();
          const viewLabel = isMatchView ? "MATCH" : (statsSetView === "current" ? `SET ${set?.number}` : `SET ${Number(statsSetView) + 1}`);

          // Player +/- for current view
          const viewPM = {};
          const setsForPM = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
          for (const s of setsForPM) {
            const setPm = getPlayerPlusMinus(s);
            for (const [pid, val] of Object.entries(setPm)) {
              viewPM[pid] = (viewPM[pid] || 0) + val;
            }
          }

          return (
          <div style={S.matchContent}>
            {/* Set selector */}
            <div style={{ display: "flex", gap: 4, marginBottom: 8, flexWrap: "wrap" }}>
              {viewSets.map((s, i) => (
                <button key={i} style={{ ...S.ib, background: (statsSetView === "current" && i === currentSetIdx) || statsSetView === String(i) ? "#007bff" : "#1a1a24", color: (statsSetView === "current" && i === currentSetIdx) || statsSetView === String(i) ? "#000" : "#e2e8f0", fontWeight: 700, fontSize: 11, padding: "6px 10px" }}
                  onClick={() => setStatsSetView(i === currentSetIdx ? "current" : String(i))}>
                  S{s.number} ({s.ourScore}-{s.theirScore})
                </button>
              ))}
              {viewSets.length > 1 && (
                <button style={{ ...S.ib, background: isMatchView ? "#007bff" : "#1a1a24", color: isMatchView ? "#000" : "#e2e8f0", fontWeight: 700, fontSize: 11, padding: "6px 10px" }}
                  onClick={() => setStatsSetView("match")}>
                  MATCH
                </button>
              )}
            </div>

            {/* Player stats table */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>PLAYER STATS &mdash; {viewLabel}</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>+/-</th>
                      <th style={S.sth}>K</th>
                      <th style={S.sth}>AE</th>
                      <th style={S.sth}>Att</th>
                      <th style={S.sth}>Att%</th>
                      <th style={S.sth}>A</th>
                      <th style={S.sth}>SA</th>
                      <th style={S.sth}>SE</th>
                      <th style={S.sth}>D</th>
                      <th style={S.sth}>CV</th>
                      <th style={S.sth}>BK</th>
                      <th style={S.sth}>SB</th>
                      <th style={S.sth}>BE</th>
                      <th style={S.sth}>R</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rosterPlayers.map((p) => {
                      const ps = getViewStats(p.id);
                      const att = (ps.kill || 0) + (ps.attack_error || 0) + (ps.attack_blocked || 0);
                      const kPct = att > 0 ? ((ps.kill || 0) - (ps.attack_error || 0)) / att : null;
                      const pm = viewPM[p.id] || 0;
                      const hasStats = Object.keys(ps).length > 0 || pm !== 0;
                      if (!hasStats) return null;
                      return (
                        <tr key={p.id}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>{p.name?.split(" ")[0] || `#${p.number}`}</td>
                          <td style={{ ...S.std, fontWeight: 800, color: pm > 0 ? "#22c55e" : pm < 0 ? "#ef4444" : "#6b7280" }}>{pm > 0 ? "+" : ""}{pm}</td>
                          <td style={{ ...S.std, color: (ps.kill || 0) > 0 ? "#22c55e" : "#6b7280" }}>{ps.kill || 0}</td>
                          <td style={{ ...S.std, color: (ps.attack_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.attack_error || 0}</td>
                          <td style={S.std}>{att}</td>
                          <td style={{ ...S.std, fontWeight: 700, color: kPct !== null && kPct > 0 ? "#22c55e" : kPct !== null && kPct < 0 ? "#ef4444" : "#6b7280" }}>{kPct === null ? "-" : (kPct >= 0 ? "." : "-.") + Math.abs(Math.round(kPct * 1000)).toString().padStart(3, "0")}</td>
                          <td style={{ ...S.std, color: "#5ba3ff" }}>{ps.assist || 0}</td>
                          <td style={{ ...S.std, color: "#007bff" }}>{ps.ace || 0}</td>
                          <td style={{ ...S.std, color: (ps.serve_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.serve_error || 0}</td>
                          <td style={S.std}>{ps.dig || 0}</td>
                          <td style={{ ...S.std, color: "#60a5fa" }}>{ps.cvr || 0}</td>
                          <td style={S.std}>{ps.block || 0}</td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{ps.stuff_block || 0}</td>
                          <td style={{ ...S.std, color: (ps.ball_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.ball_error || 0}</td>
                          <td style={S.std}>{ps.reception || 0}</td>
                        </tr>
                      );
                    })}
                    {/* Team totals */}
                    <tr style={{ borderTop: "2px solid #007bff" }}>
                      <td style={{ ...S.std, fontWeight: 800, color: "#007bff" }}>TEAM</td>
                      <td style={{ ...S.std, fontWeight: 800 }}></td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.kill || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.attack_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{(vTotals.kill || 0) + (vTotals.attack_error || 0) + (vTotals.attack_blocked || 0)}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{(() => { const a = (vTotals.kill||0)+(vTotals.attack_error||0)+(vTotals.attack_blocked||0); return a > 0 ? (((vTotals.kill||0)-(vTotals.attack_error||0))/a >= 0 ? "." : "-.") + Math.abs(Math.round(((vTotals.kill||0)-(vTotals.attack_error||0))/a*1000)).toString().padStart(3, "0") : "-"; })()}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.assist || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.ace || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.serve_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.dig || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.cvr || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.block || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.stuff_block || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.ball_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.reception || 0}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            {/* Passing Stats */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>PASSING &mdash; {viewLabel}</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>Tot</th>
                      <th style={S.sth}>3s</th>
                      <th style={S.sth}>2s</th>
                      <th style={S.sth}>1s</th>
                      <th style={S.sth}>0s</th>
                      <th style={S.sth}>Avg</th>
                      <th style={S.sth}>Wtd</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rosterPlayers.map((p) => {
                      const ps = getViewPassingStats(p.id);
                      if (!ps) return null;
                      const wtdColor = ps.weightedScore >= 2.5 ? "#22c55e" : ps.weightedScore >= 2.0 ? "#007bff" : "#ef4444";
                      return (
                        <tr key={p.id}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>{p.name?.split(" ")[0] || `#${p.number}`}</td>
                          <td style={S.std}>{ps.total}</td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{ps.passes[3]}</td>
                          <td style={{ ...S.std, color: "#007bff" }}>{ps.passes[2]}</td>
                          <td style={{ ...S.std, color: "#ef4444" }}>{ps.passes[1]}</td>
                          <td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps.passes[0]}</td>
                          <td style={S.std}>{ps.simpleAvg.toFixed(1)}</td>
                          <td style={{ ...S.std, fontWeight: 800, color: wtdColor }}>{ps.weightedScore.toFixed(2)}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              <div style={{ fontSize: 9, opacity: 0.4, marginTop: 6, textAlign: "center" }}>
                Wtd = Weighted score (3&rarr;1.5x, 2&rarr;1.0x, 1&rarr;0.5x, 0&rarr;0x). 2.5+ = elite, 2.0-2.4 = solid, &lt;2.0 = needs work
              </div>
            </div>
          </div>
          );
        })()}

        {/* FORMULA TAB - Dynamic Win/Loss Analysis */}
        {tab === "formula" && (
          <div style={S.matchContent}>
            {/* Current set scoring progress */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>SET {set?.number} SCORING</h3>
              <p style={S.cardSub}>{setProgress.totalScored} points scored</p>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, margin: "10px 0" }}>
                {setProgress.stats.filter((s) => s.scoring).map((s) => (
                  <div key={s.key} style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: s.actual > 0 ? "#22c55e" : "#4b5563" }}>{s.actual}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>{s.label}</div>
                  </div>
                ))}
              </div>
              <div style={S.remainingBox}>
                <span style={{ fontSize: 28, fontWeight: 800, color: setProgress.remaining <= 5 ? "#22c55e" : "#007bff" }}>
                  {setProgress.remaining}
                </span>
                <span style={{ fontSize: 12, opacity: 0.6 }}>points to go</span>
              </div>
            </div>

            {/* Dynamic formula from match history */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>THE FORMULA</h3>
              {!formulaAnalysis.hasEnoughData ? (
                <div style={{ textAlign: "center", padding: "16px 8px" }}>
                  <div style={{ fontSize: 13, opacity: 0.5, marginBottom: 8 }}>
                    {formulaAnalysis.totalSets === 0
                      ? "No completed sets yet."
                      : `${formulaAnalysis.totalSets} set${formulaAnalysis.totalSets > 1 ? "s" : ""} completed (${formulaAnalysis.wonSets}W / ${formulaAnalysis.lostSets}L)`}
                  </div>
                  <div style={{ fontSize: 12, opacity: 0.4 }}>
                    The formula learns from your wins and losses. Complete more sets with both wins and losses to see what separates them.
                  </div>
                </div>
              ) : (
                <>
                  <p style={S.cardSub}>
                    Based on {formulaAnalysis.totalSets} sets ({formulaAnalysis.wonSets}W / {formulaAnalysis.lostSets}L)
                  </p>
                  <div style={{ fontSize: 10, opacity: 0.4, textAlign: "center", marginBottom: 8 }}>
                    Sorted by biggest difference between wins and losses
                  </div>
                  {formulaAnalysis.analysis.filter((s) => Math.abs(s.diff) >= 0.3).map((s) => {
                    const current = s.key === "stuff_block" ? (setTotals.stuff_block || 0) : (setTotals[s.key] || 0);
                    const target = parseFloat(s.winAvg);
                    const lossTarget = parseFloat(s.lossAvg);
                    const totalPts = (set?.ourScore || 0) + (set?.theirScore || 0);
                    const paceThrough = totalPts > 0 ? Math.min(totalPts / 50, 1) : 0;
                    const expectedNow = target * paceThrough;
                    let onTrack, pct, surplus;
                    if (s.scoring) {
                      onTrack = current >= expectedNow * 0.85;
                      pct = target > 0 ? Math.min((current / target) * 100, 100) : 0;
                      surplus = Math.round((current - expectedNow) * 10) / 10;
                    } else {
                      const errExpected = lossTarget * paceThrough;
                      onTrack = current <= errExpected * 1.1;
                      pct = lossTarget > 0 ? Math.min((current / lossTarget) * 100, 100) : 0;
                      surplus = Math.round((errExpected - current) * 10) / 10; // positive = good (fewer errors)
                    }
                    const barColor = onTrack ? "#22c55e" : "#ef4444";
                    return (
                      <div key={s.key} style={{ marginBottom: 10 }}>
                        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 3 }}>
                          <span style={{ fontWeight: 700, fontSize: 12 }}>{s.label}</span>
                          <span style={{ fontSize: 11 }}>
                            <span style={{ fontWeight: 800, color: barColor }}>{current}</span>
                            <span style={{ opacity: 0.4 }}> / {s.scoring ? s.winAvg : s.lossAvg} target</span>
                          </span>
                        </div>
                        <div style={{ background: "#1a1a24", borderRadius: 6, height: 14, overflow: "hidden", position: "relative" }}>
                          <div style={{ height: "100%", borderRadius: 6, background: barColor, width: `${pct}%`, transition: "width 0.3s", opacity: 0.85 }} />
                          {paceThrough > 0 && (
                            <div style={{ position: "absolute", top: 0, bottom: 0, left: `${paceThrough * 100}%`, width: 2, background: "#fff", opacity: 0.4 }} />
                          )}
                        </div>
                        <div style={{ display: "flex", justifyContent: "space-between", fontSize: 9, marginTop: 2 }}>
                          <span style={{ opacity: 0.4 }}>Target: {s.scoring ? s.winAvg : s.lossAvg}</span>
                          <span style={{ fontWeight: 700, color: surplus >= 0 ? "#22c55e" : "#ef4444" }}>
                            {surplus >= 0 ? "+" : ""}{surplus} {s.scoring ? "ahead" : (surplus >= 0 ? "margin" : "over")}
                          </span>
                        </div>
                      </div>
                    );
                  })}

                  {/* POINT BUDGET — surplus/deficit across scoring categories */}
                  {(() => {
                    const totalPts = (set?.ourScore || 0) + (set?.theirScore || 0);
                    const paceThrough = totalPts > 0 ? Math.min(totalPts / 50, 1) : 0;
                    const scoringStats = formulaAnalysis.analysis.filter((s) => s.scoring && Math.abs(s.diff) >= 0.3);
                    let totalSurplus = 0;
                    const items = scoringStats.map((s) => {
                      const current = setTotals[s.key] || 0;
                      const expected = parseFloat(s.winAvg) * paceThrough;
                      const diff = Math.round((current - expected) * 10) / 10;
                      totalSurplus += diff;
                      return { label: s.label, diff, current };
                    });
                    if (items.length === 0 || paceThrough === 0) return null;
                    totalSurplus = Math.round(totalSurplus * 10) / 10;
                    return (
                      <div style={{ ...S.card, background: totalSurplus >= 0 ? "#0a1a0a" : "#1a0a0a", marginTop: 8, padding: 12, border: `1px solid ${totalSurplus >= 0 ? "#22c55e33" : "#ef444433"}` }}>
                        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 }}>
                          <span style={{ fontWeight: 800, fontSize: 11, letterSpacing: 1, color: totalSurplus >= 0 ? "#22c55e" : "#ef4444" }}>POINT BUDGET</span>
                          <span style={{ fontWeight: 800, fontSize: 16, color: totalSurplus >= 0 ? "#22c55e" : "#ef4444" }}>
                            {totalSurplus >= 0 ? "+" : ""}{totalSurplus}
                          </span>
                        </div>
                        <div style={{ display: "flex", gap: 4, flexWrap: "wrap" }}>
                          {items.map((it) => (
                            <div key={it.label} style={{
                              padding: "4px 8px", borderRadius: 6, fontSize: 10, fontWeight: 700,
                              background: it.diff >= 0 ? "#22c55e22" : "#ef444422",
                              color: it.diff >= 0 ? "#22c55e" : "#ef4444",
                              border: `1px solid ${it.diff >= 0 ? "#22c55e33" : "#ef444433"}`,
                            }}>
                              {it.label.split(" ")[0]} {it.diff >= 0 ? "+" : ""}{it.diff}
                            </div>
                          ))}
                        </div>
                        <div style={{ fontSize: 10, opacity: 0.5, marginTop: 6 }}>
                          {totalSurplus >= 0
                            ? `${totalSurplus} point${Math.abs(totalSurplus) !== 1 ? "s" : ""} banked across scoring categories — can absorb that in other areas.`
                            : `Need ${Math.abs(totalSurplus)} more point${Math.abs(totalSurplus) !== 1 ? "s" : ""} to match formula pace — push scoring categories.`}
                        </div>
                      </div>
                    );
                  })()}
                  {/* Key insight */}
                  {(() => {
                    const top = formulaAnalysis.analysis[0];
                    if (!top || Math.abs(top.diff) < 0.5) return null;
                    const verb = top.scoring
                      ? (top.diff > 0 ? "more" : "fewer")
                      : (top.diff < 0 ? "fewer" : "more");
                    return (
                      <div style={{ ...S.insightBox, marginTop: 10 }}>
                        <span style={S.insightLabel}>TOP DIFFERENTIATOR</span>
                        <p style={S.insightText}>
                          When you win, you average {Math.abs(top.diff)} {verb} {top.label.toLowerCase()} per set.
                        </p>
                      </div>
                    );
                  })()}
                </>
              )}
            </div>

            {/* Serve Risk */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>SERVE RISK</h3>
              <div style={{ display: "flex", gap: 16, justifyContent: "center", margin: "12px 0" }}>
                <div style={S.statCol}>
                  <span style={{ color: "#007bff", fontSize: 22, fontWeight: 800 }}>{serveRisk.aces}</span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Aces</span>
                </div>
                <div style={S.statCol}>
                  <span style={{ color: "#ef4444", fontSize: 22, fontWeight: 800 }}>{serveRisk.errors}</span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Errors</span>
                </div>
                <div style={S.statCol}>
                  <span style={{ color: serveRisk.net > 0 ? "#22c55e" : "#ef4444", fontSize: 22, fontWeight: 800 }}>
                    {serveRisk.net > 0 ? "+" : ""}{serveRisk.net}
                  </span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Net</span>
                </div>
              </div>
              <p style={{ fontSize: 13, textAlign: "center", opacity: 0.7, fontStyle: "italic", margin: 0 }}>
                {serveRisk.recommendation}
              </p>
            </div>

            {/* Serve-to-Rally Correlation */}
            {(() => {
              const corr = getServeCorrelation();
              const hasData = Object.values(corr.ourServes).some((v) => v.total > 0) || Object.values(corr.theirServes).some((v) => v.total > 0);
              if (!hasData) return null;
              return (
                <div style={S.card}>
                  <h3 style={S.cardTitle}>SERVE &rarr; RALLY CORRELATION</h3>
                  {Object.values(corr.ourServes).some((v) => v.total > 0) && (
                    <div style={{ marginBottom: 16 }}>
                      <span style={S.corrLabel}>OUR SERVE &mdash; Win % by forced pass</span>
                      <div style={{ display: "flex", gap: 12, marginTop: 8 }}>
                        {[1, 2, 3].map((q) => {
                          const d = corr.ourServes[q];
                          const winPct = d.total > 0 ? Math.round((d.won / d.total) * 100) : 0;
                          return (
                            <div key={q} style={S.corrCol}>
                              <span style={{ fontSize: 11, opacity: 0.5 }}>{q}-pass</span>
                              <span style={{ fontSize: 20, fontWeight: 800, color: winPct >= 60 ? "#22c55e" : winPct >= 40 ? "#007bff" : "#ef4444" }}>
                                {d.total > 0 ? `${winPct}%` : "-"}
                              </span>
                              <span style={{ fontSize: 10, opacity: 0.4 }}>{d.total} rallies</span>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}
                  {Object.values(corr.theirServes).some((v) => v.total > 0) && (
                    <div>
                      <span style={S.corrLabel}>OUR RECEIVE &mdash; Win % by our pass</span>
                      <div style={{ display: "flex", gap: 12, marginTop: 8 }}>
                        {[1, 2, 3].map((q) => {
                          const d = corr.theirServes[q];
                          const winPct = d.total > 0 ? Math.round((d.won / d.total) * 100) : 0;
                          return (
                            <div key={q} style={S.corrCol}>
                              <span style={{ fontSize: 11, opacity: 0.5 }}>{q}-pass</span>
                              <span style={{ fontSize: 20, fontWeight: 800, color: winPct >= 60 ? "#22c55e" : winPct >= 40 ? "#007bff" : "#ef4444" }}>
                                {d.total > 0 ? `${winPct}%` : "-"}
                              </span>
                              <span style={{ fontSize: 10, opacity: 0.4 }}>{d.total} rallies</span>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}

            {/* Set history */}
            {((currentMatch.sets||[])).filter((s) => s.complete).length > 0 && (
              <div style={S.card}>
                <h3 style={S.cardTitle}>SET HISTORY</h3>
                {((currentMatch.sets||[])).filter((s) => s.complete).map((s, i) => {
                  const st = getSetTotals(s);
                  return (
                    <div key={i} style={S.setHistoryRow}>
                      <div style={{ display: "flex", justifyContent: "space-between" }}>
                        <span style={{ fontWeight: 700 }}>Set {s.number}</span>
                        <span style={{ color: s.ourScore > s.theirScore ? "#22c55e" : "#ef4444", fontWeight: 700 }}>
                          {s.ourScore}-{s.theirScore}
                        </span>
                      </div>
                      <div style={{ fontSize: 11, opacity: 0.6, marginTop: 4 }}>
                        K:{st.kill || 0} SB:{st.stuff_block || 0} A:{st.ace || 0} OE:{st.opponent_error || 0} SE:{st.serve_error || 0}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        )}

        {/* OFFENSE TAB */}
        {tab === "offense" && (
          <div style={S.matchContent}>
            <div style={S.card}>
              <h3 style={S.cardTitle}>OFFENSE</h3>
              <p style={S.cardSub}>Set {set?.number} &bull; {totalSwings} total attacks</p>
              {swingDist.filter((d) => d.attacks > 0).length === 0 ? (
                <p style={{ textAlign: "center", opacity: 0.4, padding: 24, fontSize: 14 }}>No attacks yet</p>
              ) : (
                swingDist.filter((d) => d.attacks > 0).map((d, i) => {
                  const pct = totalSwings > 0 ? (d.attacks / totalSwings) * 100 : 0;
                  return (
                    <div key={i} style={{ marginBottom: 12 }}>
                      <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 3 }}>
                        <span style={{ fontWeight: 600 }}>
                          {d.player.name?.split(" ")[0] || `#${d.player.number}`}
                          <span style={{ fontSize: 10, opacity: 0.4, marginLeft: 4 }}>{d.player.position}</span>
                        </span>
                        <span style={{ fontSize: 12 }}>
                          {d.attacks}att ({d.kills}K/{d.errors}E/{d.blocked}B) {d.killPct !== null ? (d.killPct >= 0 ? "." : "-.") + Math.abs(Math.round(d.killPct * 1000)).toString().padStart(3, "0") : "-"}
                        </span>
                      </div>
                      <div style={S.progressBg}>
                        <div style={{ ...S.progressFill, width: `${pct}%`, background: pct > 30 ? "#007bff" : "#3b82f6" }} />
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        )}

        {/* SCOUT TAB - Opponent Shot Chart */}
        {tab === "scout" && (() => {
          const shots = set?.shots || [];
          const ZONES = [
            { id: 1, label: "Z1" }, { id: 6, label: "Z6" }, { id: 5, label: "Z5" },
            { id: 2, label: "Z2" }, { id: 3, label: "Z3" }, { id: 4, label: "Z4" },
          ];
          const outcomeColor = { kill: "#ef4444", dug: "#007bff", error: "#3b82f6" };
          const COURT_H = 200;

          const handleCourtTap = (e, manualX, manualY) => {
            if (!scoutPending) return;
            let x, y;
            if (e && e.currentTarget) { const rect = e.currentTarget.getBoundingClientRect(); x = ((e.clientX - rect.left) / rect.width) * 100; y = ((e.clientY - rect.top) / rect.height) * 100; }
            else { x = manualX; y = manualY; }
            const shot = { id: Date.now().toString(), originZone: scoutPending.originZone, outcome: scoutPending.outcome, x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10, timestamp: Date.now() };
            updateCurrentSet((s) => ({ ...s, shots: [...(s.shots || []), shot] }));
            const isOOB = x < 0 || x > 100 || y < 0 || y > 100;
            showToast(`${({ kill: "KILL", dug: "DUG", error: "ERR" })[scoutPending.outcome]}${isOOB ? " (OUT)" : ""} from Z${scoutPending.originZone}`);
            setScoutPending(null);
          };
          const undoLastShot = () => { updateCurrentSet((s) => ({ ...s, shots: (s.shots || []).slice(0, -1) })); showToast("Shot removed"); };

          const getOriginStats = () => { const stats = {}; for (const z of ZONES) { const zs = shots.filter((s) => s.originZone === z.id); stats[z.id] = { kills: zs.filter((s) => s.outcome === "kill").length, dug: zs.filter((s) => s.outcome === "dug").length, errors: zs.filter((s) => s.outcome === "error").length, total: zs.length }; } return stats; };
          const originStats = getOriginStats();
          const filteredShots = scoutOriginFilter !== null ? shots.filter((s) => s.originZone === scoutOriginFilter) : shots;

          const courtSvg = (shotList, interactive) => {
            const W = 300, H = COURT_H, PAD = 14, TW = W + PAD * 2, TH = H + PAD * 2;
            const inB = shotList.filter((s) => s.x >= 0 && s.x <= 100 && s.y >= 0 && s.y <= 100);
            const oob = shotList.filter((s) => s.x < 0 || s.x > 100 || s.y < 0 || s.y > 100);
            const handleSvgClick = (e) => { if (!scoutPending) return; const rect = e.currentTarget.getBoundingClientRect(); const rx = (e.clientX-rect.left)/rect.width*TW, ry = (e.clientY-rect.top)/rect.height*TH; handleCourtTap(null, ((rx-PAD)/W)*100, ((ry-PAD)/H)*100); };
            const COLS = 20, ROWS = 14, cellW = W / COLS, cellH = H / ROWS, RAD = 3.5;
            const heatCells = [];
            if (!interactive && inB.length > 0) {
              const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
              let maxD = 0;
              for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                let d = 0;
                for (const s of inB) { const dist = Math.sqrt(((s.x/100*COLS)-c)**2+((s.y/100*ROWS)-r)**2); if (dist < RAD) d += Math.exp(-(dist*dist)/(RAD*0.7)); }
                grid[r][c] = d; if (d > maxD) maxD = d;
              }
              const hc = (val) => {
                if (maxD === 0) return "transparent";
                const t = val / maxD;
                if (t < 0.05) return "transparent";
                const st = [[0.05,0,0,180,0.3],[0.2,0,100,255,0.45],[0.35,0,200,200,0.55],[0.5,0,220,0,0.65],[0.65,180,220,0,0.7],[0.8,255,180,0,0.8],[1.0,255,40,0,0.9]];
                let lo = st[0], hi = st[st.length-1];
                for (let i = 0; i < st.length-1; i++) { if (t >= st[i][0] && t <= st[i+1][0]) { lo = st[i]; hi = st[i+1]; break; } }
                const f = (t-lo[0])/(hi[0]-lo[0]||1), lerp = (a,b) => Math.round(a+(b-a)*f);
                return `rgba(${lerp(lo[1],hi[1])},${lerp(lo[2],hi[2])},${lerp(lo[3],hi[3])},${(lo[4]+(hi[4]-lo[4])*f).toFixed(2)})`;
              };
              for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { if (grid[r][c] > maxD * 0.05) heatCells.push(<rect key={`h${r}-${c}`} x={PAD+c*cellW} y={PAD+r*cellH} width={cellW+0.5} height={cellH+0.5} fill={hc(grid[r][c])} />); }
            }
            return (
              <div style={{ position: "relative", width: "100%", cursor: interactive && scoutPending ? "crosshair" : "default", userSelect: "none", touchAction: "none", borderRadius: 8, overflow: "hidden" }}
                onClick={interactive ? handleSvgClick : undefined}>
                <svg width="100%" viewBox={`0 0 ${TW} ${TH}`} style={{ display: "block" }}>
                  <rect x="0" y="0" width={TW} height={TH} fill="#0a0a0f" />
                  <rect x={PAD} y={PAD} width={W} height={H} fill="#0d1118" stroke="#2a2a34" strokeWidth="2" />
                  {interactive && scoutPending && <><text x={TW/2} y={PAD/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text><text x={TW/2} y={TH-PAD/2+4} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text><text x={PAD/2} y={TH/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text><text x={TW-PAD/2} y={TH/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text></>}
                  {heatCells}
                  <line x1={PAD} y1={PAD+H*0.33} x2={PAD+W} y2={PAD+H*0.33} stroke={interactive?"#2a2a34":"#ffffff33"} strokeWidth="2" strokeDasharray="8,4" />
                  <line x1={PAD+100} y1={PAD} x2={PAD+100} y2={PAD+H} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  <line x1={PAD+200} y1={PAD} x2={PAD+200} y2={PAD+H} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  <line x1={PAD} y1={PAD+H*0.5} x2={PAD+W} y2={PAD+H*0.5} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  {interactive && inB.map((s, i) => (<circle key={s.id||i} cx={PAD+s.x*W/100} cy={PAD+s.y*H/100} r={5} fill={outcomeColor[s.outcome]||"#999"} opacity={0.9} stroke="#000" strokeWidth="0.5" />))}
                  {interactive && oob.map((s, i) => { const ox = Math.max(3,Math.min(TW-3,PAD+s.x*W/100)), oy = Math.max(3,Math.min(TH-3,PAD+s.y*H/100)); return <circle key={`o${i}`} cx={ox} cy={oy} r={4} fill={outcomeColor[s.outcome]||"#999"} opacity={0.7} stroke="#ef4444" strokeWidth="0.5" />; })}
                  {!interactive && inB.map((s, i) => (<circle key={s.id||i} cx={PAD+s.x*W/100} cy={PAD+s.y*H/100} r={2} fill="#fff" opacity={0.7} />))}
                </svg>
                {interactive && scoutPending && shotList.length === 0 && (<div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%,-50%)", pointerEvents: "none", fontSize: 11, fontWeight: 700, color: "#007bff", opacity: 0.4, letterSpacing: 1, textAlign: "center" }}>TAP EXACT SPOT<br/>BALL LANDED</div>)}
              </div>
            );
          };

          return (
          <div style={S.matchContent}>
            <div style={{ display: "flex", gap: 4, marginBottom: 8 }}>
              <button style={{ ...S.gb, flex: 1, background: scoutView === "input" ? "#007bff" : "#1a1a24", color: scoutView === "input" ? "#000" : "#fff" }} onClick={() => { setScoutView("input"); setScoutPending(null); setScoutOriginFilter(null); }}>+ Log</button>
              <button style={{ ...S.gb, flex: 1, background: scoutView === "heatmap" ? "#007bff" : "#1a1a24", color: scoutView === "heatmap" ? "#000" : "#fff" }} onClick={() => { setScoutView("heatmap"); setScoutPending(null); setScoutOriginFilter(null); }}>Heat Map ({shots.length})</button>
            </div>

            {scoutView === "input" && (
              <div>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 6 }}>
                  {!scoutPending ? "STEP 1: TAP ORIGIN + OUTCOME" : "STEP 2: TAP WHERE BALL LANDED"}
                </div>
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr", gap: 2, background: "#0f1218", borderRadius: "8px", overflow: "hidden", border: "2px solid #2a2a34"}}>
                  {ZONES.map((z) => {
                    const os = originStats[z.id];
                    const isPending = scoutPending?.originZone === z.id;
                    return (
                      <div key={z.id} style={{ background: isPending ? "#0a1929" : "#0d0d14", padding: 4, minHeight: 54, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", opacity: scoutPending ? (isPending ? 1 : 0.25) : 1, position: "relative", border: isPending ? "2px solid #007bff" : "1px solid transparent" }}>
                        <span style={{ fontSize: 8, opacity: 0.3, position: "absolute", top: 2, left: 4 }}>{z.id}</span>
                        <div style={{ display: "flex", gap: 4 }}>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #ef4444", background: isPending && scoutPending.outcome === "kill" ? "#ef4444" : "transparent", color: isPending && scoutPending.outcome === "kill" ? "#000" : "#ef4444", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "kill" })}>K</button>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #007bff", background: isPending && scoutPending.outcome === "dug" ? "#007bff" : "transparent", color: isPending && scoutPending.outcome === "dug" ? "#000" : "#007bff", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "dug" })}>D</button>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #3b82f6", background: isPending && scoutPending.outcome === "error" ? "#3b82f6" : "transparent", color: isPending && scoutPending.outcome === "error" ? "#000" : "#3b82f6", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "error" })}>E</button>
                        </div>
                        {os.total > 0 && !scoutPending && (<div style={{ display: "flex", gap: 3, marginTop: 2, fontSize: 7 }}>{os.kills > 0 && <span style={{ color: "#ef4444" }}>{os.kills}K</span>}{os.dug > 0 && <span style={{ color: "#007bff" }}>{os.dug}D</span>}{os.errors > 0 && <span style={{ color: "#3b82f6" }}>{os.errors}E</span>}</div>)}
                      </div>
                    );
                  })}
                </div>
                <div style={{ background: scoutPending ? "#007bff" : "#2a2a34", textAlign: "center", fontSize: 9, fontWeight: 900, color: scoutPending ? "#000" : "#9ca3af", padding: "4px 0", letterSpacing: 3, margin: "4px 0", borderRadius: 4 }}>
                  {scoutPending ? "\u25bc TAP EXACT LANDING SPOT \u25bc" : "\u2500\u2500\u2500 NET \u2500\u2500\u2500"}
                </div>
                {courtSvg(shots, true)}
                <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 8 }}>
                  <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length} shots</span>
                  <div style={{ display: "flex", gap: 6 }}>
                    {scoutPending && <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} onClick={() => setScoutPending(null)}>Cancel</button>}
                    <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} disabled={shots.length === 0} onClick={undoLastShot}>Undo</button>
                  </div>
                </div>
                <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                </div>
              </div>
            )}

            {scoutView === "heatmap" && (
              <div>
                {shots.length === 0 ? (<div style={{ textAlign: "center", padding: 32, opacity: 0.4 }}>No shots yet.</div>) : (
                  <>
                    <div style={{ fontSize: 10, fontWeight: 700, color: "#9ca3af", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>FILTER BY ATTACK ORIGIN</div>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "auto auto", gap: 2, background: "#0f1218", border: "2px solid #2a2a34", borderRadius: "8px", overflow: "hidden", marginBottom: 4 }}>
                      {ZONES.map((z) => { const os = originStats[z.id]; const isActive = scoutOriginFilter === z.id; return (
                        <button key={z.id} style={{ background: isActive ? "#0a1929" : "#0d0d14", padding: 5, border: "none", color: "#fff", cursor: "pointer", textAlign: "center", borderBottom: isActive ? "2px solid #007bff" : "2px solid transparent" }} onClick={() => setScoutOriginFilter(isActive ? null : z.id)}>
                          <div style={{ fontSize: 8, opacity: 0.4 }}>Z{z.id}</div>
                          {os.total > 0 && <div style={{ fontSize: 10, fontWeight: 700 }}>{os.total} <span style={{ fontSize: 7, opacity: 0.5 }}>({os.kills}K)</span></div>}
                        </button>); })}
                    </div>
                    {scoutOriginFilter !== null && (<button style={{ ...S.gb, background: "#2a2a34", width: "100%", marginBottom: 4, fontSize: 10 }} onClick={() => setScoutOriginFilter(null)}>Zone {scoutOriginFilter} filter &mdash; tap to clear</button>)}
                    <div style={{ background: "#007bff", textAlign: "center", fontSize: 9, fontWeight: 900, color: "#000", padding: "3px 0", letterSpacing: 3, margin: "2px 0", borderRadius: 4 }}>{"\u2500\u2500\u2500"} NET {"\u2500\u2500\u2500"}</div>
                    {courtSvg(filteredShots, false)}
                    <div style={{ ...S.card, marginTop: 8 }}>
                      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, textAlign: "center" }}>
                        <div><div style={{ fontSize: 20, fontWeight: 800 }}>{filteredShots.length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Attacks</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#ef4444" }}>{filteredShots.filter((s) => s.outcome === "kill").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Kills</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#22c55e" }}>{filteredShots.filter((s) => s.outcome === "dug").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Digs</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#3b82f6" }}>{filteredShots.filter((s) => s.outcome === "error").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Errors</div></div>
                      </div>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
          );
        })()}

        {/* ── SUBS TAB ──────────────────────────── */}
        {tab === "subs" && (
          <div style={S.matchContent}>
            <div style={S.card}>
              <h3 style={S.cardTitle}>SUBSTITUTIONS</h3>
              <p style={S.cardSub}>{set?.subCount || 0} subs used this set</p>

              {/* Make a sub */}
              <SubManager
                onCourt={Object.entries(set?.currentLineup || {}).map(([pos, id]) => ({
                  pos: parseInt(pos),
                  player: getPlayerById(id),
                  id,
                }))}
                bench={benchPlayers}
                onSub={(inId, outId) => makeSub(inId, outId)}
              />

              {/* Sub history */}
              {(set?.subs || []).length > 0 && (
                <div style={{ marginTop: 16 }}>
                  <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4 }}>HISTORY</span>
                  {[...(set?.subs || [])].reverse().map((sub, i) => {
                    const inP = getPlayerById(sub.inPlayer);
                    const outP = getPlayerById(sub.outPlayer);
                    return (
                      <div key={i} style={{ padding: "8px 0", borderBottom: "1px solid #1a1a24", fontSize: 13 }}>
                        R{sub.rotation}: {inP?.name?.split(" ")[0]} in → {outP?.name?.split(" ")[0]} out
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    );
  }

  return null;
}

// ── SUB MANAGER COMPONENT ─────────────────────────────
function SubManager({ onCourt, bench, onSub }) {
  const [subOut, setSubOut] = useState(null);
  const [subIn, setSubIn] = useState(null);

  return (
    <div>
      <div style={{ marginTop: 12 }}>
        <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
          PLAYER OUT
        </span>
        <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
          {sortByPosition(onCourt.filter((c) => c.player).map((c) => ({ ...c.player, _courtId: c.id }))).map((p) => (
            <button key={p._courtId} style={{
              ...S.pickerPlayer,
              ...(subOut === p._courtId ? { borderColor: "#ef4444", background: "#1a0a0a" } : {}),
            }}
              onClick={() => setSubOut(p._courtId)}>
              <span style={{ fontWeight: 800 }}>{p.name?.split(" ")[0]}</span>
              <span style={{ fontSize: 9, opacity: 0.5 }}>#{p.number}</span>
            </button>
          ))}
        </div>
      </div>

      {subOut && bench.length > 0 && (
        <div style={{ marginTop: 12 }}>
          <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
            PLAYER IN
          </span>
          <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
            {sortByPosition(bench).map((p) => (
              <button key={p.id} style={{
                ...S.pickerPlayer,
                ...(subIn === p.id ? { borderColor: "#22c55e", background: "#0a1a0a" } : {}),
              }}
                onClick={() => setSubIn(p.id)}>
                <span style={{ fontWeight: 800 }}>{p.name?.split(" ")[0]}</span>
                <span style={{ fontSize: 9, opacity: 0.5 }}>#{p.number}</span>
              </button>
            ))}
          </div>
        </div>
      )}

      {subOut && subIn && (
        <button style={{ ...S.primaryBtn, marginTop: 12, fontSize: 14 }} onClick={() => {
          onSub(subIn, subOut);
          setSubOut(null);
          setSubIn(null);
        }}>
          Confirm Sub
        </button>
      )}
    </div>
  );
}

// ═════════════════════════════════════════════════════
// STYLES
// ═════════════════════════════════════════════════════
const S = {
  container: { minHeight: "100vh", minHeight: "100dvh", height: "100vh", height: "100dvh", background: "#0a0a0f", color: "#e2e8f0", fontFamily: "'SF Pro Display',-apple-system,BlinkMacSystemFont,sans-serif", maxWidth: 480, margin: "0 auto", position: "relative", overflowX: "hidden", overflowY: "auto", WebkitOverflowScrolling: "touch" },
  loading: { textAlign: "center", padding: 48, fontSize: 16, opacity: 0.5 },
  header: { padding: "16px 16px 12px", display: "flex", alignItems: "center", gap: 10, borderBottom: "1px solid #1a1a24" },
  logoRow: { display: "flex", alignItems: "center", gap: 10 },
  logoIcon: { width: 40, height: 40, borderRadius: 10, background: "#111118", display: "flex", alignItems: "center", justifyContent: "center" },
  logoTitle: { fontSize: 22, fontWeight: 800, letterSpacing: 3, margin: 0, color: "#ffffff" },
  logoSub: { fontSize: 10, opacity: 0.5, margin: 0, letterSpacing: 1, color: "#ffffff" },
  headerTitle: { fontSize: 17, fontWeight: 700, margin: 0 },
  pad: { padding: "16px 16px 180px" },
  backBtn: { background: "none", border: "none", color: "#e2e8f0", fontSize: 22, cursor: "pointer", padding: "4px 8px" },
  // Home
  newMatchBtn: { width: "100%", padding: 14, background: "none", border: "2px dashed #2a2a34", borderRadius: 14, color: "#6b7280", fontSize: 14, fontWeight: 700, display: "flex", alignItems: "center", justifyContent: "center", gap: 8, cursor: "pointer" },
  sectionTitle: { fontSize: 11, fontWeight: 700, letterSpacing: 1.5, textTransform: "uppercase", opacity: 0.4, marginBottom: 10 },
  matchCard: { width: "100%", padding: 14, background: "#111118", border: "1px solid #1e1e28", borderRadius: 12, marginBottom: 8, textAlign: "left", cursor: "pointer", color: "#e2e8f0" },
  setScoreBadge: { background: "#1a1a24", padding: "2px 10px", borderRadius: 6, fontSize: 12, fontWeight: 600 },
  clearBtn: { background: "none", border: "1px solid #2a2a34", borderRadius: 8, color: "#6b7280", padding: "8px 16px", fontSize: 12, cursor: "pointer", width: "100%", marginTop: 24 },
  // Teams
  addTeamBtn: { background: "none", border: "1px solid #007bff", borderRadius: 8, color: "#007bff", padding: "5px 12px", fontSize: 12, fontWeight: 700, cursor: "pointer" },
  emptyTeam: { background: "#0d0d14", borderRadius: 12, padding: 24, textAlign: "center", border: "1px dashed #1e1e28" },
  teamCard: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 12, padding: 14, marginBottom: 8 },
  rosterChip: { background: "#1a1a24", padding: "2px 8px", borderRadius: 6, fontSize: 11, fontWeight: 600 },
  teamActionBtn: { padding: "8px 14px", background: "#007bff", border: "none", borderRadius: 8, color: "#fff", fontSize: 12, fontWeight: 700, cursor: "pointer" },
  // Form
  label: { display: "block", fontSize: 11, fontWeight: 700, letterSpacing: 1, textTransform: "uppercase", opacity: 0.4, marginBottom: 4 },
  input: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", padding: "10px 12px", fontSize: 14, outline: "none", width: "100%", boxSizing: "border-box" },
  primaryBtn: { width: "100%", padding: 14, background: "#007bff", border: "none", borderRadius: 12, color: "#ffffff", fontSize: 15, fontWeight: 800, cursor: "pointer" },
  // Lineup
  courtSetup: { background: "#0d0d14", borderRadius: 14, padding: 16, border: "1px solid #1a1a24" },
  netLabel: { textAlign: "center", fontSize: 11, fontWeight: 700, letterSpacing: 3, opacity: 0.3, marginBottom: 8 },
  courtGrid: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 8 },
  courtSlot: { padding: "12px 8px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, position: "relative" },
  courtSlotActive: { borderColor: "#007bff", background: "#0a1525" },
  courtSlotFilled: { background: "#0a1525", borderColor: "#007bff" },
  courtPosLabel: { fontSize: 10, fontWeight: 800, color: "#64748b", position: "absolute", top: 3, left: 6 },
  courtPlayerNum: { fontSize: 18, fontWeight: 800 },
  courtPlayerName: { fontSize: 10, opacity: 0.6, maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" },
  pickerBox: { background: "#0d0d14", borderRadius: 12, padding: 14, border: "1px solid #1e1e28", marginBottom: 12 },
  pickerLabel: { fontSize: 12, fontWeight: 700, opacity: 0.6, display: "block", marginBottom: 8 },
  pickerPlayer: { padding: "10px 14px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, minWidth: 56 },
  optionBtn: { flex: 1, padding: 16, background: "#111118", border: "2px solid #1e1e28", borderRadius: 12, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 6 },
  optionBtnActive: { borderColor: "#007bff", background: "#0a1525" },
  infoCard: { background: "#111118", borderRadius: 12, padding: 16, border: "1px solid #1e1e28", textAlign: "center" },
  // Match
  matchHeader: { display: "flex", alignItems: "center", justifyContent: "space-between", padding: "10px 10px 6px", borderBottom: "1px solid #1a1a24" },
  scoreBoard: { display: "flex", alignItems: "center", gap: 14 },
  teamCol: { display: "flex", flexDirection: "column", alignItems: "center" },
  teamLabel: { fontSize: 9, fontWeight: 700, letterSpacing: 1.5, opacity: 0.5 },
  bigScore: { fontSize: 30, fontWeight: 800, lineHeight: 1 },
  setChip: { background: "#007bff", color: "#ffffff", fontSize: 11, fontWeight: 800, padding: "4px 10px", borderRadius: 16, textAlign: "center", lineHeight: 1.3 },
  undoBtn: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", fontSize: 18, padding: "6px 10px", cursor: "pointer" },
  serveIndicator: { textAlign: "center", padding: "6px 12px", fontSize: 13, fontWeight: 600 },
  tabs: { display: "flex", borderBottom: "1px solid #1a1a24" },
  tab: { flex: 1, padding: "9px 0", background: "none", border: "none", borderBottom: "2px solid transparent", color: "#64748b", fontSize: 12, fontWeight: 700, cursor: "pointer", letterSpacing: 0.5, position: "relative" },
  tabActive: { color: "#007bff", borderBottomColor: "#007bff" },
  badge: { position: "absolute", top: 2, right: "calc(50% - 20px)", background: "#ef4444", color: "#fff", fontSize: 9, fontWeight: 800, padding: "1px 5px", borderRadius: 8 },
  matchContent: { padding: "10px 10px 180px", overflowY: "auto" },
  toast: { position: "fixed", top: 10, left: "50%", transform: "translateX(-50%)", background: "#007bff", color: "#ffffff", padding: "7px 18px", borderRadius: 18, fontSize: 13, fontWeight: 700, zIndex: 999, pointerEvents: "none" },
  // Court
  courtMatch: { background: "#0d0d14", borderRadius: 14, padding: "10px 10px 14px", border: "1px solid #1a1a24", marginBottom: 10 },
  netBar: { textAlign: "center", fontSize: 10, fontWeight: 700, letterSpacing: 3, opacity: 0.3, marginBottom: 6, borderBottom: "2px solid #1e1e28", paddingBottom: 4 },
  courtPlayer: { padding: "8px 4px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", display: "flex", flexDirection: "column", alignItems: "center", gap: 1, position: "relative", cursor: "pointer", minHeight: 60, justifyContent: "center" },
  courtPlayerServing: { borderColor: "#007bff", background: "#0a1525" },
  courtPlayerLibero: { borderColor: "#22c55e", background: "#0a1a0a" },
  courtPlayerPasser: { borderColor: "#22c55e", background: "#0a1a0f" },
  courtPlayerSelected: { borderColor: "#007bff", background: "#0a1525" },
  rallyStartBtn: { width: "100%", padding: 16, background: "#007bff", border: "none", borderRadius: 12, color: "#ffffff", fontSize: 16, fontWeight: 800, cursor: "pointer", marginBottom: 8 },
  theirPointBtn: { width: "100%", padding: 12, background: "none", border: "1px solid #991b1b", borderRadius: 10, color: "#ef4444", fontSize: 13, fontWeight: 700, cursor: "pointer", marginBottom: 12 },
  endSetBtn: { width: "100%", padding: 12, background: "none", border: "2px solid #007bff", borderRadius: 12, color: "#007bff", fontSize: 13, fontWeight: 700, cursor: "pointer", marginTop: 8 },
  // Player list rows
  pRow: { display: "flex", alignItems: "center", gap: 6, padding: "6px 8px", background: "#0d0d14", borderRadius: 8, marginBottom: 4, borderLeft: "3px solid #1e1e28" },
  pId: { minWidth: 62, flexShrink: 0 },
  pName: { fontSize: 13, fontWeight: 700 },
  pBtns: { display: "flex", gap: 3, flexWrap: "wrap", flex: 1, justifyContent: "flex-end" },
  ib: { padding: "6px 8px", border: "none", borderRadius: 6, color: "#fff", cursor: "pointer", fontWeight: 800, fontSize: 11, minWidth: 34, textAlign: "center" },
  mSt: { fontSize: 8, color: "#9ca3af", fontWeight: 700 },
  rowDivider: { fontSize: 9, color: "#4b5563", textAlign: "center", letterSpacing: 2, fontWeight: 700, margin: "6px 0 4px", opacity: 0.6 },
  gb: { padding: "8px 4px", border: "none", borderRadius: 6, color: "#fff", cursor: "pointer", fontWeight: 700, fontSize: 11, textAlign: "center", background: "#065f46" },
  // Overlay + popup
  overlay: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.7)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 100 },
  popup: { background: "#15151f", borderRadius: 16, padding: 20, maxWidth: 320, width: "90%", border: "1px solid #007bff" },
  // Stats table
  statsTable: { width: "100%", borderCollapse: "collapse", fontSize: 11 },
  sth: { padding: "4px 3px", textAlign: "center", color: "#9ca3af", fontWeight: 700, fontSize: 9, letterSpacing: 1, borderBottom: "1px solid #1e1e28" },
  std: { padding: "5px 3px", textAlign: "center", color: "#d1d5db", fontSize: 11, borderBottom: "1px solid #1a1a24" },
  // Phases
  phaseBox: { background: "#0d0d14", borderRadius: 14, padding: 16, border: "1px solid #1a1a24" },
  phaseTitle: { fontSize: 14, fontWeight: 800, letterSpacing: 1.5, color: "#007bff", margin: "0 0 4px", textAlign: "center" },
  phaseDesc: { fontSize: 12, opacity: 0.5, textAlign: "center", margin: "0 0 12px" },
  phaseGrid: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8 },
  phaseBtnLg: { padding: 20, border: "none", borderRadius: 12, color: "#fff", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 4 },
  passRow: { display: "flex", gap: 8, justifyContent: "center" },
  passBtn: { padding: "12px 16px", border: "none", borderRadius: 10, color: "#fff", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, flex: 1 },
  cancelBtn: { width: "100%", padding: 10, background: "none", border: "1px solid #2a2a34", borderRadius: 8, color: "#6b7280", fontSize: 12, cursor: "pointer", marginTop: 12 },
  rallyBtn: { padding: 14, border: "none", borderRadius: 10, color: "#fff", cursor: "pointer", fontWeight: 800, fontSize: 13, letterSpacing: 0.5 },
  // Cards
  card: { background: "#111118", borderRadius: 14, padding: 16, marginBottom: 10, border: "1px solid #1e1e28" },
  cardTitle: { fontSize: 12, fontWeight: 800, letterSpacing: 2, color: "#007bff", margin: "0 0 4px" },
  cardSub: { fontSize: 11, opacity: 0.4, margin: "0 0 14px" },
  formulaRow: { display: "flex", alignItems: "center", gap: 10, marginBottom: 10 },
  progressBg: { flex: 1, height: 7, background: "#1a1a24", borderRadius: 4, overflow: "hidden" },
  progressFill: { height: "100%", borderRadius: 4, transition: "width 0.3s" },
  remainingBox: { display: "flex", flexDirection: "column", alignItems: "center", padding: "14px 0 4px", borderTop: "1px solid #1a1a24", marginTop: 8 },
  statCol: { display: "flex", flexDirection: "column", alignItems: "center" },
  insightBox: { background: "#1a1a24", borderRadius: 10, padding: 12, marginTop: 12, borderLeft: "3px solid #007bff" },
  insightLabel: { fontSize: 9, fontWeight: 800, letterSpacing: 2, color: "#007bff", display: "block", marginBottom: 4 },
  insightText: { fontSize: 12, margin: 0, lineHeight: 1.5, opacity: 0.8 },
  setHistoryRow: { padding: "8px 0", borderBottom: "1px solid #1a1a24" },
  // Correlation
  corrLabel: { fontSize: 11, fontWeight: 700, letterSpacing: 1, opacity: 0.5, display: "block" },
  corrCol: { display: "flex", flexDirection: "column", alignItems: "center", flex: 1 },
};

ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(VolleyballStats));
</script>
</body>
</html>
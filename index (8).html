<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#0a0a0f">
<title>Formula by PRV8</title>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABAGlDQ1BpY2MAABiVY2BgPMEABCwGDAy5eSVFQe5OChGRUQrsDxgYgRAMEpOLCxhwA6Cqb9cgai/r4lGHC3CmpBYnA+kPQKxSBLQcaKQIkC2SDmFrgNhJELYNiF1eUlACZAeA2EUhQc5AdgqQrZGOxE5CYicXFIHU9wDZNrk5pckIdzPwpOaFBgNpDiCWYShmCGJwZ3AC+R+iJH8RA4PFVwYG5gkIsaSZDAzbWxkYJG4hxFQWMDDwtzAwbDuPEEOESUFiUSJYiAWImdLSGBg+LWdg4I1kYBC+wMDAFQ0LCBxuUwC7zZ0hHwjTGXIYUoEingx5DMkMekCWEYMBgyGDGQCm1j8/yRb+6wAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACAVBMVEUAAAAAAQIAAAIAAAECNG0BWr0BVbIBVbEBVK8BVK4BU60BUqwBUqoBUakBUagBUKYAT6UBT6QBTqMBTaEATaAATJ8BS5wBKlgBCBEBcesAe/8Ad/gAd/cAdvUAdfQAdPIAc/AAcu4AcewAcesAcOkAb+cAbuUAbeMAbOEAa+AAat4AadwAaNkAat0BX8YABg0Ba98Ac+8AbOIAatwAadoAZ9cAZtUAZdMAZNEAZNAAY84AYswAYckABw8FNm4DWrkCVa4CVa8CVK0CU6wCU6sCUqkCUagCUaYCUKUCT6QDT6MDT6EAS50AS5wASpoBSZkBSZgAR5UASpsBLV4BAQF0dXbGx8e8vb2+vr++vr69vb3ExMRPT1ACAgISEhLu7u7////9/f38/PzMzMzPz895eXnS0tLHx8fJycnQ0NBfX18DAwNjY2OkpKSbm5udnZ2enp6cnJyampqioqJvb28PDw/X19fT09PU1NTW1tYlJSUODg7FxcXY2NgmJiZcXFyjo6OhoaF0dHRFRUVwcHBra2tsbGw+Pj4KCgqFhYWPj4+MjIyCgoIICAgJCQmDg4OQkJCNjY0HBwc7OztqampkZGRlZWVmZmYtLS1ISEhERERGRkY/Pz8GBgZTU1NZWVlXV1dWVlZeXl4FBQVRUVFaWlpYWFgjIyNAQEA9PT04ODgZWfA5AAAAAWJLR0Rgxbd8EAAAAAd0SU1FB+oCFAgaEH05uusAAAFbSURBVDjLY2CgDmBEA0xMTMyMjMTrZ2ZgYWVjY+fg5OLm4eXjFxAUEhYRFRMSB0pA5SUkpaRlZOXkFRSVlFVU1dQ1NLW0dXT19OEGSBgYqgLFjTS1jE10TM3MLSytrG2sWW0RVtjZOzg6Obu4url7eHp5+/j6+QcEBgUT78gQhtCw8AgIiIyKjmGIhRoMl4+LT0hMgIKkhGRMA1AVpGCxIjUtPQMK0jOzGLJDQmJJiokQhpzcvHw4KCgsLCouQZEvTS8rr4CDchCorAKKw0F1TW0akiQIlNUhKQhhqG/IK4SAfDBZ1NgUQrwTQaC5pbUNBFpb2hliQ0AA1ZsdnV3dENDV04vNgL7+CRPBoHtCzySsVkyeMnXatGnTp0+dMpk0t8HBjJmzmptnz+lgCMHuu7nz5i9YsGDhIpTQQwaLlyxdtmzZgiycChiWr1i5cmX7ql4GCgGJwU8sAABLz4GFC/yJSAAAAB50RVh0aWNjOmNvcHlyaWdodABHb29nbGUgSW5jLiAyMDE2rAszOAAAABR0RVh0aWNjOmRlc2NyaXB0aW9uAHNSR0K6kHMHAAAAAElFTkSuQmCC">
<link rel="apple-touch-icon" sizes="180x180" href="data:image/png;base64,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k20h9Xr91q1bn3/++ccffzw/Px9Kn3k4pO89duzY7OwsEQkhqP0RQvi+T0RXr159/PHHAcCyjM80tJb8PYdsUi+//PInn3wiDWpZVrtHoxIpkVKpNDU19fzzz3/33XcYbGVmlkeKYGRkZHp6mog8z5MGlbS68a/KbYRFqNfrRDQ2NlYul1ttb7Pk7Bilp33zzTcHBgZc17Vtm4gwoNWF/e2ERSCiUqnkuu6+ffteffVVCPrQjiRncfi+DwAHDhwAAMuypDJaXcacISLZBo4ePQoAHRyW5h9SrVu3buvWrRC0tlYXMGdkieT/H3300d7e3g6OOfIUhzSZ4zid3RmHiq9UKnJ83nltQGJkMNbBjWlNYUQcndqS1hodPo3DrAbuVphM8hdHRw5S1iZ5ikM6jHq9vri4qL7TqdTrdTmv06nk7DkQcW5u7tq1a9C5ypAT6gDwyy+/zM7OdnBJjUyff/bZZwAghOi8dSk55ytnRb/66ivo6OlzI5TL5W+++SZco2r3VTd17Y2C1cTp6enh4WHo6HG7qSX7xx577OzZs4ODg67rdtiSvW3blmUdP378xIkTvOXnoZGdy549e65evUpEvu93gOegYNfSzMzMSy+9BGugQzG7TbCnp+eNN944evToI4880u7bBD3Pu3379pkzZz766KPx8fG14DPMbjCWDQ4A+vr6yuUytW1wioiu687NzckirAVlNAPbtjsj4OjI4jwYPtS0UtrX7TEMwzBM57PWDpf+ZoppqCadle3p6enUzeirQRrE9/35+XkIYvbiRL6mqkoqY2ho6MiRI6Ojoxs3bixgyygIvu/fvn37yy+/PH369OLiYnFWK42IQyrj0KFD77777qZNm2q1mlysanVhCwoiOo7T1dV15cqVt99++/r16wWZZDO18PbCCy988MEHi4uLS0tL0mdwh5JFuHDT398/NTX12muv3bhxowj+I+cKk0XavHnzqVOnqtVqvV4PT0S2tpxFRopAztD39/dfuXLl+PHjnpf/78Q+LEY2+xw5cmTTpk3SZ7AylkU9hTszM/PUU08dPnwYCvAVD0bOyu7fv5+V8bBIfViW5bruoUOHoADDlvy12dvbOzg4KFXCynhYZOeybdu2arXageKwbZt9xm9G+g/HcYqw/SV/cbRc751BEczIxyGZTFgcTCYsDiYTI2dlW10oJh/yF4fneZ7nyai7CFFVGyGNJtdpi3AKN/+zsvPz8+Pj4239ZdatQlrMtu3JyUm5iN9a8hcHAJw5c6ZcLnfkWVlzhD6jUqlcuHABCnBoKmdxyIXm06dPX7x4sb+/33Vd7l9WgqqMu3fvfvHFF1CAL7HMX5vyEPq333574MCBgYGBhYWF1paw+MiW43leV1dXd3f3O++8c+nSJblxrrUZM/S7skhEu3btev/99/fu3cubfR6M3EAqfcZ777135syZjt3sExaYiLq7uw8fPnzw4MHNmzc7jtPqwhYU3/cnJyfPnTt38uTJiYmJgigDjG4wVrfLVqtVx3F4NU4jDDUWFhbW4incNXW4dDWwoRiGYRiGYczQ8i3UbZ291mJ2KBueyOjq6irClJ+aN9/3a7WallVGxexZ2fXr14+Oju7evbuvr69obdT3/Xv37l2+fPnrr7+u1+usjyQGp8+ffPLJF198US6/FWF3QhLbtkul0k8//XTixIk7d+6wPjTyF0eojFdeeaVer8uF2WJO78gTqtVqdW5u7sMPP5yYmGB9qBjZMbB+/frXX38dET3PC09RFxAAsG27Xq/39vZu27ZtbGxsDU1drwAjZ2VHR0fXrVsnv9i6yOsp0k/Ytr2wsLBjx45nnnkGeA+sgpHNPrt37w63kRbc1mEmPc974oknoBiniQpC/iOISqXS19fn+35hQ40kUhwbNmzo7B89fVjyF4dlWUUbtT6YUMGO47R822ahaKdaNA3vddVgcUS0UT/YHFgcTCYsjhjcraiwOCKKP/BuMvmLQz3n2RYNMcyk/Im/VmenQOR/HLJWq01PT8u95q0u3UqR86Szs7PhIj4DhrqVS5cuhV8LVnCJhJkslUryt5Lba5LGKDkbQkphbGzs5s2b3d3dcp60sPqg4BeE5ReAnj9/HgpwQrU4mDore/Pmzb179/b09NRqtcJGeXLJvlQqlcvlTz/99NatW4XNakswuNlnaGjo2LFjIyMj8utcWl3SFORmn5mZmVOnTl2+fLnITq4lmD0rWy6Xn3322T179gwMDBStLxdCzM7OXrt27fz58/fu3WNlJGnGBmMA6OrqKtqaFm8wbj1FcxjtlT2GYRiGYRhm1TRhWolnrgzRJLOa2J4pd/W5rtucIqxBjH9h3K5du4aGhiqViolBoxBiYWFhfHz8xo0bxTxx2dYYnD4fHh7et2+fXH4zt5plWZZt29PT0+fOnZuZmTFoqrWHKc8xMjLy3HPPyY0/pmMCOU+/tLR09uxZ1keOGJkfrFarTz/9tFSG7E2Mnne1LKter1cqlf379/OMZ44Y+WL8nTt3yt6kCWdlMfjFzXq9Pjg4uH37duDxS04Y2ewzNDQUbvNpzlA23LYzPDwMbbJ3tfjk74RLpVKlUpERaNNasHyQ7/u9vb38Pdp5YeRnvFro1dvupG6RYTsymbA4mExYHEwmLA4mExYHk0n+4lC/AqX58w183jVH8heH67pzc3NN3mse/szR0tJSMc/ItCNGps/Hx8fDifMmOI/wQbZtT0xMAE+f54SR6fMff/xxcnKyOb87HE6c27a9uLj4ww8/AE+f54Qp5z81NbV169ZKpSK/kNRoGaTPcBznwoULU1NTRp+1pjBYbf39/aOjoxs2bGjCZp+FhYWLFy/+/PPP5oqzBjHbph3H2b59+/DwcLVaNeE/iGhpaenOnTs3btzgn77OneZtMM79x3hkqMFjkzaGjyYwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwTCfz/7hZpdzIoykYAAAAHnRFWHRpY2M6Y29weXJpZ2h0AEdvb2dsZSBJbmMuIDIwMTasCzM4AAAAFHRFWHRpY2M6ZGVzY3JpcHRpb24Ac1JHQrqQcwcAAAAASUVORK5CYII=">
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
  html, body { height: 100%; overflow: hidden; background: #0a0a0f; -webkit-overflow-scrolling: touch; }
  #root { width: 100%; height: 100%; }
  input, select, button { font-family: inherit; }
</style>
</head>
<body>
<div id="root"></div>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
<script>
  firebase.initializeApp({
    apiKey: "AIzaSyCmVcH8BMH637D-YTPJpr7Ziph9aqDMzgI",
    authDomain: "formula-e8bc3.firebaseapp.com",
    databaseURL: "https://formula-e8bc3-default-rtdb.firebaseio.com",
    projectId: "formula-e8bc3",
    storageBucket: "formula-e8bc3.firebasestorage.app",
    messagingSenderId: "631822291876",
    appId: "1:631822291876:web:0903a57e9b1606228e6731"
  });
  const fbDb = firebase.database();
</script>
<script type="text/babel">
const { useState, useEffect, useCallback, useRef } = React;

// ── CONSTANTS ──────────────────────────────────────────
const POSITIONS = ["OH", "MB", "S", "OPP", "L", "DS"];

// ── BRAND ASSETS ────────────────────────────────────────
const LOGO_FULL = "data:image/png;base64,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";
const LOGO_ICON = "data:image/png;base64,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k20h9Xr91q1bn3/++ccffzw/Px9Kn3k4pO89duzY7OwsEQkhqP0RQvi+T0RXr159/PHHAcCyjM80tJb8PYdsUi+//PInn3wiDWpZVrtHoxIpkVKpNDU19fzzz3/33XcYbGVmlkeKYGRkZHp6mog8z5MGlbS68a/KbYRFqNfrRDQ2NlYul1ttb7Pk7Bilp33zzTcHBgZc17Vtm4gwoNWF/e2ERSCiUqnkuu6+ffteffVVCPrQjiRncfi+DwAHDhwAAMuypDJaXcacISLZBo4ePQoAHRyW5h9SrVu3buvWrRC0tlYXMGdkieT/H3300d7e3g6OOfIUhzSZ4zid3RmHiq9UKnJ83nltQGJkMNbBjWlNYUQcndqS1hodPo3DrAbuVphM8hdHRw5S1iZ5ikM6jHq9vri4qL7TqdTrdTmv06nk7DkQcW5u7tq1a9C5ypAT6gDwyy+/zM7OdnBJjUyff/bZZwAghOi8dSk55ytnRb/66ivo6OlzI5TL5W+++SZco2r3VTd17Y2C1cTp6enh4WHo6HG7qSX7xx577OzZs4ODg67rdtiSvW3blmUdP378xIkTvOXnoZGdy549e65evUpEvu93gOegYNfSzMzMSy+9BGugQzG7TbCnp+eNN944evToI4880u7bBD3Pu3379pkzZz766KPx8fG14DPMbjCWDQ4A+vr6yuUytW1wioiu687NzckirAVlNAPbtjsj4OjI4jwYPtS0UtrX7TEMwzBM57PWDpf+ZoppqCadle3p6enUzeirQRrE9/35+XkIYvbiRL6mqkoqY2ho6MiRI6Ojoxs3bixgyygIvu/fvn37yy+/PH369OLiYnFWK42IQyrj0KFD77777qZNm2q1mlysanVhCwoiOo7T1dV15cqVt99++/r16wWZZDO18PbCCy988MEHi4uLS0tL0mdwh5JFuHDT398/NTX12muv3bhxowj+I+cKk0XavHnzqVOnqtVqvV4PT0S2tpxFRopAztD39/dfuXLl+PHjnpf/78Q+LEY2+xw5cmTTpk3SZ7AylkU9hTszM/PUU08dPnwYCvAVD0bOyu7fv5+V8bBIfViW5bruoUOHoADDlvy12dvbOzg4KFXCynhYZOeybdu2arXageKwbZt9xm9G+g/HcYqw/SV/cbRc751BEczIxyGZTFgcTCYsDiYTI2dlW10oJh/yF4fneZ7nyai7CFFVGyGNJtdpi3AKN/+zsvPz8+Pj4239ZdatQlrMtu3JyUm5iN9a8hcHAJw5c6ZcLnfkWVlzhD6jUqlcuHABCnBoKmdxyIXm06dPX7x4sb+/33Vd7l9WgqqMu3fvfvHFF1CAL7HMX5vyEPq333574MCBgYGBhYWF1paw+MiW43leV1dXd3f3O++8c+nSJblxrrUZM/S7skhEu3btev/99/fu3cubfR6M3EAqfcZ777135syZjt3sExaYiLq7uw8fPnzw4MHNmzc7jtPqwhYU3/cnJyfPnTt38uTJiYmJgigDjG4wVrfLVqtVx3F4NU4jDDUWFhbW4incNXW4dDWwoRiGYRiGYczQ8i3UbZ291mJ2KBueyOjq6irClJ+aN9/3a7WallVGxexZ2fXr14+Oju7evbuvr69obdT3/Xv37l2+fPnrr7+u1+usjyQGp8+ffPLJF198US6/FWF3QhLbtkul0k8//XTixIk7d+6wPjTyF0eojFdeeaVer8uF2WJO78gTqtVqdW5u7sMPP5yYmGB9qBjZMbB+/frXX38dET3PC09RFxAAsG27Xq/39vZu27ZtbGxsDU1drwAjZ2VHR0fXrVsnv9i6yOsp0k/Ytr2wsLBjx45nnnkGeA+sgpHNPrt37w63kRbc1mEmPc974oknoBiniQpC/iOISqXS19fn+35hQ40kUhwbNmzo7B89fVjyF4dlWUUbtT6YUMGO47R822ahaKdaNA3vddVgcUS0UT/YHFgcTCYsjhjcraiwOCKKP/BuMvmLQz3n2RYNMcyk/Im/VmenQOR/HLJWq01PT8u95q0u3UqR86Szs7PhIj4DhrqVS5cuhV8LVnCJhJkslUryt5Lba5LGKDkbQkphbGzs5s2b3d3dcp60sPqg4BeE5ReAnj9/HgpwQrU4mDore/Pmzb179/b09NRqtcJGeXLJvlQqlcvlTz/99NatW4XNakswuNlnaGjo2LFjIyMj8utcWl3SFORmn5mZmVOnTl2+fLnITq4lmD0rWy6Xn3322T179gwMDBStLxdCzM7OXrt27fz58/fu3WNlJGnGBmMA6OrqKtqaFm8wbj1FcxjtlT2GYRiGYRhm1TRhWolnrgzRJLOa2J4pd/W5rtucIqxBjH9h3K5du4aGhiqViolBoxBiYWFhfHz8xo0bxTxx2dYYnD4fHh7et2+fXH4zt5plWZZt29PT0+fOnZuZmTFoqrWHKc8xMjLy3HPPyY0/pmMCOU+/tLR09uxZ1keOGJkfrFarTz/9tFSG7E2Mnne1LKter1cqlf379/OMZ44Y+WL8nTt3yt6kCWdlMfjFzXq9Pjg4uH37duDxS04Y2ewzNDQUbvNpzlA23LYzPDwMbbJ3tfjk74RLpVKlUpERaNNasHyQ7/u9vb38Pdp5YeRnvFro1dvupG6RYTsymbA4mExYHEwmLA4mExYHk0n+4lC/AqX58w183jVH8heH67pzc3NN3mse/szR0tJSMc/ItCNGps/Hx8fDifMmOI/wQbZtT0xMAE+f54SR6fMff/xxcnKyOb87HE6c27a9uLj4ww8/AE+f54Qp5z81NbV169ZKpSK/kNRoGaTPcBznwoULU1NTRp+1pjBYbf39/aOjoxs2bGjCZp+FhYWLFy/+/PPP5oqzBjHbph3H2b59+/DwcLVaNeE/iGhpaenOnTs3btzgn77OneZtMM79x3hkqMFjkzaGjyYwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwDMMwTCfz/7hZpdzIoykYAAAAHnRFWHRpY2M6Y29weXJpZ2h0AEdvb2dsZSBJbmMuIDIwMTasCzM4AAAAFHRFWHRpY2M6ZGVzY3JpcHRpb24Ac1JHQrqQcwcAAAAASUVORK5CYII=";

// ── WINNING FORMULA ENGINE ──────────────────────────────
// 10 computed variables derived from 14 raw event types
const FORMULA_VARIABLES = [
  { name: "hitting_eff", displayName: "Hitting Efficiency", domain: "Offense", unit: "ratio", format: (v) => { const r = Math.round(v*1000); return (r >= 0 ? "." : "-.") + Math.abs(r).toString().padStart(3,"0"); } },
  { name: "kill_rate", displayName: "Kill Rate", domain: "Offense", unit: "ratio", format: (v) => "." + Math.max(0, Math.round(v*1000)).toString().padStart(3,"0") },
  { name: "serve_pressure", displayName: "Serve Pressure", domain: "Serving", unit: "score", format: (v) => (v||0).toFixed(2) },
  { name: "ace_error_ratio", displayName: "Ace-to-Error Ratio", domain: "Serving", unit: "ratio", format: (v) => (v||0).toFixed(1) },
  { name: "reception_eff", displayName: "Pass Efficiency", domain: "Passing", unit: "score", format: (v) => (v||0).toFixed(2) },
  { name: "reception_error_rate", displayName: "Pass Error Rate", domain: "Passing", unit: "ratio", format: (v) => "." + Math.max(0, Math.round((v||0)*1000)).toString().padStart(3,"0") },
  { name: "stuff_block_rate", displayName: "Stuff Blocks/Set", domain: "Blocking", unit: "count", format: (v) => (v||0).toFixed(1) },
  { name: "block_touch_rate", displayName: "Block Touches/Set", domain: "Blocking", unit: "count", format: (v) => (v||0).toFixed(1) },
  { name: "dig_rate", displayName: "Digs/Set", domain: "Defense", unit: "count", format: (v) => (v||0).toFixed(1) },
  { name: "cover_rate", displayName: "Covers/Set", domain: "Cover", unit: "count", format: (v) => (v||0).toFixed(1) },
];

// Serve-in tier weights (forcedPass 1=best, 3=weakest)
const SERVE_TIER_WEIGHTS = { 1: 0.40, 2: 0.15, 3: -0.05 };
// Reception quality weights (3=perfect, 0=error)
const RECEPTION_TIER_WEIGHTS = { 3: 0.35, 2: 0.15, 1: -0.15, 0: 0.0 };

// Compute 10 formula variables from a set's events
const computeFormulaRow = (set) => {
  let kills = 0, attErr = 0, attBlk = 0, aces = 0, sErr = 0, sInW = 0;
  let totalServes = 0, totalRec = 0, recW = 0, recErr = 0;
  let stuffBlk = 0, blkTouch = 0, digs = 0, covers = 0;
  for (const ev of (set.events || [])) {
    switch (ev.stat) {
      case "kill": kills++; break;
      case "attack_error": attErr++; break;
      case "attack_blocked": attBlk++; break;
      case "ace": aces++; totalServes++; break;
      case "serve_error": sErr++; totalServes++; break;
      case "serve_in": totalServes++; sInW += (SERVE_TIER_WEIGHTS[ev.forcedPass] || 0); break;
      case "reception": totalRec++; recW += (RECEPTION_TIER_WEIGHTS[ev.quality] ?? 0); break;
      case "reception_error": recErr++; break;
      case "stuff_block": stuffBlk++; break;
      case "block": blkTouch++; break;
      case "dig": digs++; break;
      case "cvr": covers++; break;
    }
  }
  const totalAtt = kills + attErr + attBlk;
  return {
    hitting_eff: totalAtt > 0 ? (kills - attErr - attBlk) / totalAtt : 0,
    kill_rate: totalAtt > 0 ? kills / totalAtt : 0,
    serve_pressure: totalServes > 0 ? (aces + sInW - sErr) / totalServes : 0,
    ace_error_ratio: aces / Math.max(sErr, 1),
    reception_eff: recW / Math.max(totalRec, 1),
    reception_error_rate: recErr / Math.max(totalRec, 1),
    stuff_block_rate: stuffBlk,
    block_touch_rate: blkTouch,
    dig_rate: digs,
    cover_rate: covers,
  };
};

// ── Logistic regression engine ─────────────────────────
const _sigmoid = (x) => 1 / (1 + Math.exp(-Math.max(-500, Math.min(500, x))));
const _dot = (a, b) => a.reduce((s, v, i) => s + v * b[i], 0);

const _standardize = (rows) => {
  const n = rows.length, p = rows[0].length;
  const means = new Array(p).fill(0), stds = new Array(p).fill(0);
  for (let j = 0; j < p; j++) {
    let s = 0; for (let i = 0; i < n; i++) s += rows[i][j]; means[j] = s / n;
    let sq = 0; for (let i = 0; i < n; i++) sq += (rows[i][j] - means[j]) ** 2;
    stds[j] = Math.sqrt(sq / n) || 1;
  }
  return { data: rows.map(r => r.map((v, j) => (v - means[j]) / stds[j])), means, stds };
};

const _fitElasticNet = (X, y, lambda = 0.1, alpha = 0.5, maxIter = 200) => {
  const n = X.length, p = X[0].length;
  const beta = new Array(p).fill(0);
  let b0 = 0;
  for (let iter = 0; iter < maxIter; iter++) {
    let maxD = 0;
    const probs = X.map((xi, i) => _sigmoid(b0 + _dot(xi, beta)));
    const db0 = y.reduce((s, yi, i) => s + (yi - probs[i]), 0) / n;
    b0 += db0; maxD = Math.max(maxD, Math.abs(db0));
    for (let j = 0; j < p; j++) {
      const p2 = X.map((xi, i) => _sigmoid(b0 + _dot(xi, beta)));
      let grad = 0, hess = 0;
      for (let i = 0; i < n; i++) {
        grad += X[i][j] * (y[i] - p2[i]);
        hess += X[i][j] ** 2 * p2[i] * (1 - p2[i] + 1e-8);
      }
      grad /= n; hess /= n;
      const l1 = alpha * lambda, l2 = (1 - alpha) * lambda;
      const denom = hess + l2;
      const z = beta[j] + grad / denom;
      const old = beta[j];
      const thr = l1 / denom;
      beta[j] = z > thr ? z - thr : z < -thr ? z + thr : 0;
      maxD = Math.max(maxD, Math.abs(beta[j] - old));
    }
    if (maxD < 1e-5) break;
  }
  return { beta, intercept: b0 };
};

// Leave-one-out cross-validation for lambda selection (spec requirement)
const _cvSelectLambda = (X, y, alpha = 0.5) => {
  const lambdas = [0.001, 0.01, 0.05, 0.1, 0.3, 0.5, 1.0];
  const n = X.length;
  let bestLambda = 0.1, bestAcc = 0;
  for (const lam of lambdas) {
    let correct = 0;
    for (let i = 0; i < n; i++) {
      const Xt = X.filter((_, j) => j !== i);
      const yt = y.filter((_, j) => j !== i);
      if (Xt.length < 3) continue;
      const model = _fitElasticNet(Xt, yt, lam, alpha, 100);
      const pred = _sigmoid(model.intercept + _dot(X[i], model.beta));
      if ((pred >= 0.5 && y[i] === 1) || (pred < 0.5 && y[i] === 0)) correct++;
    }
    const acc = correct / n;
    if (acc > bestAcc) { bestAcc = acc; bestLambda = lam; }
  }
  return { lambda: bestLambda, accuracy: bestAcc };
};

// ROC + Youden threshold for a single variable
const _computeThreshold = (values, outcomes) => {
  const n = values.length;
  const sorted = values.map((v, i) => ({ v, o: outcomes[i] })).sort((a, b) => a.v - b.v);
  const totalP = outcomes.filter(o => o === 1).length;
  const totalN = n - totalP;
  if (totalP === 0 || totalN === 0) return { auc: 0.5, threshold: null, winAbove: null, winBelow: null };
  // Sweep thresholds, compute TPR/FPR
  let tp = totalP, fp = totalN; // everything predicted positive initially
  const points = [{ tpr: 1, fpr: 1, thr: sorted[0].v - 1 }];
  for (let i = 0; i < n; i++) {
    if (sorted[i].o === 1) tp--; else fp--;
    const tpr = tp / totalP, fpr = fp / totalN;
    points.push({ tpr, fpr, thr: sorted[i].v });
  }
  // AUC via trapezoidal rule
  let auc = 0;
  for (let i = 1; i < points.length; i++) {
    auc += (points[i - 1].fpr - points[i].fpr) * (points[i - 1].tpr + points[i].tpr) / 2;
  }
  if (auc < 0.55) return { auc, threshold: null, winAbove: null, winBelow: null };
  // Youden index: max(TPR - FPR)
  let bestJ = -1, bestThr = null;
  for (const p of points) {
    const j = p.tpr - p.fpr;
    if (j > bestJ) { bestJ = j; bestThr = p.thr; }
  }
  // Win rates above/below threshold
  const above = sorted.filter(s => s.v > bestThr);
  const below = sorted.filter(s => s.v <= bestThr);
  const winAbove = above.length > 0 ? Math.round(above.filter(s => s.o === 1).length / above.length * 100) : null;
  const winBelow = below.length > 0 ? Math.round(below.filter(s => s.o === 1).length / below.length * 100) : null;
  return { auc, threshold: bestThr, winAbove, winBelow };
};

// Generate team narrative from top weighted variables (spec language patterns)
const _generateNarrative = (variables, tier) => {
  const significant = variables.filter(v => v.priorityZone !== "low_relationship");
  if (significant.length === 0) return "Your Winning Formula is still developing patterns.";
  // Sort by absolute coefficient to find top contributors
  const byWeight = [...significant].sort((a, b) => Math.abs(b.coefficient) - Math.abs(a.coefficient));
  const top = byWeight.slice(0, 3);
  const domains = [...new Set(top.map(v => v.domain))];

  // Single-domain narratives per spec
  if (domains.length === 1) {
    const d = domains[0];
    if (d === "Defense" || d === "Cover") return "Your team wins by extending rallies and outlasting opponents defensively.";
    if (d === "Offense") return "Your team wins through offensive firepower and attack termination.";
    if (d === "Serving") return "Your team wins by disrupting opponents from the service line and capitalizing on pressure.";
    if (d === "Passing") return "Your team wins when passing fuels an efficient offensive system.";
    if (d === "Blocking") return "Your team wins through dominant net presence and blocking.";
  }

  // Cross-domain narratives per spec
  const domainPhrases = {
    Offense: "efficient attacking",
    Serving: "serve pressure",
    Passing: "passing efficiency",
    Blocking: "net presence",
    Defense: "defensive resilience",
    Cover: "strong coverage in transition",
  };
  return "Your team wins through " + domains.slice(0, 2).map(d => domainPhrases[d] || d.toLowerCase()).join(" and ") + ".";
};

// Full Winning Formula pipeline
const computeWinningFormula = (setRows) => {
  // setRows: [{ set, won }] — set objects with events + outcome
  const n = setRows.length;
  const totalSets = n;
  const wonCount = setRows.filter(r => r.won).length;
  const lostCount = n - wonCount;

  // Confidence tiers
  let tier = "building";
  if (n >= 26) tier = "established";
  else if (n >= 8) tier = "developing";

  if (n < 8 || wonCount === 0 || lostCount === 0) {
    return {
      hasEnoughData: false,
      tier,
      totalSets,
      wonSets: wonCount,
      lostSets: lostCount,
      variables: [],
      narrative: "",
      formulaStrength: 0,
      predictedWinProb: 0,
      headline: null,
    };
  }

  // Step 1: Compute 10 variables for each set
  const rawRows = setRows.map(r => computeFormulaRow(r.set));
  const outcomes = setRows.map(r => r.won ? 1 : 0);
  const varNames = FORMULA_VARIABLES.map(v => v.name);
  const matrix = rawRows.map(r => varNames.map(name => r[name]));

  // Step 2: Standardize
  const { data: Xstd, means, stds } = _standardize(matrix);

  // Step 3: Fit elastic net with CV lambda selection
  const { lambda: bestLambda, accuracy: cvAccuracy } = _cvSelectLambda(Xstd, outcomes);
  const model = _fitElasticNet(Xstd, outcomes, bestLambda, 0.5);

  // Step 4: Predicted win probability at current averages (mean = 0 in standardized space)
  const predAtMean = _sigmoid(model.intercept);

  // Step 5: Sensitivity per variable (marginal effect in real units)
  const pBase = predAtMean;
  const logisticSlope = pBase * (1 - pBase);

  // Step 6: Per-variable analysis
  const last10 = rawRows.slice(-Math.min(10, n));
  const last5 = rawRows.slice(-Math.min(5, n));
  const prev5 = n > 5 ? rawRows.slice(-Math.min(10, n), -5) : [];

  const formulaVars = FORMULA_VARIABLES.map((vDef, j) => {
    const coeff = model.beta[j];
    const sensitivity = (coeff * logisticSlope) / stds[j]; // per real unit

    // ROC threshold
    const vals = matrix.map(r => r[j]);
    const roc = _computeThreshold(vals, outcomes);

    // Current average (last 10 sets)
    const currentAvg = last10.reduce((s, r) => s + r[vDef.name], 0) / last10.length;

    // Trend
    const last5Avg = last5.reduce((s, r) => s + r[vDef.name], 0) / last5.length;
    const prev5Avg = prev5.length > 0 ? prev5.reduce((s, r) => s + r[vDef.name], 0) / prev5.length : last5Avg;
    const trendPct = prev5Avg !== 0 ? (last5Avg - prev5Avg) / Math.abs(prev5Avg) : 0;
    const trend = trendPct > 0.05 ? "improving" : trendPct < -0.05 ? "declining" : "stable";

    // Total available gain
    const threshold = roc.threshold;
    let totalGain = 0;
    if (threshold !== null && sensitivity !== 0) {
      // For reception_error_rate, lower is better — invert
      const isInverse = vDef.name === "reception_error_rate";
      if (isInverse) {
        totalGain = currentAvg > threshold ? Math.abs(sensitivity) * (currentAvg - threshold) * 100 : 0;
      } else {
        totalGain = currentAvg < threshold ? Math.abs(sensitivity) * (threshold - currentAvg) * 100 : 0;
      }
    }

    return {
      ...vDef,
      coefficient: coeff,
      sensitivity,
      threshold,
      rocAuc: roc.auc,
      currentAvg,
      trend,
      winAbove: roc.winAbove,
      winBelow: roc.winBelow,
      totalGain: Math.round(totalGain * 10) / 10,
      priorityZone: "on_target", // assigned in next step
    };
  });

  // Step 7: Assign priority zones
  // Determine which are below threshold
  const belowThreshold = formulaVars.filter(v => {
    if (v.threshold === null) return false;
    if (v.name === "reception_error_rate") return v.currentAvg > v.threshold;
    return v.currentAvg < v.threshold;
  });
  // Sort by totalGain descending for priority
  belowThreshold.sort((a, b) => b.totalGain - a.totalGain);
  const highImpactNames = new Set(belowThreshold.slice(0, 3).map(v => v.name));

  for (const v of formulaVars) {
    if (v.rocAuc < 0.55 || v.threshold === null) {
      v.priorityZone = "low_relationship";
    } else {
      const isBelow = v.name === "reception_error_rate" ? v.currentAvg > v.threshold : v.currentAvg < v.threshold;
      if (isBelow && highImpactNames.has(v.name)) v.priorityZone = "high_impact";
      else if (isBelow) v.priorityZone = "moderate_impact";
      else v.priorityZone = "on_target";
    }
  }

  // Sort: high_impact first (by totalGain), then moderate, then on_target, then low
  const zoneOrder = { high_impact: 0, moderate_impact: 1, on_target: 2, low_relationship: 3 };
  formulaVars.sort((a, b) => {
    const za = zoneOrder[a.priorityZone], zb = zoneOrder[b.priorityZone];
    if (za !== zb) return za - zb;
    return b.totalGain - a.totalGain;
  });

  // Step 8: Narrative + headline
  const narrative = _generateNarrative(formulaVars, tier);
  const topPriority = formulaVars.find(v => v.priorityZone === "high_impact");
  const trendChange = formulaVars.find(v => v.trend !== "stable" && v.priorityZone !== "low_relationship");
  const allOnTarget = formulaVars.filter(v => v.priorityZone !== "low_relationship").every(v => v.priorityZone === "on_target");

  // Build headline per spec language
  let headline = null;
  if (topPriority) {
    headline = {
      variable: topPriority.displayName,
      message: `Your data shows the largest win rate improvement comes from pushing ${topPriority.displayName} above ${topPriority.format(topPriority.threshold)}. Currently at ${topPriority.format(topPriority.currentAvg)}${topPriority.totalGain > 0 ? ` — closing this gap is worth ~${topPriority.totalGain} win% points.` : "."}`,
    };
  } else if (allOnTarget) {
    const mostSensitive = [...formulaVars].filter(v => v.priorityZone === "on_target").sort((a, b) => Math.abs(b.sensitivity) - Math.abs(a.sensitivity))[0];
    if (mostSensitive) {
      headline = {
        variable: mostSensitive.displayName,
        message: `Your team is above winning thresholds across all major categories. Your most sensitive variable is ${mostSensitive.displayName} — maintaining ${mostSensitive.format(mostSensitive.threshold)}+ is your strongest predictor of continued success.`,
      };
    }
  }

  return {
    hasEnoughData: true,
    tier,
    totalSets,
    wonSets: wonCount,
    lostSets: lostCount,
    variables: formulaVars,
    narrative,
    formulaStrength: Math.round(cvAccuracy * 100),
    predictedWinProb: Math.round(pBase * 100),
    headline,
  };
};

// Old FORMULA_STATS kept for stats tab column rendering only
const FORMULA_STATS = [
  { key: "kill", label: "Kills", scoring: true },
  { key: "stuff_block", label: "Stuff Blocks", scoring: true },
  { key: "ace", label: "Aces", scoring: true },
  { key: "opponent_error", label: "Opp Errors", scoring: true },
  { key: "attack_error", label: "Attack Errors", scoring: false },
  { key: "ball_error", label: "Ball Handling Errors", scoring: false },
  { key: "serve_error", label: "Serve Errors", scoring: false },
  { key: "block", label: "Block Touches", scoring: false },
  { key: "dig", label: "Digs", scoring: false },
  { key: "cvr", label: "Covers", scoring: false },
  { key: "assist", label: "Assists", scoring: false },
];

// ── PLAYER IMPACT SCORE (PIS) ENGINE ────────────────────
const IMPACT_WEIGHTS = {
  // Terminal events: fixed ±1.0, never adjusted by Winning Formula
  kill: 1.0, attack_error: -1.0, attack_blocked: -1.0,
  ace: 1.0, serve_error: -1.0, reception_error: -1.0,
  stuff_block: 1.0, ball_error: -1.0,
  // Non-terminal: defaults, adjusted by Winning Formula multipliers
  serve_in: { 1: 0.40, 2: 0.15, 3: -0.05 },
  reception: { 3: 0.35, 2: 0.15, 1: -0.15, 0: 0.00 },
  block: 0.20, dig: 0.35, cvr: 0.25, assist: 0.75,
};

const TERMINAL_EVENTS = new Set([
  "kill", "attack_error", "attack_blocked", "ace",
  "serve_error", "reception_error", "stuff_block", "ball_error"
]);

const _getStatCategory = (stat) => {
  switch (stat) {
    case "kill": case "attack_error": case "attack_blocked": return "offense";
    case "ace": case "serve_error": case "serve_in": return "serving";
    case "reception": case "reception_error": return "passing";
    case "stuff_block": case "block": return "blocking";
    case "dig": return "defense";
    case "cvr": return "cover";
    case "assist": return "setting";
    default: return "misc";
  }
};

// Map Winning Formula coefficients → PIS category multipliers
const _deriveMultipliers = (formula) => {
  if (!formula?.hasEnoughData || !formula.variables?.length) return {};
  // Map formula variables to PIS categories
  const catMap = {
    serving: ["serve_pressure", "ace_error_ratio"],
    passing: ["reception_eff", "reception_error_rate"],
    blocking: ["stuff_block_rate", "block_touch_rate"],
    defense: ["dig_rate"],
    cover: ["cover_rate"],
  };
  const rawWeights = {};
  for (const [cat, varNames] of Object.entries(catMap)) {
    const coeffs = varNames.map(n => {
      const v = formula.variables.find(fv => fv.name === n);
      return v ? Math.abs(v.coefficient) : 0;
    });
    rawWeights[cat] = coeffs.reduce((s, c) => s + c, 0) / coeffs.length;
  }
  // Normalize: average raw weight becomes 1.0
  const vals = Object.values(rawWeights);
  const avg = vals.reduce((s, v) => s + v, 0) / vals.length;
  const multipliers = {};
  for (const [cat, raw] of Object.entries(rawWeights)) {
    multipliers[cat] = avg > 0 ? Math.max(0.25, Math.min(2.5, raw / avg)) : 1.0;
  }
  // Setting not in formula — always 1.0
  multipliers.setting = 1.0;
  return multipliers;
};

// Graduated blend: 0% at 8 sets, 100% at 30 sets
const _getEffectiveMultipliers = (setCount, rawMultipliers) => {
  if (setCount < 8 || !rawMultipliers || Object.keys(rawMultipliers).length === 0) return {};
  const blend = Math.min(1.0, (setCount - 8) / 22);
  const effective = {};
  for (const [cat, mult] of Object.entries(rawMultipliers)) {
    effective[cat] = 1.0 + (mult - 1.0) * blend;
  }
  return effective;
};

// Calculate Player Impact Rating from events
const calculatePlayerImpact = (events, playerId, formulaMultipliers = {}) => {
  const breakdown = { offense: 0, serving: 0, passing: 0, blocking: 0, defense: 0, cover: 0, setting: 0 };
  for (const ev of events) {
    if (ev.player !== playerId) continue;
    const stat = ev.stat;
    let weight = 0;
    if (stat === "serve_in") {
      const fp = ev.forcedPass ?? ev.metadata?.forcedPass;
      weight = IMPACT_WEIGHTS.serve_in[fp] ?? 0;
    } else if (stat === "reception") {
      const q = ev.quality ?? ev.metadata?.quality;
      weight = IMPACT_WEIGHTS.reception[q] ?? 0;
    } else if (typeof IMPACT_WEIGHTS[stat] === "number") {
      weight = IMPACT_WEIGHTS[stat];
    } else continue;
    // Apply formula multiplier to non-terminal events only
    if (!TERMINAL_EVENTS.has(stat)) {
      const cat = _getStatCategory(stat);
      weight *= (formulaMultipliers[cat] ?? 1.0);
    }
    const cat = _getStatCategory(stat);
    breakdown[cat] = (breakdown[cat] || 0) + weight;
  }
  const total = Object.values(breakdown).reduce((s, v) => s + v, 0);
  return { total: Math.round(total * 100) / 100, breakdown };
};

const defaultRoster = () =>
  Array.from({ length: 14 }, (_, i) => ({
    id: `p${i}`,
    number: "",
    name: "",
    position: "",
  }));

const POS_ORDER = { OH: 0, MB: 1, S: 2, OPP: 3, RS: 3, L: 4, DS: 5 };
const sortByPosition = (players) => [...players].sort((a, b) => {
  const pa = POS_ORDER[a.position] ?? 6;
  const pb = POS_ORDER[b.position] ?? 6;
  return pa !== pb ? pa - pb : 0;
});

const emptyMatch = () => ({
  id: Date.now().toString(),
  opponent: "",
  date: new Date().toISOString().split("T")[0],
  roster: defaultRoster(),
  sets: [],
  complete: false,
  format: 3, // best of 3 or 5
});

const emptySet = (num) => ({
  number: num,
  events: [],
  rallies: [],
  shots: [], // { origin, zone, outcome, timestamp }
  ourScore: 0,
  theirScore: 0,
  complete: false,
  // rotation state
  startingLineup: {}, // { pos1: playerId, pos2: ... pos6: playerId }
  currentLineup: {},
  liberoId: null, // backwards compat
  libero1Id: null,
  libero2Id: null,
  liberoIn: false, // is libero currently on court
  liberoForPlayer: null, // who the libero replaced
  liberoServeForMB: null, // backwards compat
  mbBackRowMap: {}, // { mbId: "libero1"|"libero2"|"self" }
  liberoServeMap: {}, // { liberoId: mbId } — which MB rotation each libero serves for
  liberoSwaps: {}, // runtime overrides from swap button: { mbId: liberoId|"self" }
  rotation: 1, // 1-6
  weServe: true,
  firstServerId: null,
  subs: [], // { inPlayer, outPlayer, rotation, timestamp }
  subCount: 0,
});

// Court position labels
const COURT_POS = {
  4: { label: "Front Left", row: "front", col: 0, short: "FL" },
  3: { label: "Front Mid", row: "front", col: 1, short: "FM" },
  2: { label: "Front Right", row: "front", col: 2, short: "FR" },
  5: { label: "Back Left", row: "back", col: 0, short: "BL" },
  6: { label: "Back Mid", row: "back", col: 1, short: "BM" },
  1: { label: "Back Right", row: "back", col: 2, short: "BR" },
};

const BACK_ROW = [1, 5, 6];
const FRONT_ROW = [2, 3, 4];

function VolleyballStats() {
  const [roomCode, setRoomCode] = useState(null);
  const [roomInput, setRoomInput] = useState("");
  const [recentRooms, setRecentRooms] = useState([]);
  const [screen, setScreenRaw] = useState("home");
  const navStackRef = useRef([]);
  const navigate = (s) => {
    navStackRef.current.push(screen);
    setScreenRaw(s);
  };
  const goBack = () => {
    if (navStackRef.current.length > 0) {
      const prev = navStackRef.current.pop();
      setScreenRaw(prev);
    } else {
      setScreenRaw("home");
    }
  };
  // For cases where we need to set screen without pushing history (e.g., room exit)
  const setScreen = (s) => {
    navStackRef.current = [];
    setScreenRaw(s);
  };
  const [matches, setMatches] = useState([]);
  const [currentMatch, setCurrentMatch] = useState(null);
  const [currentSetIdx, setCurrentSetIdx] = useState(0);
  const [toast, setToast] = useState(null);
  const [loaded, setLoaded] = useState(false);
  const toastRef = useRef(null);


  // Saved teams
  const [savedTeams, setSavedTeams] = useState([]);
  const [editingTeam, setEditingTeam] = useState(null);

  // Standalone scout sessions (accessible from home)
  const [scoutSessions, setScoutSessions] = useState([]);
  const [currentScout, setCurrentScout] = useState(null);
  const [scoutNameInput, setScoutNameInput] = useState(""); // for new scout creation

  // Setup state
  const [setupStep, setSetupStep] = useState("roster"); // roster, lineup, options
  const [lineupSlots, setLineupSlots] = useState({});
  const [lineupPositions, setLineupPositions] = useState({}); // {playerId: "OH"} overrides
  const [selectedLibero, setSelectedLibero] = useState(null);
  const [selectedLibero2, setSelectedLibero2] = useState(null);
  const [mbBackRowMap, setMbBackRowMap] = useState({}); // { mbId: "libero1"|"libero2"|"self" }
  const [weServeFirst, setWeServeFirst] = useState(true);
  const [firstServerPos, setFirstServerPos] = useState(1);
  const [selectingPos, setSelectingPos] = useState(null);
  const [selectingLibero, setSelectingLibero] = useState(null); // null, 1, or 2

  // Match state
  const [tab, setTab] = useState("court"); // court, stats, formula, swings, subs
  const [rallyPhase, setRallyPhase] = useState("idle"); // idle, offense, defense
  const [prevRallyPhase, setPrevRallyPhase] = useState(null); // for undo
  const [currentRally, setCurrentRally] = useState(null);
  const [prevRally, setPrevRally] = useState(null); // for undo
  const [selectedPlayer, setSelectedPlayer] = useState(null);
  const [undoStack, setUndoStack] = useState([]);
  const [assistPrompt, setAssistPrompt] = useState(null);
  const [scoutView, setScoutView] = useState("input");
  const [scoutPending, setScoutPending] = useState(null); // { originZone, outcome } → waiting for landing zone tap
  const [scoutOriginFilter, setScoutOriginFilter] = useState(null); // heatmap filter by origin zone
  const [statsSetView, setStatsSetView] = useState("current"); // "current", "match", or set index
  const [homeTab, setHomeTab] = useState("teams"); // "teams", "formula"
  const [liberoServeChoice, setLiberoServeChoice] = useState(null);
  const [libero2ServeChoice, setLibero2ServeChoice] = useState(null);
  const [showTimeout, setShowTimeout] = useState(false); // timeout overlay
  const [showRotationFix, setShowRotationFix] = useState(false); // manual rotation overlay
  const [activeTeamId, setActiveTeamId] = useState(null); // for team homepage
  // Practice mode
  const [practices, setPractices] = useState([]);
  const [currentPractice, setCurrentPractice] = useState(null);
  const [practiceRound, setPracticeRound] = useState(null); // { selectedPassers: [], events: [] }
  const [practicePasserPick, setPracticePasserPick] = useState(false); // which MB rotation libero serves for

  // Track active match to prevent Firebase listener overwrites during live tracking
  const activeMatchRef = useRef(false);
  useEffect(() => { activeMatchRef.current = !!currentMatch; }, [currentMatch]);

  // ── FIREBASE DATA NORMALIZATION ──────────────────────
  // Firebase: (1) drops empty arrays entirely ([] → undefined)
  // (2) converts arrays to objects {0: x, 1: y, ...}
  // (3) may create sparse objects if nulls existed {0: x, 2: z} (drops null at index 1)

  const fbNorm = (val) => {
    if (val === null || val === undefined) return val;
    if (typeof val !== "object") return val;
    if (Array.isArray(val)) return val.filter(v => v != null).map(fbNorm);
    const keys = Object.keys(val);
    if (keys.length === 0) return val;
    // Firebase pseudo-array: all keys are non-negative integers AND key "0" exists
    // (lineup objects have keys 1-6, no "0", so they stay as objects)
    const hasZero = keys.includes("0");
    const allNumeric = keys.every((k) => /^\d+$/.test(k));
    if (hasZero && allNumeric) {
      return keys.sort((a, b) => Number(a) - Number(b)).map((k) => fbNorm(val[k])).filter(v => v != null);
    }
    // Regular object — recurse
    const out = {};
    for (const [k, v] of Object.entries(val)) out[k] = fbNorm(v);
    return out;
  };

  const fbArr = (val) => {
    if (!val) return [];
    const normed = fbNorm(val);
    if (Array.isArray(normed)) return normed;
    if (typeof normed === "object") return Object.values(normed);
    return [];
  };

  // Ensure a set has all required array/object properties
  const normalizeSet = (s) => {
    if (!s || typeof s !== "object") return { events: [], rallies: [], shots: [], ourScore: 0, theirScore: 0, currentLineup: {} };
    // Ensure lineup objects have consistent integer-accessible keys
    // CRITICAL: Firebase stores {1:a, 2:b, ..., 6:f} as array [null, a, b, c, d, e, f]
    // fbNorm strips the null → [a, b, c, d, e, f] with indices 0-5
    // So index 0 = zone 1, index 1 = zone 2, etc.
    // Also handle raw Firebase arrays with null at index 0 (pre-fbNorm)
    const normLineup = (obj) => {
      if (!obj || typeof obj !== "object") return {};
      const out = {};
      if (Array.isArray(obj)) {
        // Check if this is a raw Firebase array with null/undefined at index 0
        const hasLeadingNull = obj.length > 0 && (obj[0] === null || obj[0] === undefined);
        if (hasLeadingNull) {
          // Raw Firebase format: index 1 = zone 1, ..., index 6 = zone 6
          for (let z = 1; z <= 6 && z < obj.length; z++) {
            if (obj[z]) out[z] = obj[z];
          }
        } else {
          // Post-fbNorm format: index 0 = zone 1, ..., index 5 = zone 6
          for (let i = 0; i < obj.length && i < 6; i++) {
            if (obj[i]) out[i + 1] = obj[i];
          }
        }
        if (Object.keys(out).length < 6) {
          console.warn("[normLineup] Array(" + obj.length + ") → " + Object.keys(out).length + " zones. leadingNull:" + hasLeadingNull);
        }
        return out;
      }
      for (const [k, v] of Object.entries(obj)) {
        if (/^[1-6]$/.test(k) && v) out[Number(k)] = v;
      }
      return out;
    };
    
    let currentLineup = normLineup(s.currentLineup);
    let startingLineup = normLineup(s.startingLineup);
    const posOverrides = s.positionOverrides && typeof s.positionOverrides === "object" && !Array.isArray(s.positionOverrides) ? s.positionOverrides : {};
    
    // REPAIR: if lineup has < 6 zones but positionOverrides has 6 starters, fill in missing players
    const starterIds = Object.keys(posOverrides);
    if (starterIds.length === 6) {
      // Repair startingLineup first
      if (Object.keys(startingLineup).length < 6 && Object.keys(startingLineup).length > 0) {
        const inStarting = new Set(Object.values(startingLineup));
        const missingFromStarting = starterIds.filter(id => !inStarting.has(id));
        const emptyStartZones = [1,2,3,4,5,6].filter(z => !startingLineup[z]);
        for (let i = 0; i < missingFromStarting.length && i < emptyStartZones.length; i++) {
          startingLineup[emptyStartZones[i]] = missingFromStarting[i];
        }
        if (missingFromStarting.length > 0) {
          console.warn("[REPAIR] Fixed startingLineup: added", missingFromStarting, "to zones", emptyStartZones.slice(0, missingFromStarting.length));
        }
      }
      // Repair currentLineup
      if (Object.keys(currentLineup).length < 6 && Object.keys(currentLineup).length > 0) {
        const inCurrent = new Set(Object.values(currentLineup));
        const missingFromCurrent = starterIds.filter(id => !inCurrent.has(id));
        const emptyCurrentZones = [1,2,3,4,5,6].filter(z => !currentLineup[z]);
        for (let i = 0; i < missingFromCurrent.length && i < emptyCurrentZones.length; i++) {
          currentLineup[emptyCurrentZones[i]] = missingFromCurrent[i];
        }
        if (missingFromCurrent.length > 0) {
          console.warn("[REPAIR] Fixed currentLineup: added", missingFromCurrent, "to zones", emptyCurrentZones.slice(0, missingFromCurrent.length));
        }
      }
    }
    
    return {
      ...s,
      events: Array.isArray(s.events) ? s.events : [],
      rallies: Array.isArray(s.rallies) ? s.rallies : [],
      shots: Array.isArray(s.shots) ? s.shots : [],
      subs: Array.isArray(s.subs) ? s.subs : [],
      currentLineup,
      startingLineup,
      positionOverrides: posOverrides,
      mbBackRowMap: s.mbBackRowMap && typeof s.mbBackRowMap === "object" && !Array.isArray(s.mbBackRowMap) ? s.mbBackRowMap : {},
      liberoServeMap: s.liberoServeMap && typeof s.liberoServeMap === "object" && !Array.isArray(s.liberoServeMap) ? s.liberoServeMap : {},
      liberoSwaps: s.liberoSwaps && typeof s.liberoSwaps === "object" && !Array.isArray(s.liberoSwaps) ? s.liberoSwaps : {},
      libero1Id: s.libero1Id || s.liberoId || null,
      libero2Id: s.libero2Id || null,
      ourScore: s.ourScore || 0,
      theirScore: s.theirScore || 0,
    };
  };

  const normalizeMatch = (m) => {
    if (!m || typeof m !== "object") return null;
    return {
      ...m,
      sets: Array.isArray(m.sets) ? m.sets.map(normalizeSet) : [],
      roster: Array.isArray(m.roster) ? m.roster : [],
    };
  };

  const normalizeTeam = (t) => {
    if (!t || typeof t !== "object") return null;
    return {
      ...t,
      players: Array.isArray(t.players) ? t.players : [],
    };
  };

  const normalizePractice = (p) => {
    if (!p || typeof p !== "object") return null;
    return {
      ...p,
      rounds: Array.isArray(p.rounds) ? p.rounds.map((r) => ({
        ...r,
        groups: Array.isArray(r.groups) ? r.groups.map((g) => ({
          ...g,
          selectedPassers: Array.isArray(g.selectedPassers) ? g.selectedPassers : [],
          events: Array.isArray(g.events) ? g.events : [],
        })) : [],
        events: Array.isArray(r.events) ? r.events : [],
      })) : [],
    };
  };

  const normalizeFromFb = (type, data) => {
    const arr = fbArr(data);
    switch (type) {
      case "teams": return arr.map(normalizeTeam).filter(Boolean);
      case "matches": return arr.map(normalizeMatch).filter(Boolean);
      case "practices": return arr.map(normalizePractice).filter(Boolean);
      default: return arr;
    }
  };

  // Load recent rooms on mount (before room selection) — stays in localStorage (per-device)
  useEffect(() => {
    try {
      const saved = localStorage.getItem("formula_recent_rooms");
      if (saved) setRecentRooms(JSON.parse(saved));
      const lastRoom = localStorage.getItem("formula_last_room");
      if (lastRoom) setRoomInput(lastRoom);
    } catch (e) {}
  }, []);

  // Firebase listeners — attach on room select, detach on room change
  useEffect(() => {
    if (!roomCode) return;
    setLoaded(false);

    const base = `rooms/${roomCode}`;
    const refs = {
      teams: fbDb.ref(`${base}/teams`),
      matches: fbDb.ref(`${base}/matches`),
      practices: fbDb.ref(`${base}/practices`),
    };

    // Track initial load (need all 3 to fire at least once)
    let loadFlags = { teams: false, matches: false, practices: false };
    const checkLoaded = () => {
      if (Object.values(loadFlags).every(Boolean)) setLoaded(true);
    };

    const handlers = {};

    handlers.teams = refs.teams.on('value', (snap) => {
      const raw = snap.val();
      const normalized = normalizeFromFb("teams", raw);
      console.log("[Firebase] teams raw:", raw, "→ normalized:", normalized);
      setSavedTeams(normalized);
      loadFlags.teams = true;
      checkLoaded();
    });

    handlers.matches = refs.matches.on('value', (snap) => {
      const raw = snap.val();
      if (activeMatchRef.current) {
        if (!loadFlags.matches) { loadFlags.matches = true; checkLoaded(); }
        console.log("[Firebase] matches update skipped (active match)");
        return;
      }
      // Log raw set data for lineup debugging
      if (raw) {
        const rawArr = Array.isArray(raw) ? raw : Object.values(raw);
        for (const m of rawArr) {
          if (m && m.sets) {
            const sets = Array.isArray(m.sets) ? m.sets : Object.values(m.sets);
            for (const s of sets) {
              if (s && s.currentLineup) {
                console.log("[Firebase RAW] match:", m.opponent, "set lineup:", JSON.stringify(s.currentLineup), "starting:", JSON.stringify(s.startingLineup), "lib1:", s.libero1Id || s.liberoId);
              }
            }
          }
        }
      }
      const normalized = normalizeFromFb("matches", raw);
      console.log("[Firebase] matches raw:", raw, "→ normalized:", normalized);
      if (normalized.length > 0) {
        console.log("[Firebase] match[0] teamId:", normalized[0].teamId, "sets:", normalized[0].sets?.length, "roster:", normalized[0].roster?.length);
        // Log normalized lineup for comparison with raw
        for (const m of normalized) {
          for (const s of (m.sets || [])) {
            console.log("[Firebase NORM] match:", m.opponent, "set lineup:", JSON.stringify(s.currentLineup), "starting:", JSON.stringify(s.startingLineup), "lib1:", s.libero1Id);
          }
        }
      }
      setMatches(normalized);
      loadFlags.matches = true;
      checkLoaded();
    });

    handlers.practices = refs.practices.on('value', (snap) => {
      const raw = snap.val();
      const normalized = normalizeFromFb("practices", raw);
      console.log("[Firebase] practices:", normalized.length, "sessions");
      setPractices(normalized);
      loadFlags.practices = true;
      checkLoaded();
    });

    // Save room to recents (localStorage — per device)
    try {
      localStorage.setItem("formula_last_room", roomCode);
      const rooms = JSON.parse(localStorage.getItem("formula_recent_rooms") || "[]");
      const updated = [roomCode, ...rooms.filter((r) => r !== roomCode)].slice(0, 10);
      localStorage.setItem("formula_recent_rooms", JSON.stringify(updated));
      setRecentRooms(updated);
    } catch (e) {}

    // Cleanup listeners on room change
    return () => {
      refs.teams.off('value', handlers.teams);
      refs.matches.off('value', handlers.matches);
      refs.practices.off('value', handlers.practices);
    };
  }, [roomCode]);

  // Per-team scout listener — loads only active team's scouts
  useEffect(() => {
    if (!roomCode || !activeTeamId) { setScoutSessions([]); return; }
    const teamScoutRef = fbDb.ref(`rooms/${roomCode}/teamScout/${activeTeamId}`);
    const handler = teamScoutRef.on('value', (snap) => {
      const normalized = fbArr(snap.val());
      console.log("[Firebase] teamScout for", activeTeamId, ":", normalized.length, "sessions");
      setScoutSessions(normalized);
    });

    // One-time migration: check old global scout path for sessions belonging to this team
    fbDb.ref(`rooms/${roomCode}/scout`).once('value', (snap) => {
      const allOld = fbArr(snap.val());
      const mine = allOld.filter((s) => s.teamId === activeTeamId);
      if (mine.length > 0) {
        console.log("[Firebase] Migrating", mine.length, "scout sessions for team", activeTeamId);
        // Read current per-team data, merge, write back
        teamScoutRef.once('value', (tSnap) => {
          const existing = fbArr(tSnap.val());
          const existingIds = new Set(existing.map((s) => s.id));
          const toAdd = mine.filter((s) => !existingIds.has(s.id));
          if (toAdd.length > 0) {
            const merged = [...existing, ...toAdd];
            teamScoutRef.set(merged);
          }
          // Remove migrated sessions from old global path
          const remaining = allOld.filter((s) => s.teamId !== activeTeamId);
          fbDb.ref(`rooms/${roomCode}/scout`).set(remaining.length > 0 ? remaining : null);
        });
      }
    });

    return () => { teamScoutRef.off('value', handler); };
  }, [roomCode, activeTeamId]);

  // Save functions — write to Firebase
  const save = (m) => {
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/matches`).set(m); } catch (e) {}
  };

  const saveScoutSessions = (sessions) => {
    setScoutSessions(sessions);
    if (!roomCode || !activeTeamId) return;
    try { fbDb.ref(`rooms/${roomCode}/teamScout/${activeTeamId}`).set(sessions); } catch (e) {}
  };

  const deleteMatch = (matchId) => {
    const updated = matches.filter((m) => m.id !== matchId);
    setMatches(updated);
    save(updated);
    showToast("Match deleted");
  };

  const saveTeams = (teams) => {
    setSavedTeams(teams);
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/teams`).set(teams); } catch (e) {}
  };

  const savePractices = (p) => {
    setPractices(p);
    if (!roomCode) return;
    try { fbDb.ref(`rooms/${roomCode}/practices`).set(p); } catch (e) {}
  };

  const deletePractice = (practiceId) => {
    const updated = practices.filter((p) => p.id !== practiceId);
    savePractices(updated);
    showToast("Practice deleted");
  };

  const createTeam = () => {
    setEditingTeam({
      id: Date.now().toString(),
      name: "",
      players: Array.from({ length: 16 }, (_, i) => ({
        id: `t${Date.now()}-p${i}`,
        number: "",
        name: "",
        position: "",
      })),
    });
    navigate("editTeam");
  };

  const saveCurrentTeam = () => {
    if (!editingTeam || !editingTeam.name.trim()) {
      showToast("Enter a team name");
      return;
    }
    const exists = savedTeams.find((t) => t.id === editingTeam.id);
    let updated;
    if (exists) {
      updated = savedTeams.map((t) => (t.id === editingTeam.id ? editingTeam : t));
    } else {
      updated = [...savedTeams, editingTeam];
    }
    saveTeams(updated);
    setEditingTeam(null);
    setScreen("home");
    showToast(`${editingTeam.name} saved!`);
  };

  const deleteTeam = (teamId) => {
    const updated = savedTeams.filter((t) => t.id !== teamId);
    saveTeams(updated);
    showToast("Team deleted");
  };

  const startMatchWithTeam = (team) => {
    const match = emptyMatch();
    // Copy team roster — preserve original player IDs for stat continuity across matches
    match.roster = ((team.players||[])).filter((p) => p.number).map((p) => ({
      ...p,
    }));
    // Pad to 14 if fewer
    while (match.roster.length < 14) {
      match.roster.push({ id: `m${Date.now()}-px${match.roster.length}`, number: "", name: "", position: "" });
    }
    match.teamName = team.name;
    match.teamId = team.id;
    setCurrentMatch(match);
    setSetupStep("roster");
    navigate("setup");
  };

  const showToast = (msg) => {
    if (toastRef.current) clearTimeout(toastRef.current);
    setToast(msg);
    toastRef.current = setTimeout(() => setToast(null), 1500);
  };

  const persistMatch = (updated) => {
    setCurrentMatch(updated);
    setMatches((prev) => {
      const all = prev.map((m) => (m.id === updated.id ? updated : m));
      if (!all.find((m) => m.id === updated.id)) all.push(updated);
      save(all);
      return all;
    });
  };

  const getCurrentSet = () => {
    if (!currentMatch || !currentMatch.sets[currentSetIdx]) return null;
    return currentMatch.sets[currentSetIdx];
  };

  // CRITICAL: use functional updater to avoid stale closure issues
  // when multiple updates fire in the same tick (recordEvent + scorePoint)
  const updateCurrentSet = (updater) => {
    setCurrentMatch((prev) => {
      if (!prev || !prev.sets[currentSetIdx]) return prev;
      const sets = [...prev.sets];
      sets[currentSetIdx] = updater(sets[currentSetIdx]);
      const updated = { ...prev, sets };
      // Persist async
      setMatches((prevMatches) => {
        const all = prevMatches.map((m) => (m.id === updated.id ? updated : m));
        if (!all.find((m) => m.id === updated.id)) all.push(updated);
        save(all);
        return all;
      });
      return updated;
    });
  };

  // ── ROTATION LOGIC ──────────────────────────────────
  const rotate = (lineup) => {
    // Clockwise rotation: 1→6→5→4→3→2→1
    const newLineup = {};
    newLineup[1] = lineup[2];
    newLineup[2] = lineup[3];
    newLineup[3] = lineup[4];
    newLineup[4] = lineup[5];
    newLineup[5] = lineup[6];
    newLineup[6] = lineup[1];
    // Validate: all 6 must be defined
    const missing = [1,2,3,4,5,6].filter(z => !newLineup[z]);
    if (missing.length > 0) console.error("[ROTATE] Missing zones after rotation:", missing, "input:", JSON.stringify(lineup), "output:", JSON.stringify(newLineup));
    return newLineup;
  };

  // Manual rotation: set lineup so targetPlayerId is in zone 1
  const applyManualRotation = (targetPlayerId, weServe) => {
    if (!currentMatch || !currentMatch.sets?.[currentSetIdx]) return;
    const set = currentMatch.sets[currentSetIdx];
    const starting = set.startingLineup || {};
    // Find which starting zone the target player is in
    let targetZone = null;
    for (let z = 1; z <= 6; z++) {
      if (starting[z] === targetPlayerId) { targetZone = z; break; }
    }
    if (!targetZone) return;
    // Compute rotation count: how many rotations to get from starting to target in zone 1
    const rotCount = (targetZone - 1) % 6;
    // Apply rotations to starting lineup
    let newLineup = { ...starting };
    for (let i = 0; i < rotCount; i++) newLineup = rotate(newLineup);
    // Update set
    updateCurrentSet((s) => ({
      ...s,
      currentLineup: newLineup,
      rotation: rotCount === 0 ? 1 : rotCount + 1,
      weServe: weServe,
      liberoSwaps: {}, // reset swaps for new rotation
    }));
    setShowRotationFix(false);
    setRallyPhase("idle");
    showToast(`Rotation set: R${rotCount + 1} — ${weServe ? "Our serve" : "Receiving"}`);
  };

  const getPlayerById = (id) => {
    if (!currentMatch) return null;
    return ((currentMatch.roster||[])).find((p) => p.id === id);
  };

  // Get effective position: check match overrides first, then roster position
  const getEffectivePosition = (id) => {
    if (!id) return "";
    // Check the current set's positionOverrides first
    const set = currentMatch?.sets?.[currentSetIdx] || currentMatch?.sets?.[currentMatch?.sets?.length - 1];
    const overrides = set?.positionOverrides || {};
    if (overrides[id]) return overrides[id];
    // Fall back to setup-time lineupPositions state
    if (lineupPositions[id]) return lineupPositions[id];
    // Fall back to roster position
    const p = getPlayerById(id);
    return p?.position || "";
  };

  // Get libero IDs from set (backwards compatible with old single-libero sets)
  const getSetLiberos = (set) => {
    if (!set) return { lib1: null, lib2: null };
    return {
      lib1: set.libero1Id || set.liberoId || null,
      lib2: set.libero2Id || null,
    };
  };

  const isLiberoId = (pid, set) => {
    const { lib1, lib2 } = getSetLiberos(set);
    return pid === lib1 || pid === lib2;
  };

  // Determine which player should be in for a given MB in the back row
  const getBackRowSubFor = (set, mbId, zone) => {
    if (!mbId) return mbId;
    const { lib1, lib2 } = getSetLiberos(set);
    if (!lib1 && !lib2) return mbId; // no liberos

    // Check runtime swap override first
    const swapOverride = set.liberoSwaps?.[mbId];
    if (swapOverride === "self") return mbId;
    if (swapOverride && (swapOverride === lib1 || swapOverride === lib2)) {
      // Zone 1 serving: only sub if this libero serves for this MB
      if (zone === 1 && set.weServe) {
        const serveMap = set.liberoServeMap || {};
        const oldServeForMB = set.liberoServeForMB; // backwards compat
        if (serveMap[swapOverride] === mbId || (swapOverride === lib1 && oldServeForMB === mbId)) {
          return swapOverride;
        }
        return mbId; // MB serves themselves
      }
      return swapOverride;
    }

    // Check setup assignment
    const backRowMap = set.mbBackRowMap || {};
    const assignment = backRowMap[mbId];
    let liberoToSub = null;

    if (assignment === "libero2" && lib2) liberoToSub = lib2;
    else if (assignment === "libero1" && lib1) liberoToSub = lib1;
    else if (assignment === "self") return mbId;
    else if (lib1) liberoToSub = lib1; // default: use libero 1
    else return mbId;

    // Zone 1 serving: only sub if this libero serves for this MB
    if (zone === 1 && set.weServe) {
      const serveMap = set.liberoServeMap || {};
      const oldServeForMB = set.liberoServeForMB;
      if (serveMap[liberoToSub] === mbId || (liberoToSub === lib1 && oldServeForMB === mbId)) {
        return liberoToSub;
      }
      return mbId;
    }

    return liberoToSub;
  };

  const getOnCourtLineup = (set) => {
    if (!set) return {};
    const lineup = { ...set.currentLineup };
    
    // Self-heal: if any position 1-6 is empty, try to reconstruct from startingLineup + rotation
    for (let z = 1; z <= 6; z++) {
      if (!lineup[z] && !lineup[String(z)]) {
        // Try string key (Firebase converts numeric keys to strings)
        const strKey = String(z);
        if (set.currentLineup?.[strKey]) {
          lineup[z] = set.currentLineup[strKey];
        } else if (set.startingLineup?.[z] || set.startingLineup?.[strKey]) {
          console.warn("[LINEUP HEAL] Zone", z, "empty in currentLineup, reconstructing from startingLineup");
          // Rebuild from startingLineup with correct rotation count
          const rotCount = ((set.rotation || 1) - 1) % 6;
          let reconstructed = { ...(set.startingLineup || {}) };
          // Normalize keys to numbers
          const normalized = {};
          for (const k of Object.keys(reconstructed)) normalized[Number(k)] = reconstructed[k];
          let rotated = { ...normalized };
          for (let r = 0; r < rotCount; r++) rotated = rotate(rotated);
          for (let zz = 1; zz <= 6; zz++) {
            if (!lineup[zz]) lineup[zz] = rotated[zz];
          }
          break;
        }
      }
    }
    
    const { lib1, lib2 } = getSetLiberos(set);
    if (!lib1 && !lib2) return lineup;

    for (const pos of BACK_ROW) {
      const playerId = lineup[pos];
      if (!playerId) continue; // skip empty slots
      if (getEffectivePosition(playerId) === "MB") {
        const sub = getBackRowSubFor(set, playerId, pos);
        if (sub && sub !== playerId) {
          lineup[pos] = sub;
          lineup._liberoFor = playerId;
          lineup._liberoPos = pos;
        }
        break; // only one MB in back row at a time
      }
    }
    return lineup;
  };

  const getCurrentServer = (set) => {
    if (!set) return null;
    if (!set.weServe) return null;
    const basePlayerId = set.currentLineup[1]; // who is in zone 1 by rotation
    if (!basePlayerId || !currentMatch) return basePlayerId;
    const { lib1, lib2 } = getSetLiberos(set);
    // If an MB is in zone 1 and we have liberos
    if (getEffectivePosition(basePlayerId) === "MB" && (lib1 || lib2)) {
      const sub = getBackRowSubFor(set, basePlayerId, 1);
      return sub; // either the libero (if serves for this MB) or the MB themselves
    }
    // If a libero is in zone 1 somehow
    if (isLiberoId(basePlayerId, set)) return basePlayerId;
    return basePlayerId;
  };

  const getNextServer = (set) => {
    // When receiving, the player in zone 2 will rotate to zone 1 on sideout
    if (!set || set.weServe) return null;
    const lineup = getOnCourtLineup(set);
    return lineup[2];
  };

  // Identify serve-receive passers: typically OHs + Libero
  // Front-row OHs pull back to pass, libero always passes
  // Any player with position OH, L, or DS is a primary passer
  const isPrimaryPasser = (playerId, set) => {
    if (!set || !currentMatch) return false;
    // Either libero always passes
    if (isLiberoId(playerId, set)) return true;
    // OHs and DS are primary passers
    const pos = getEffectivePosition(playerId);
    if (["OH", "L", "DS"].includes(pos)) return true;
    return false;
  };

  // Get all on-court players for receive phase, with primary passer flag
  const getPassers = (set) => {
    if (!set) return [];
    const lineup = getOnCourtLineup(set);
    const passers = [];
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (pid && typeof pid === "string") {
        passers.push({ pos, playerId: pid, player: getPlayerById(pid), primary: isPrimaryPasser(pid, set) });
      }
    }
    return passers;
  };

  // ── SCORING ──────────────────────────────────────────
  const scorePoint = (forUs) => {
    updateCurrentSet((set) => {
      let newSet = { ...set };
      if (forUs) {
        newSet.ourScore = set.ourScore + 1;
        if (!set.weServe) {
          // Sideout! We rotate and now serve
          newSet.currentLineup = rotate(set.currentLineup);
          newSet.rotation = (set.rotation % 6) + 1;
          newSet.weServe = true;
        }
        // If already serving, stay same rotation
      } else {
        newSet.theirScore = set.theirScore + 1;
        if (set.weServe) {
          // Lost serve
          newSet.weServe = false;
        }
      }
      return newSet;
    });
  };

  const recordEvent = (playerId, stat, extra = {}) => {
    const event = {
      id: Date.now().toString() + Math.random().toString(36).slice(2, 5),
      player: playerId,
      stat,
      timestamp: Date.now(),
      rotation: getCurrentSet()?.rotation,
      weServing: getCurrentSet()?.weServe,
      ...extra,
      _prevPhase: rallyPhase, // save phase for undo
      _prevRally: currentRally ? { ...currentRally } : null,
    };
    updateCurrentSet((set) => ({ ...set, events: [...(set.events || []), event] }));
    setUndoStack((prev) => [...prev, event]);
    return event;
  };

  // ── ONE-TAP STAT RECORDING ──────────────────────────

  const recordRally = (rally) => {
    updateCurrentSet((set) => ({ ...set, rallies: [...(set.rallies || []), rally] }));
  };

  const endRally = (weWon, rally) => {
    // Save score snapshot to last undo entry for proper undo
    const set = getCurrentSet();
    if (set) {
      setUndoStack((prev) => {
        if (prev.length === 0) return prev;
        const last = { ...prev[prev.length - 1] };
        last._undoScore = {
          ourScore: set.ourScore,
          theirScore: set.theirScore,
          weServe: set.weServe,
          currentLineup: { ...set.currentLineup },
          rotation: set.rotation,
        };
        last._undoRally = !!rally;
        return [...prev.slice(0, -1), last];
      });
    }
    // Capture on-court players for +/- before score changes lineup
    const onCourtNow = set ? getOnCourtLineup(set) : {};
    const onCourtIds = [1,2,3,4,5,6].map((p) => onCourtNow[p]).filter((v) => typeof v === "string");
    if (rally) recordRally({ ...rally, weWon, onCourt: onCourtIds });
    scorePoint(weWon);
    setRallyPhase("idle");
    setCurrentRally(null);
    setSelectedPlayer(null);
  };

  const getSetterOnCourt = (set) => {
    if (!set || !currentMatch) return null;
    const lineup = getOnCourtLineup(set);
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (getEffectivePosition(pid) === "S") return pid;
    }
    return null;
  };

  const getHittersOnCourt = (set) => {
    if (!set || !currentMatch) return [];
    const lineup = getOnCourtLineup(set);
    const hitters = [];
    for (const pos of [1, 2, 3, 4, 5, 6]) {
      const pid = lineup[pos];
      if (!pid || typeof pid !== "string") continue;
      const ePos = getEffectivePosition(pid);
      if (!["S", "L", "DS"].includes(ePos)) hitters.push(pid);
    }
    return hitters;
  };


  // ── UNDO ────────────────────────────────────────────
  const undoLastAction = () => {
    if (undoStack.length === 0) return;
    const last = undoStack[undoStack.length - 1];
    // Remove the event
    updateCurrentSet((set) => ({
      ...set,
      events: (set.events || []).filter((e) => e.id !== last.id),
    }));
    // Revert rally phase if saved
    if (last._prevPhase !== undefined) {
      setRallyPhase(last._prevPhase);
    }
    if (last._prevRally !== undefined) {
      setCurrentRally(last._prevRally);
    }
    // If this was a rally-ending event that changed score, also undo the rally and score
    if (last._undoScore) {
      updateCurrentSet((set) => {
        const newSet = { ...set };
        newSet.ourScore = last._undoScore.ourScore;
        newSet.theirScore = last._undoScore.theirScore;
        newSet.weServe = last._undoScore.weServe;
        newSet.currentLineup = last._undoScore.currentLineup;
        newSet.rotation = last._undoScore.rotation;
        if (last._undoRally) {
          newSet.rallies = (set.rallies || []).slice(0, -1);
        }
        return newSet;
      });
    }
    setUndoStack((prev) => prev.slice(0, -1));
    showToast("Undone");
  };

  // ── SUBS ────────────────────────────────────────────
  const makeSub = (inPlayerId, outPlayerId) => {
    updateCurrentSet((set) => {
      const newLineup = { ...set.currentLineup };
      for (const pos of Object.keys(newLineup)) {
        if (newLineup[pos] === outPlayerId) {
          newLineup[pos] = inPlayerId;
          break;
        }
      }
      return {
        ...set,
        currentLineup: newLineup,
        subs: [
          ...set.subs,
          { inPlayer: inPlayerId, outPlayer: outPlayerId, rotation: set.rotation, timestamp: Date.now() },
        ],
        subCount: set.subCount + 1,
      };
    });
    const inP = getPlayerById(inPlayerId);
    const outP = getPlayerById(outPlayerId);
    showToast(`SUB: ${inP?.name?.split(" ")[0]} in for ${outP?.name?.split(" ")[0]}`);
  };

  // ── END SET ─────────────────────────────────────────
  const endCurrentSet = () => {
    updateCurrentSet((set) => ({ ...set, complete: true }));
    setRallyPhase("idle");
    setCurrentRally(null);
    setUndoStack([]);
    setSelectingPos(null);
    setSelectingLibero(null);

    // Check if match is over
    const setsToWin = currentMatch?.format === 5 ? 3 : 2;
    const completedSets = [...(currentMatch?.sets || [])];
    // The current set just got marked complete but state hasn't propagated yet,
    // so count from what we have plus the current set result
    const set = currentMatch?.sets?.[currentSetIdx];
    const weWonThisSet = set && set.ourScore > set.theirScore;
    let setsWon = completedSets.filter((s, i) => i !== currentSetIdx && s.complete && s.ourScore > s.theirScore).length + (weWonThisSet ? 1 : 0);
    let setsLost = completedSets.filter((s, i) => i !== currentSetIdx && s.complete && s.ourScore < s.theirScore).length + (weWonThisSet ? 0 : 1);

    if (setsWon >= setsToWin || setsLost >= setsToWin) {
      // Match is over — mark complete and show summary
      setCurrentMatch((prev) => {
        const updated = { ...prev, complete: true, result: { setsWon, setsLost, won: setsWon >= setsToWin } };
        setMatches((prevM) => {
          const all = prevM.map((m) => (m.id === updated.id ? updated : m));
          save(all);
          return all;
        });
        return updated;
      });
      navigate("matchComplete");
    } else {
      // More sets to play — go to new set setup
      setSetupStep("lineup");
      navigate("setup");
    }
  };

  const endMatchEarly = () => {
    if (!confirm("End this match? You can still view stats.")) return;
    const completedSets = (currentMatch?.sets || []).filter((s) => s.complete);
    const setsWon = completedSets.filter((s) => s.ourScore > s.theirScore).length;
    const setsLost = completedSets.filter((s) => s.ourScore < s.theirScore).length;
    // Also complete the current set if it has any score
    const set = currentMatch?.sets?.[currentSetIdx];
    if (set && !set.complete && (set.ourScore > 0 || set.theirScore > 0)) {
      updateCurrentSet((s) => ({ ...s, complete: true }));
    }
    setCurrentMatch((prev) => {
      const updated = { ...prev, complete: true, result: { setsWon, setsLost, won: setsWon > setsLost } };
      setMatches((prevM) => {
        const all = prevM.map((m) => (m.id === updated.id ? updated : m));
        save(all);
        return all;
      });
      return updated;
    });
    setRallyPhase("idle");
    setCurrentRally(null);
    setUndoStack([]);
    navigate("matchComplete");
  };

  // ── CORRELATION ANALYSIS ────────────────────────────
  const getServeCorrelation = () => {
    if (!currentMatch) return { data: [], summary: "" };
    const allRallies = ((currentMatch.sets||[])).flatMap((s) => s.rallies || []);

    const ourServes = allRallies.filter((r) => r.type === "our_serve" && r.serveForced);
    const byQuality = { 1: { total: 0, won: 0 }, 2: { total: 0, won: 0 }, 3: { total: 0, won: 0 } };

    for (const r of ourServes) {
      const q = r.serveForced;
      if (byQuality[q]) {
        byQuality[q].total++;
        if (r.weWon) byQuality[q].won++;
      }
    }

    const theirServes = allRallies.filter((r) => r.type === "their_serve" && r.passQuality !== undefined);
    const byPassQ = { 1: { total: 0, won: 0 }, 2: { total: 0, won: 0 }, 3: { total: 0, won: 0 } };

    for (const r of theirServes) {
      const q = r.passQuality;
      if (byPassQ[q]) {
        byPassQ[q].total++;
        if (r.weWon) byPassQ[q].won++;
      }
    }

    return { ourServes: byQuality, theirServes: byPassQ };
  };

  // ── STATS HELPERS ───────────────────────────────────
  const getSetTotals = (setData) => {
    const totals = {};
    if (!setData) return totals;
    for (const event of (setData.events || [])) {
      if (event.stat === "serve_in") continue;
      totals[event.stat] = (totals[event.stat] || 0) + 1;
    }
    return totals;
  };

  const getMatchTotals = () => {
    const totals = {};
    if (!currentMatch) return totals;
    for (const set of (currentMatch.sets || [])) {
      for (const event of (set.events || [])) {
        if (event.stat === "serve_in") continue;
        totals[event.stat] = (totals[event.stat] || 0) + 1;
      }
    }
    return totals;
  };

  const getPlayerSetStats = (playerId, setData) => {
    const stats = {};
    if (!setData) return stats;
    for (const event of (setData.events || [])) {
      if (event.player === playerId && event.stat !== "serve_in") {
        stats[event.stat] = (stats[event.stat] || 0) + 1;
      }
    }
    return stats;
  };

  // Weighted passing: 3→1.5, 2→1.0, 1→0.5, 0→0
  const PASS_WEIGHTS = { 3: 1.5, 2: 1.0, 1: 0.5, 0: 0 };
  const getPlayerPassingStats = (playerId, setData) => {
    if (!setData) return null;
    const passes = { 0: 0, 1: 0, 2: 0, 3: 0 };
    let total = 0;
    for (const ev of (setData.events || [])) {
      if (ev.player === playerId && ev.stat === "reception" && ev.quality !== undefined) {
        passes[ev.quality] = (passes[ev.quality] || 0) + 1;
        total++;
      }
    }
    if (total === 0) return null;
    let weightedSum = 0;
    let weightTotal = 0;
    for (const [q, count] of Object.entries(passes)) {
      const w = PASS_WEIGHTS[q] || 0;
      weightedSum += Number(q) * w * count;
      weightTotal += w * count;
    }
    const weightedScore = weightTotal > 0 ? weightedSum / weightTotal : 0;
    const simpleAvg = (passes[0]*0 + passes[1]*1 + passes[2]*2 + passes[3]*3) / total;
    return { passes, total, weightedScore, simpleAvg };
  };

  const getSwingDistribution = (setData) => {
    if (!currentMatch || !setData) return [];
    const dist = [];
    for (const player of currentMatch.roster) {
      if (!player.number) continue;
      const ps = getPlayerSetStats(player.id, setData);
      const attacks = (ps.kill || 0) + (ps.attack_error || 0) + (ps.attack_blocked || 0);
      dist.push({
        player,
        attacks,
        kills: ps.kill || 0,
        errors: ps.attack_error || 0,
        blocked: ps.attack_blocked || 0,
        killPct: attacks > 0 ? ((ps.kill || 0) - (ps.attack_error || 0)) / attacks : null,
      });
    }
    dist.sort((a, b) => b.attacks - a.attacks);
    return dist;
  };

  // Dynamic formula: elastic net logistic regression over computed set variables
  // Filters to current match's team only
  const getFormulaAnalysis = () => {
    const teamId = currentMatch?.teamId;
    const setRows = [];
    for (const m of matches) {
      if (teamId && m.teamId !== teamId) continue;
      for (const s of (m.sets || [])) {
        if (s.complete) {
          setRows.push({ set: s, won: s.ourScore > s.theirScore });
        }
      }
    }
    return computeWinningFormula(setRows);
  };

  // Current set progress (works regardless of history)
  const getCurrentSetProgress = (setData) => {
    const totals = getSetTotals(setData);
    const ourScore = setData?.ourScore || 0;
    const eventScored = (totals.kill || 0) + (totals.stuff_block || 0) + (totals.ace || 0) + (totals.opponent_error || 0);
    const currentVars = setData ? computeFormulaRow(setData) : {};
    return {
      totals,
      totalScored: ourScore,
      eventScored, // tracked scoring events (may be < ourScore if +US was used)
      remaining: Math.max(0, 25 - ourScore),
      currentVars,
      stats: FORMULA_STATS.map((fs) => ({
        ...fs,
        actual: fs.key === "stuff_block" ? (totals.stuff_block || 0) : (totals[fs.key] || 0),
      })),
    };
  };

  const getServeRisk = (setData) => {
    const totals = getSetTotals(setData);
    const aces = totals.ace || 0;
    const errors = totals.serve_error || 0;
    const total = aces + errors;
    if (total === 0) return { ratio: 0, aces, errors, net: 0, recommendation: "No serve data yet" };
    const net = aces - errors;
    const ratio = aces / Math.max(1, errors);
    let rec = "";
    if (ratio >= 2) rec = "Serving is a weapon. Keep the pressure on.";
    else if (ratio >= 1) rec = "Serving net positive. Stay aggressive.";
    else if (ratio >= 0.5) rec = "Errors outpacing aces. Consider backing off.";
    else rec = "Too many errors. Prioritize getting serves in.";
    return { ratio, aces, errors, net, recommendation: rec };
  };

  // Player Impact Rating helpers
  // Compute formula analysis at component level for stats tab access
  const formulaAnalysis = getFormulaAnalysis();

  const getFormulaMultipliers = () => {
    const fa = formulaAnalysis;
    const rawMult = _deriveMultipliers(fa);
    return _getEffectiveMultipliers(fa?.totalSets || 0, rawMult);
  };

  const getPlayerPIS = (playerId, sets) => {
    const mult = getFormulaMultipliers();
    const allEvents = [];
    for (const s of sets) {
      for (const ev of (s.events || [])) allEvents.push(ev);
    }
    return calculatePlayerImpact(allEvents, playerId, mult);
  };

  const getPlayerSetPIS = (playerId, setData) => {
    if (!setData) return { total: 0, breakdown: {} };
    const mult = getFormulaMultipliers();
    return calculatePlayerImpact(setData.events || [], playerId, mult);
  };

  // Formula status: how many variables are above threshold in current set
  const getFormulaBudget = (setData, fa) => {
    if (!fa?.hasEnoughData || !setData) return null;
    const cv = computeFormulaRow(setData);
    const significant = fa.variables.filter(v => v.threshold !== null && v.priorityZone !== "low_relationship");
    if (significant.length === 0) return null;
    let above = 0;
    for (const v of significant) {
      const val = cv[v.name] ?? 0;
      const isInverse = v.name === "reception_error_rate";
      if (isInverse ? val <= v.threshold : val >= v.threshold) above++;
    }
    return { above, total: significant.length, pct: Math.round((above / significant.length) * 100) };
  };

  // ═══════════════════════════════════════════════════
  // RENDER
  // ═══════════════════════════════════════════════════

  // ── ROOM SELECTION SCREEN ────────────────────────────
  if (!roomCode) {
    const enterRoom = (code) => {
      const clean = code.trim().toUpperCase().replace(/[^A-Z0-9]/g, "");
      if (clean.length < 2) return;
      setRoomCode(clean);
      setLoaded(false);
    };
    const generateCode = () => {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    };

    return (
      <div style={{ minHeight: "100vh", minHeight: "100dvh", background: "#0a0a0f", color: "#e2e8f0", fontFamily: "'SF Pro Display',-apple-system,BlinkMacSystemFont,sans-serif", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", padding: 20 }}>
        <img src={LOGO_FULL} alt="Formula by PRV8" style={{ width: 280, marginBottom: 28 }} />

        <div style={{ width: "100%", maxWidth: 260 }}>
          <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>ENTER ROOM CODE</div>
          <input
            style={{ display: "block", width: "100%", padding: 12, background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", fontSize: 18, fontWeight: 700, letterSpacing: 3, textTransform: "uppercase", textAlign: "center", marginBottom: 8, boxSizing: "border-box" }}
            value={roomInput}
            onChange={(e) => setRoomInput(e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, "").slice(0, 16))}
            placeholder="ROOM"
            onKeyDown={(e) => { if (e.key === "Enter") enterRoom(roomInput); }}
          />
          <button
            style={{ display: "block", width: "100%", padding: 12, background: "#007bff", border: "none", borderRadius: 10, color: "#fff", fontSize: 15, fontWeight: 800, cursor: "pointer", marginBottom: 10, opacity: roomInput.trim().length < 2 ? 0.3 : 1, boxSizing: "border-box" }}
            disabled={roomInput.trim().length < 2}
            onClick={() => enterRoom(roomInput)}>
            JOIN ROOM
          </button>
          <button
            style={{ display: "block", width: "100%", padding: 10, background: "none", border: "1px solid #007bff", borderRadius: 10, color: "#007bff", fontSize: 13, fontWeight: 700, cursor: "pointer", letterSpacing: 1, marginBottom: 20, boxSizing: "border-box" }}
            onClick={() => { const c = generateCode(); setRoomInput(c); enterRoom(c); }}>
            CREATE NEW ROOM
          </button>

          {recentRooms.length > 0 && (
            <div style={{ marginBottom: 20 }}>
              <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>RECENT ROOMS</div>
              <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
                {recentRooms.map((r) => (
                  <button key={r} style={{ padding: "6px 12px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", fontSize: 12, fontWeight: 700, letterSpacing: 2, cursor: "pointer" }}
                    onClick={() => enterRoom(r)}>{r}</button>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  if (!loaded) {
    return <div style={S.container}><div style={{ ...S.loading, display: "flex", flexDirection: "column", alignItems: "center", gap: 12 }}><img src={LOGO_ICON} alt="Formula" style={{ width: 48, height: 48, borderRadius: 10, opacity: 0.6 }} /><span style={{ opacity: 0.4 }}>Loading...</span></div></div>;
  }


  // ── HOME SCREEN ─────────────────────────────────────
  if (screen === "home") {
    return (
      <div style={S.container}>
        <div style={S.header}>
          <div style={S.logoRow}>
            <img src={LOGO_ICON} alt="Formula" style={{ width: 30, height: 30, borderRadius: 6 }} />
          </div>
          <button style={{ background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#007bff", padding: "6px 12px", fontSize: 11, fontWeight: 700, letterSpacing: 2, cursor: "pointer" }}
            onClick={() => { setRoomCode(null); setLoaded(false); setMatches([]); setSavedTeams([]); setScoutSessions([]); setPractices([]); setCurrentMatch(null); setScreen("home"); setActiveTeamId(null); setRoomInput(""); }}>
            {roomCode}
          </button>
        </div>

        <div style={S.pad}>
          <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 14 }}>
            <h3 style={{ ...S.sectionTitle, margin: 0 }}>My Teams</h3>
            <button style={S.addTeamBtn} onClick={createTeam}>+ New Team</button>
          </div>

          {savedTeams.length === 0 ? (
            <div style={S.emptyTeam}>
              <p style={{ margin: 0, fontSize: 14, opacity: 0.5 }}>No teams yet</p>
              <p style={{ margin: "4px 0 0", fontSize: 12, opacity: 0.35 }}>Create a team to start tracking stats</p>
            </div>
          ) : (
            savedTeams.map((team) => {
              const playerCount = ((team.players||[])).filter((p) => p.number).length;
              const teamMatches = matches.filter((m) => m.teamId === team.id);
              if (matches.length > 0 && teamMatches.length === 0) {
                console.log("[Debug] Team has 0 matches. team.id:", JSON.stringify(team.id), "typeof:", typeof team.id);
                console.log("[Debug] All match teamIds:", matches.map((m) => ({ teamId: m.teamId, type: typeof m.teamId })));
              }
              const setsW = teamMatches.reduce((t, m) => t + ((m.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length, 0);
              const setsL = teamMatches.reduce((t, m) => t + ((m.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length, 0);
              return (
                <div key={team.id} style={{ ...S.teamCard, cursor: "pointer" }}
                  onClick={() => { setActiveTeamId(team.id); navigate("teamHome"); }}>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <span style={{ fontWeight: 700, fontSize: 16 }}>{team.name}</span>
                    {teamMatches.length > 0 && (
                      <span style={{ fontSize: 12, fontWeight: 700, color: setsW >= setsL ? "#22c55e" : "#ef4444" }}>{setsW}W - {setsL}L</span>
                    )}
                  </div>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 6 }}>
                    <div style={{ display: "flex", flexWrap: "wrap", gap: 4 }}>
                      {((team.players||[])).filter((p) => p.number).slice(0, 6).map((p, i) => (
                        <span key={i} style={S.rosterChip}>#{p.number}</span>
                      ))}
                      {playerCount > 6 && <span style={{ ...S.rosterChip, opacity: 0.4 }}>+{playerCount - 6}</span>}
                    </div>
                    <span style={{ fontSize: 11, opacity: 0.3 }}>{teamMatches.length} match{teamMatches.length !== 1 ? "es" : ""}</span>
                  </div>
                </div>
              );
            })
          )}

          {/* Quick match without team */}
          <button style={{ ...S.newMatchBtn, marginTop: 16 }} onClick={() => { setCurrentMatch(emptyMatch()); setSetupStep("roster"); navigate("setup"); }}>
            + Quick Match
          </button>
        </div>
      </div>
    );
  }

  // ── TEAM HOMEPAGE SCREEN ────────────────────────────
  if (screen === "teamHome" && activeTeamId) {
    const team = savedTeams.find((t) => t.id === activeTeamId);
    if (!team) { console.log("[Debug] Team not found, id:", activeTeamId, "savedTeams:", savedTeams.map(t => t.id)); setScreen("home"); return null; }
    const teamMatches = matches.filter((m) => m.teamId === team.id);
    const teamPractices = practices.filter((p) => p.teamId === team.id);
    const rosterP = (team.players || []).filter((p) => p.number);
    console.log("[Debug] Team homepage:", team.name, "id:", team.id, "teamMatches:", teamMatches.length, "players:", rosterP.length);

    try {

    // Compute Winning Formula for this team
    const teamSetRows = [];
    for (const m of teamMatches) {
      for (const s of (m.sets || [])) {
        if (s.complete) teamSetRows.push({ set: s, won: s.ourScore > s.theirScore });
      }
    }
    const teamFormula = computeWinningFormula(teamSetRows);

    // Cumulative player stats across all team matches
    // Build player ID → canonical key mapping to deduplicate across matches
    const pidToCanonical = {};  // playerId → "number_name"
    const canonicalInfo = {};   // "number_name" → { name, number, position }
    for (const m of teamMatches) {
      for (const p of (m.roster || [])) {
        if (!p.number) continue;
        const key = `${p.number}_${(p.name || "").trim().toLowerCase()}`;
        pidToCanonical[p.id] = key;
        if (!canonicalInfo[key]) canonicalInfo[key] = { name: p.name, number: p.number, position: p.position };
      }
    }
    const playerSeasonStats = {};
    for (const m of teamMatches) {
      for (const s of (m.sets || [])) {
        for (const ev of (s.events || [])) {
          if (ev.stat === "serve_in") continue;
          const pid = ev.player;
          const key = pidToCanonical[pid] || pid;
          if (!playerSeasonStats[key]) playerSeasonStats[key] = {};
          playerSeasonStats[key][ev.stat] = (playerSeasonStats[key][ev.stat] || 0) + 1;
        }
      }
    }

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={goBack}>‹</button>
          <h1 style={{ ...S.headerTitle, flex: 1 }}>{team.name}</h1>
          <button style={{ background: "none", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", padding: "6px 10px", cursor: "pointer", fontSize: 13 }}
            onClick={() => { setEditingTeam({ ...team, players: [...team.players] }); navigate("editTeam"); }}>
            Settings
          </button>
        </div>

        <div style={S.pad}>
          {/* Record summary */}
          <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 8, marginBottom: 16 }}>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800 }}>{teamMatches.length}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>MATCHES</div>
            </div>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{teamFormula.wonSets}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>SETS WON</div>
            </div>
            <div style={{ ...S.card, textAlign: "center", padding: 10 }}>
              <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{teamFormula.lostSets}</div>
              <div style={{ fontSize: 9, opacity: 0.5 }}>SETS LOST</div>
            </div>
          </div>

          {/* WINNING FORMULA */}
          <div style={S.card}>
            <h3 style={S.cardTitle}>WINNING FORMULA</h3>
            {!teamFormula.hasEnoughData ? (
              <div style={{ textAlign: "center", padding: "12px 8px" }}>
                <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 12 }}>
                  BUILDING YOUR FORMULA
                </div>
                <div style={{ display: "flex", alignItems: "center", gap: 6, justifyContent: "center", marginBottom: 12 }}>
                  {[1,2,3,4,5,6,7,8].map((n) => (
                    <div key={n} style={{
                      width: 28, height: 28, borderRadius: 6,
                      background: n <= (teamFormula.totalSets || 0) ? "#007bff" : "#1e1e28",
                      border: n <= (teamFormula.totalSets || 0) ? "none" : "1px solid #2a2a34",
                      display: "flex", alignItems: "center", justifyContent: "center",
                      fontSize: 11, fontWeight: 800,
                      color: n <= (teamFormula.totalSets || 0) ? "#fff" : "#4b5563",
                    }}>{n}</div>
                  ))}
                </div>
                <div style={{ fontSize: 12, opacity: 0.5, marginBottom: 4 }}>
                  {teamFormula.totalSets || 0} of 8 sets completed
                </div>
                <div style={{ fontSize: 11, opacity: 0.35 }}>
                  {(teamFormula.totalSets || 0) === 0
                    ? "Your winning formula is built from patterns in your wins and losses. Start tracking matches to unlock it."
                    : (teamFormula.wonSets || 0) === 0 || (teamFormula.lostSets || 0) === 0
                      ? "Need both wins and losses to find the patterns. Keep competing."
                      : `${Math.max(0, 8 - (teamFormula.totalSets || 0))} more set${8 - (teamFormula.totalSets || 0) === 1 ? "" : "s"} to go.`}
                </div>
              </div>
            ) : (
              <>
                <p style={S.cardSub}>
                  {teamFormula.tier === "established"
                    ? `Well-established across ${teamFormula.totalSets} sets. These priorities reflect consistent patterns.`
                    : `Taking shape based on ${teamFormula.totalSets} sets. Priorities becoming clearer with more data.`}
                  {" "}Strength: {teamFormula.formulaStrength}%
                </p>
                {teamFormula.narrative && (
                  <div style={{ fontSize: 11, fontStyle: "italic", opacity: 0.6, textAlign: "center", marginBottom: 8, padding: "0 4px" }}>
                    {teamFormula.narrative}
                  </div>
                )}
                {/* Priority variables */}
                {teamFormula.variables.filter(v => v.priorityZone !== "low_relationship").slice(0, 5).map((v) => {
                  const zoneColor = v.priorityZone === "high_impact" ? "#ef4444" : v.priorityZone === "moderate_impact" ? "#eab308" : "#22c55e";
                  const zoneLabel = v.priorityZone === "high_impact" ? "PRIORITY" : v.priorityZone === "moderate_impact" ? "SECONDARY" : "ON TARGET";
                  return (
                    <div key={v.name} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "6px 0", borderBottom: "1px solid #1a1a24" }}>
                      <div>
                        <span style={{ fontWeight: 700, fontSize: 12 }}>{v.displayName}</span>
                        <span style={{ fontSize: 7, fontWeight: 800, color: zoneColor, background: zoneColor + "22", padding: "1px 4px", borderRadius: 3, marginLeft: 6 }}>{zoneLabel}</span>
                      </div>
                      <div style={{ display: "flex", gap: 8, alignItems: "center" }}>
                        <span style={{ fontSize: 11, opacity: 0.5 }}>avg {v.format(v.currentAvg)}</span>
                        {v.threshold !== null && <span style={{ fontSize: 14, fontWeight: 800, color: zoneColor }}>{v.format(v.threshold)}</span>}
                        {v.threshold !== null && <span style={{ fontSize: 9, opacity: 0.3 }}>target</span>}
                      </div>
                    </div>
                  );
                })}
                {/* Headline */}
                {teamFormula.headline && (
                  <div style={{ ...S.insightBox, marginTop: 8 }}>
                    <div style={S.insightLabel}>TOP OPPORTUNITY</div>
                    <div style={{ fontSize: 11, opacity: 0.8 }}>{teamFormula.headline.message}</div>
                  </div>
                )}
              </>
            )}
          </div>

          {/* ACTION BUTTONS */}
          <div style={{ display: "flex", gap: 8, marginBottom: 8, marginTop: 4 }}>
            <button style={{ ...S.primaryBtn, flex: 1, margin: 0 }} onClick={() => startMatchWithTeam(team)}>
              New Match
            </button>
            <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#0056b3" }} onClick={() => {
              const practice = {
                id: Date.now().toString(), teamId: team.id, teamName: team.name,
                date: new Date().toISOString().split("T")[0],
                name: "Practice " + new Date().toLocaleDateString(), rounds: [],
              };
              setCurrentPractice(practice);
              setPracticeRound(null);
              setPracticePasserPick(true);
              navigate("practice");
            }}>
              Practice
            </button>
          </div>

          {/* PLAYER STATS */}
          {Object.keys(playerSeasonStats).length > 0 && (() => {
            // Build reverse map: canonical key → all player IDs that map to it
            const canonicalToPids = {};
            for (const [pid, key] of Object.entries(pidToCanonical)) {
              if (!canonicalToPids[key]) canonicalToPids[key] = [];
              if (!canonicalToPids[key].includes(pid)) canonicalToPids[key].push(pid);
            }
            // Compute season PIR for each canonical player
            const seasonMult = (() => {
              const rawMult = _deriveMultipliers(teamFormula);
              return _getEffectiveMultipliers(teamFormula?.totalSets || 0, rawMult);
            })();
            const allSeasonEvents = [];
            for (const m of teamMatches) for (const s of (m.sets || [])) for (const ev of (s.events || [])) allSeasonEvents.push(ev);
            const seasonPIS = {};
            for (const canonKey of Object.keys(playerSeasonStats)) {
              const pids = canonicalToPids[canonKey] || [canonKey];
              // Calculate impact across all player IDs for this canonical player
              const playerEvents = allSeasonEvents.filter(ev => pids.includes(ev.player));
              const breakdown = { offense: 0, serving: 0, passing: 0, blocking: 0, defense: 0, cover: 0, setting: 0 };
              for (const ev of playerEvents) {
                const stat = ev.stat;
                let weight = 0;
                if (stat === "serve_in") { const fp = ev.forcedPass ?? ev.metadata?.forcedPass; weight = IMPACT_WEIGHTS.serve_in[fp] ?? 0; }
                else if (stat === "reception") { const q = ev.quality ?? ev.metadata?.quality; weight = IMPACT_WEIGHTS.reception[q] ?? 0; }
                else if (typeof IMPACT_WEIGHTS[stat] === "number") weight = IMPACT_WEIGHTS[stat];
                else continue;
                if (!TERMINAL_EVENTS.has(stat)) { const cat = _getStatCategory(stat); weight *= (seasonMult[cat] ?? 1.0); }
                const cat = _getStatCategory(stat);
                breakdown[cat] = (breakdown[cat] || 0) + weight;
              }
              const total = Object.values(breakdown).reduce((s, v) => s + v, 0);
              seasonPIS[canonKey] = { total: Math.round(total * 100) / 100, breakdown };
            }
            return (
            <div style={S.card}>
              <h3 style={S.cardTitle}>SEASON PLAYER STATS</h3>
              <p style={S.cardSub}>Cumulative across {teamMatches.length} match{teamMatches.length !== 1 ? "es" : ""}</p>
              <div style={{ overflowX: "auto" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>PIR</th>
                      <th style={S.sth}>K</th>
                      <th style={S.sth}>AE</th>
                      <th style={S.sth}>ATT</th>
                      <th style={S.sth}>PCT</th>
                      <th style={S.sth}>A</th>
                      <th style={S.sth}>SA</th>
                      <th style={S.sth}>SE</th>
                      <th style={S.sth}>DIG</th>
                      <th style={S.sth}>CV</th>
                      <th style={S.sth}>BS</th>
                      <th style={S.sth}>BE</th>
                    </tr>
                  </thead>
                  <tbody>
                    {Object.entries(playerSeasonStats)
                      .map(([canonKey, stats]) => {
                        const info = canonicalInfo[canonKey] || {};
                        const pName = info.name?.split(" ")[0] || canonKey;
                        const pNum = info.number || "";
                        const k = stats.kill || 0, e = stats.attack_error || 0, blkd = stats.attack_blocked || 0;
                        const att = k + e + blkd;
                        const pct = att > 0 ? (k - e) / att : null;
                        const pis = seasonPIS[canonKey] || { total: 0 };
                        return { pid: canonKey, pName, pNum, k, e, att, pct, pis: pis.total, a: stats.assist || 0, sa: stats.ace || 0, se: stats.serve_error || 0, dig: stats.dig || 0, cvr: stats.cvr || 0, bs: stats.stuff_block || 0, be: stats.ball_error || 0 };
                      })
                      .sort((a, b) => b.pis - a.pis)
                      .map((p) => (
                        <tr key={p.pid}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap", textAlign: "left" }}>{p.pName} <span style={{ opacity: 0.4, fontWeight: 400 }}>#{p.pNum}</span></td>
                          <td style={{ ...S.std, fontWeight: 800, color: p.pis > 0 ? "#22c55e" : p.pis < 0 ? "#ef4444" : "#6b7280" }}>{p.pis > 0 ? "+" : ""}{p.pis.toFixed(1)}</td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{p.k}</td>
                          <td style={{ ...S.std, color: "#ef4444" }}>{p.e}</td>
                          <td style={S.std}>{p.att}</td>
                          <td style={{ ...S.std, fontWeight: 700, color: p.pct !== null ? (p.pct >= 0.2 ? "#22c55e" : p.pct >= 0 ? "#fff" : "#ef4444") : "#6b7280" }}>
                            {p.pct !== null ? (p.pct >= 0 ? "." : "-.") + Math.abs(Math.round(p.pct * 1000)).toString().padStart(3, "0") : "-"}
                          </td>
                          <td style={S.std}>{p.a || "-"}</td>
                          <td style={S.std}>{p.sa || "-"}</td>
                          <td style={S.std}>{p.se || "-"}</td>
                          <td style={S.std}>{p.dig || "-"}</td>
                          <td style={{ ...S.std, color: "#60a5fa" }}>{p.cvr || "-"}</td>
                          <td style={S.std}>{p.bs || "-"}</td>
                          <td style={{ ...S.std, color: p.be > 0 ? "#ef4444" : "#6b7280" }}>{p.be || "-"}</td>
                        </tr>
                      ))}
                  </tbody>
                </table>
              </div>
            </div>
            );
          })()}

          {/* SCOUT OPPONENT */}
          <div style={{ marginBottom: 16 }}>
            <h3 style={S.sectionTitle}>Scout Opponent</h3>
            <div style={{ display: "flex", gap: 6, marginBottom: 10 }}>
              <input
                style={{ ...S.input, flex: 1, margin: 0 }}
                placeholder="Opponent name..."
                value={scoutNameInput}
                onChange={(e) => setScoutNameInput(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === "Enter" && scoutNameInput.trim()) {
                    const session = { id: Date.now().toString(), name: scoutNameInput.trim(), shots: [], created: new Date().toISOString().split("T")[0], teamId: activeTeamId };
                    setCurrentScout(session);
                    setScoutView("input");
                    setScoutPending(null);
                    setScoutNameInput("");
                    navigate("scout");
                  }
                }}
              />
              <button style={S.addTeamBtn} onClick={() => {
                if (!scoutNameInput.trim()) { showToast("Enter opponent name"); return; }
                const session = { id: Date.now().toString(), name: scoutNameInput.trim(), shots: [], created: new Date().toISOString().split("T")[0], teamId: activeTeamId };
                setCurrentScout(session);
                setScoutView("input");
                setScoutPending(null);
                setScoutNameInput("");
                navigate("scout");
              }}>+ Scout</button>
            </div>
            {scoutSessions.map((s) => {
              const kills = (s.shots || []).filter((sh) => sh.outcome === "kill").length;
              const total = (s.shots || []).length;
              return (
                <div key={s.id} style={S.teamCard}>
                  <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                    <div>
                      <span style={{ fontWeight: 700, fontSize: 14 }}>{s.name}</span>
                      <span style={{ fontSize: 11, opacity: 0.4, marginLeft: 8 }}>{s.created}</span>
                    </div>
                    <span style={{ fontSize: 11, opacity: 0.5 }}>{total} shots</span>
                  </div>
                  <div style={{ display: "flex", gap: 6, marginTop: 8 }}>
                    <button style={S.teamActionBtn} onClick={() => {
                      setCurrentScout({ ...s });
                      setScoutView(total > 0 ? "heatmap" : "input");
                      setScoutPending(null);
                      navigate("scout");
                    }}>
                      {total > 0 ? "View / Edit" : "Start Scouting"}
                    </button>
                    <button style={{ ...S.teamActionBtn, background: "#1a1a24", color: "#ef4444" }}
                      onClick={() => { saveScoutSessions(scoutSessions.filter((x) => x.id !== s.id)); showToast("Deleted"); }}>
                      Remove
                    </button>
                  </div>
                </div>
              );
            })}
          </div>

          {/* RECENT MATCHES */}
          <h3 style={S.sectionTitle}>Match History</h3>
          {teamMatches.length === 0 ? (
            <div style={{ textAlign: "center", padding: 20, opacity: 0.4, fontSize: 13 }}>No matches yet</div>
          ) : (
            teamMatches.slice().reverse().map((m) => {
              const setScores = ((m.sets||[])).map((s) => `${s.ourScore}-${s.theirScore}`).join(", ");
              const won = ((m.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length;
              const lost = ((m.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length;
              const isComplete = m.complete;
              const matchWon = won > lost;
              return (
                <div key={m.id} style={{ ...S.card, marginBottom: 8, display: "flex", alignItems: "center", gap: 8, borderLeft: isComplete ? `3px solid ${matchWon ? "#22c55e" : "#ef4444"}` : "3px solid #007bff" }}>
                  <div style={{ flex: 1, cursor: "pointer" }}
                    onClick={() => {
                      const setIdx = Math.max(0, ((m.sets||[])).length - 1);
                      const resumeSet = m.sets?.[setIdx];
                      
                      // Lineup integrity check and repair
                      let repairedMatch = m;
                      if (resumeSet) {
                        const lineup = resumeSet.currentLineup || {};
                        const starting = resumeSet.startingLineup || {};
                        const rosterIds = (m.roster||[]).map(p => p.id);
                        const missingZones = [1,2,3,4,5,6].filter(z => !lineup[z] || !rosterIds.includes(lineup[z]));
                        
                        console.log("[RESUME] Set", setIdx, "lineup:", JSON.stringify(lineup), "starting:", JSON.stringify(starting));
                        console.log("[RESUME] lib1:", resumeSet.libero1Id, "lib2:", resumeSet.libero2Id);
                        console.log("[RESUME] rosterIds:", rosterIds);
                        console.log("[RESUME] missingZones:", missingZones);
                        console.log("[RESUME] posOverrides:", JSON.stringify(resumeSet.positionOverrides));
                        
                        if (missingZones.length > 0) {
                          let rebuilt = null;
                          
                          if (Object.keys(starting).length === 6) {
                            // Rebuild from complete starting lineup + rotation count
                            const rotCount = (resumeSet.rotation || 1) - 1;
                            rebuilt = { ...starting };
                            for (let i = 0; i < rotCount; i++) rebuilt = rotate(rebuilt);
                            console.warn("[RESUME REPAIR] Rebuilt from startingLineup + rotation", rotCount);
                          } else if (Object.keys(lineup).length >= 4) {
                            // Partial lineup — fill in missing from positionOverrides
                            const posO = resumeSet.positionOverrides || {};
                            const starterIds = Object.keys(posO);
                            if (starterIds.length === 6) {
                              rebuilt = { ...lineup };
                              const inLineup = new Set(Object.values(rebuilt));
                              const missing = starterIds.filter(id => !inLineup.has(id));
                              const emptyZones = [1,2,3,4,5,6].filter(z => !rebuilt[z]);
                              for (let i = 0; i < missing.length && i < emptyZones.length; i++) {
                                rebuilt[emptyZones[i]] = missing[i];
                              }
                              console.warn("[RESUME REPAIR] Filled missing players from posOverrides:", missing, "→ zones:", emptyZones);
                            }
                          }
                          
                          if (rebuilt && Object.keys(rebuilt).length === 6) {
                            // Also repair startingLineup if needed
                            let repairedStarting = starting;
                            if (Object.keys(starting).length < 6) {
                              const posO = resumeSet.positionOverrides || {};
                              const starterIds = Object.keys(posO);
                              if (starterIds.length === 6) {
                                repairedStarting = { ...starting };
                                const inStarting = new Set(Object.values(repairedStarting));
                                const missingS = starterIds.filter(id => !inStarting.has(id));
                                const emptyS = [1,2,3,4,5,6].filter(z => !repairedStarting[z]);
                                for (let i = 0; i < missingS.length && i < emptyS.length; i++) {
                                  repairedStarting[emptyS[i]] = missingS[i];
                                }
                              }
                            }
                            
                            const repairedSets = [...m.sets];
                            repairedSets[setIdx] = { ...resumeSet, currentLineup: rebuilt, startingLineup: repairedStarting };
                            repairedMatch = { ...m, sets: repairedSets };
                            console.warn("[RESUME REPAIR] Final lineup:", JSON.stringify(rebuilt));
                          }
                        }
                        
                        // Restore position overrides and MB map
                        if (resumeSet.positionOverrides && Object.keys(resumeSet.positionOverrides).length > 0) {
                          setLineupPositions(resumeSet.positionOverrides);
                        }
                        if (resumeSet.mbBackRowMap && Object.keys(resumeSet.mbBackRowMap).length > 0) {
                          setMbBackRowMap(resumeSet.mbBackRowMap);
                        }
                      }
                      
                      setCurrentMatch(repairedMatch);
                      setCurrentSetIdx(setIdx);
                      if (isComplete) {
                        navigate("matchComplete");
                      } else {
                        setTab("court");
                        navigate("match");
                      }
                    }}>
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center" }}>
                      <div>
                        <span style={{ fontWeight: 700, fontSize: 14 }}>vs {m.opponent || "\u2014"}</span>
                        {!isComplete && <span style={{ fontSize: 9, fontWeight: 800, color: "#007bff", marginLeft: 6, padding: "1px 5px", border: "1px solid #007bff", borderRadius: 4 }}>LIVE</span>}
                        <span style={{ fontSize: 11, opacity: 0.4, marginLeft: 8 }}>{m.date}</span>
                      </div>
                      <div style={{ textAlign: "right" }}>
                        <div style={{ fontWeight: 800, color: won > lost ? "#22c55e" : won < lost ? "#ef4444" : "#007bff" }}>
                          {won}-{lost}
                        </div>
                        {isComplete && <div style={{ fontSize: 9, fontWeight: 700, color: matchWon ? "#22c55e" : "#ef4444" }}>{matchWon ? "W" : "L"}</div>}
                      </div>
                    </div>
                    <div style={{ fontSize: 11, opacity: 0.5, marginTop: 4 }}>{setScores}</div>
                  </div>
                  <button style={{ background: "none", border: "none", color: "#ef4444", fontSize: 18, padding: "4px 8px", cursor: "pointer", opacity: 0.4, flexShrink: 0 }}
                    onClick={(e) => { e.stopPropagation(); if (confirm(`Delete match vs ${m.opponent || "—"}?`)) deleteMatch(m.id); }}>
                    ✕
                  </button>
                </div>
              );
            })
          )}

          {/* Practice history */}
          {teamPractices.length > 0 && (
            <>
              <h3 style={{ ...S.sectionTitle, marginTop: 16 }}>Practice History</h3>
              {teamPractices.slice().reverse().map((p) => {
                const totalPasses = ((p.rounds||[])).reduce((t, r) => t + (r.events||[]).length, 0);
                return (
                  <div key={p.id} style={{ ...S.card, marginBottom: 8, display: "flex", alignItems: "center", gap: 8 }}>
                    <div style={{ flex: 1, cursor: "pointer" }}
                      onClick={() => { setCurrentPractice(p); setPracticeRound(null); setPracticePasserPick(true); navigate("practice"); }}>
                      <div style={{ display: "flex", justifyContent: "space-between" }}>
                        <span style={{ fontWeight: 700 }}>{p.name}</span>
                        <span style={{ fontSize: 11, opacity: 0.4 }}>{p.date}</span>
                      </div>
                      <div style={{ fontSize: 11, opacity: 0.5, marginTop: 2 }}>{((p.rounds||[])).length} rounds / {totalPasses} passes</div>
                    </div>
                    <button style={{ background: "none", border: "none", color: "#ef4444", fontSize: 18, padding: "4px 8px", cursor: "pointer", opacity: 0.4, flexShrink: 0 }}
                      onClick={(e) => { e.stopPropagation(); if (confirm(`Delete practice "${p.name}"?`)) deletePractice(p.id); }}>
                      ✕
                    </button>
                  </div>
                );
              })}
            </>
          )}
        </div>
      </div>
    );
    } catch (err) {
      console.error("[TeamHome] Render error:", err);
      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={goBack}>‹</button>
            <h1 style={S.headerTitle}>Error</h1>
          </div>
          <div style={S.pad}>
            <p style={{ color: "#ef4444" }}>Error loading team page. Check browser console for details.</p>
            <p style={{ fontSize: 12, opacity: 0.5, marginTop: 8 }}>{String(err)}</p>
          </div>
        </div>
      );
    }
  }

  // ── EDIT TEAM SCREEN ────────────────────────────────
  if (screen === "editTeam" && editingTeam) {
    const playerCount = editingTeam.players.filter((p) => p.number).length;
    return (
      <div style={S.container}>
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => { setEditingTeam(null); goBack(); }}>‹</button>
          <h1 style={S.headerTitle}>{editingTeam.name ? `Edit: ${editingTeam.name}` : "New Team"}</h1>
        </div>
        <div style={S.pad}>
          <div style={{ marginBottom: 16 }}>
            <label style={S.label}>Team Name</label>
            <input style={S.input} placeholder="e.g. Pulse 18s, SJB Varsity"
              value={editingTeam.name}
              onChange={(e) => setEditingTeam((prev) => ({ ...prev, name: e.target.value }))} />
          </div>

          <h3 style={S.sectionTitle}>Players ({playerCount})</h3>
          <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
            {editingTeam.players.map((p, i) => (
              <div key={i} style={{ display: "flex", gap: 6, alignItems: "center" }}>
                <input style={{ ...S.input, width: 50, textAlign: "center", padding: "8px 4px" }}
                  placeholder="#" value={p.number} inputMode="numeric"
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, number: val } : pl);
                      return { ...prev, players };
                    });
                  }} />
                <input style={{ ...S.input, flex: 1 }} placeholder="Name" value={p.name}
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, name: val } : pl);
                      return { ...prev, players };
                    });
                  }} />
                <select style={{ ...S.input, width: 62, padding: "8px 2px" }} value={p.position}
                  onChange={(e) => {
                    const val = e.target.value;
                    setEditingTeam((prev) => {
                      const players = prev.players.map((pl, j) => j === i ? { ...pl, position: val } : pl);
                      return { ...prev, players };
                    });
                  }}>
                  <option value="">Pos</option>
                  {POSITIONS.map((pos) => <option key={pos} value={pos}>{pos}</option>)}
                </select>
              </div>
            ))}
          </div>

          {/* Add more player rows */}
          <button style={{ ...S.clearBtn, marginTop: 12, borderStyle: "dashed" }}
            onClick={() => {
              setEditingTeam((prev) => ({
                ...prev,
                players: [...prev.players, ...Array.from({ length: 2 }, (_, i) => ({
                  id: `t${Date.now()}-px${prev.players.length + i}`,
                  number: "",
                  name: "",
                  position: "",
                }))],
              }));
            }}>
            + Add More Rows
          </button>

          <button style={{ ...S.primaryBtn, marginTop: 20 }} onClick={saveCurrentTeam}>
            Save Team
          </button>
        </div>
      </div>
    );
  }

  // ── SETUP SCREENS ───────────────────────────────────
  // ── MATCH COMPLETE SCREEN ────────────────────────────
  if (screen === "matchComplete") {
    const completedSets = (currentMatch?.sets || []).filter((s) => s.complete);
    const setsWon = completedSets.filter((s) => s.ourScore > s.theirScore).length;
    const setsLost = completedSets.filter((s) => s.ourScore < s.theirScore).length;
    const weWon = setsWon > setsLost;
    const rosterPlayers = ((currentMatch?.roster||[])).filter((p) => p.number);

    // Aggregate all player stats from completed sets
    const playerMatchStats = {};
    for (const s of completedSets) {
      for (const ev of (s.events || [])) {
        if (ev.stat === "serve_in") continue;
        const pid = ev.player;
        if (!pid) continue;
        if (!playerMatchStats[pid]) playerMatchStats[pid] = {};
        playerMatchStats[pid][ev.stat] = (playerMatchStats[pid][ev.stat] || 0) + 1;
      }
    }

    // Player Impact Ratings across all sets
    const mult = (() => {
      // Build formula for this match's team data only
      const teamId = currentMatch?.teamId;
      const allSetRows = [];
      for (const m of matches) {
        if (teamId && m.teamId !== teamId) continue;
        for (const s of (m.sets || [])) {
          if (s.complete) allSetRows.push({ set: s, won: s.ourScore > s.theirScore });
        }
      }
      const fa = computeWinningFormula(allSetRows);
      const rawMult = _deriveMultipliers(fa);
      return _getEffectiveMultipliers(fa?.totalSets || 0, rawMult);
    })();
    const matchPIS = {};
    for (const p of rosterPlayers) {
      const allEvts = [];
      for (const s of completedSets) for (const ev of (s.events || [])) allEvts.push(ev);
      matchPIS[p.id] = calculatePlayerImpact(allEvts, p.id, mult);
    }

    // Find MVP (highest PIS)
    let mvpId = null, mvpPIS = -Infinity;
    for (const [pid, pis] of Object.entries(matchPIS)) {
      if (pis.total > mvpPIS) { mvpPIS = pis.total; mvpId = pid; }
    }
    const mvpPlayer = rosterPlayers.find((p) => p.id === mvpId);
    const mvpStats = playerMatchStats[mvpId] || {};

    return (
      <div style={S.container}>
        <div style={S.header}>
          <button style={S.backBtn} onClick={goBack}>‹</button>
          <h1 style={S.headerTitle}>Match Complete</h1>
        </div>
        <div style={S.pad}>
          {/* Result banner */}
          <div style={{
            ...S.card, textAlign: "center", padding: 24, marginBottom: 16,
            borderLeft: `4px solid ${weWon ? "#22c55e" : "#ef4444"}`,
          }}>
            <div style={{ fontSize: 13, opacity: 0.5, marginBottom: 4 }}>vs {currentMatch?.opponent}</div>
            <div style={{
              fontSize: 40, fontWeight: 900, letterSpacing: 2,
              color: weWon ? "#22c55e" : "#ef4444",
            }}>
              {weWon ? "WIN" : "LOSS"}
            </div>
            <div style={{ fontSize: 28, fontWeight: 800, margin: "8px 0" }}>
              {setsWon} - {setsLost}
            </div>
            <div style={{ fontSize: 12, opacity: 0.5 }}>
              {completedSets.map((s) => `${s.ourScore}-${s.theirScore}`).join("  |  ")}
            </div>
            {currentMatch?.tournament && (
              <div style={{ fontSize: 11, opacity: 0.4, marginTop: 6 }}>{currentMatch.tournament}</div>
            )}
          </div>

          {/* MVP */}
          {mvpPlayer && (() => {
            const mvpPisObj = matchPIS[mvpId] || { total: 0, breakdown: {} };
            const cats = [
              { key: "offense", label: "OFF", color: "#22c55e" },
              { key: "serving", label: "SRV", color: "#007bff" },
              { key: "passing", label: "PAS", color: "#eab308" },
              { key: "blocking", label: "BLK", color: "#a855f7" },
              { key: "defense", label: "DEF", color: "#60a5fa" },
              { key: "cover", label: "CVR", color: "#14b8a6" },
              { key: "setting", label: "SET", color: "#f472b6" },
            ];
            const maxAbs = Math.max(1, ...Object.values(mvpPisObj.breakdown).map(Math.abs));
            return (
            <div style={{ ...S.card, padding: 16, marginBottom: 16, borderLeft: "4px solid #007bff" }}>
              <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 6 }}>MATCH MVP</div>
              <div style={{ display: "flex", alignItems: "center", gap: 12 }}>
                <div>
                  <div style={{ fontSize: 18, fontWeight: 800 }}>{mvpPlayer.name?.split(" ")[0]}</div>
                  <div style={{ fontSize: 11, opacity: 0.5 }}>#{mvpPlayer.number} {mvpPlayer.position}</div>
                </div>
                <div style={{ marginLeft: "auto", textAlign: "right" }}>
                  <div style={{ fontSize: 20, fontWeight: 800, color: mvpPIS > 0 ? "#22c55e" : "#ef4444" }}>
                    {mvpPIS > 0 ? "+" : ""}{mvpPIS.toFixed(1)}
                  </div>
                  <div style={{ fontSize: 9, opacity: 0.4 }}>PIR</div>
                </div>
              </div>
              <div style={{ display: "flex", gap: 8, marginTop: 8, flexWrap: "wrap" }}>
                {mvpStats.kill > 0 && <span style={{ fontSize: 11, color: "#22c55e", fontWeight: 700 }}>{mvpStats.kill}K</span>}
                {mvpStats.ace > 0 && <span style={{ fontSize: 11, color: "#007bff", fontWeight: 700 }}>{mvpStats.ace}A</span>}
                {mvpStats.stuff_block > 0 && <span style={{ fontSize: 11, color: "#22c55e", fontWeight: 700 }}>{mvpStats.stuff_block}SB</span>}
                {mvpStats.dig > 0 && <span style={{ fontSize: 11, fontWeight: 700 }}>{mvpStats.dig}D</span>}
                {mvpStats.cvr > 0 && <span style={{ fontSize: 11, color: "#14b8a6", fontWeight: 700 }}>{mvpStats.cvr}CV</span>}
                {mvpStats.assist > 0 && <span style={{ fontSize: 11, color: "#5ba3ff", fontWeight: 700 }}>{mvpStats.assist}AS</span>}
                {mvpStats.block > 0 && <span style={{ fontSize: 11, fontWeight: 700 }}>{mvpStats.block}BT</span>}
              </div>
              {/* Category breakdown bars */}
              <div style={{ display: "flex", gap: 2, height: 8, marginTop: 8 }}>
                {cats.map(c => {
                  const val = mvpPisObj.breakdown[c.key] || 0;
                  if (val === 0) return null;
                  const w = Math.max(4, Math.abs(val) / maxAbs * 100);
                  return <div key={c.key} style={{ height: "100%", borderRadius: 2, width: `${w}%`, background: val > 0 ? c.color : "#ef4444", opacity: 0.7 }} />;
                })}
              </div>
              <div style={{ display: "flex", gap: 6, marginTop: 3 }}>
                {cats.map(c => {
                  const val = mvpPisObj.breakdown[c.key] || 0;
                  if (val === 0) return null;
                  return <span key={c.key} style={{ fontSize: 8, color: c.color, opacity: 0.5 }}>{c.label} {val > 0 ? "+" : ""}{val.toFixed(1)}</span>;
                })}
              </div>
            </div>
            );
          })()}

          {/* Set-by-set breakdown */}
          <div style={{ ...S.card, padding: 16, marginBottom: 16 }}>
            <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 10 }}>SET BREAKDOWN</div>
            {completedSets.map((s) => {
              const won = s.ourScore > s.theirScore;
              const setTotals = {};
              for (const ev of (s.events || [])) {
                if (ev.stat !== "serve_in") setTotals[ev.stat] = (setTotals[ev.stat] || 0) + 1;
              }
              return (
                <div key={s.number} style={{
                  display: "flex", alignItems: "center", gap: 12, padding: "8px 0",
                  borderBottom: "1px solid #1e1e28",
                }}>
                  <div style={{ width: 50 }}>
                    <span style={{ fontSize: 11, opacity: 0.4 }}>Set {s.number}</span>
                  </div>
                  <div style={{ fontSize: 18, fontWeight: 800, width: 60, color: won ? "#22c55e" : "#ef4444" }}>
                    {s.ourScore}-{s.theirScore}
                  </div>
                  <div style={{ flex: 1, display: "flex", gap: 6, flexWrap: "wrap", fontSize: 10, opacity: 0.6 }}>
                    <span>{setTotals.kill || 0}K</span>
                    <span>{setTotals.attack_error || 0}AE</span>
                    <span>{setTotals.ace || 0}A</span>
                    <span>{setTotals.serve_error || 0}SE</span>
                    <span>{setTotals.stuff_block || 0}SB</span>
                    <span>{setTotals.dig || 0}D</span>
                  </div>
                </div>
              );
            })}
          </div>

          {/* Team stat summary */}
          <div style={{ ...S.card, padding: 16, marginBottom: 16 }}>
            <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 10 }}>MATCH TOTALS</div>
            {(() => {
              const t = {};
              for (const s of completedSets) {
                for (const ev of (s.events || [])) {
                  if (ev.stat !== "serve_in") t[ev.stat] = (t[ev.stat] || 0) + 1;
                }
              }
              const att = (t.kill||0) + (t.attack_error||0) + (t.attack_blocked||0);
              const pct = att > 0 ? ((t.kill||0) - (t.attack_error||0)) / att : null;
              return (
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 10 }}>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{t.kill || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>KILLS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{t.attack_error || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ATT ERR</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: pct !== null && pct >= 0.2 ? "#22c55e" : pct !== null && pct >= 0 ? "#fff" : "#ef4444" }}>
                      {pct !== null ? (pct >= 0 ? "." : "-.") + Math.abs(Math.round(pct * 1000)).toString().padStart(3, "0") : "-"}
                    </div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>HIT%</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{att}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ATT</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#007bff" }}>{t.ace || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ACES</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{t.serve_error || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>SRV ERR</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{t.dig || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>DIGS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#22c55e" }}>{t.stuff_block || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>STUFF BLK</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800 }}>{t.block || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>BLK TCH</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#5ba3ff" }}>{t.assist || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>ASSISTS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#60a5fa" }}>{t.cvr || 0}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>COVERS</div>
                  </div>
                  <div style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: "#ef4444" }}>{(t.ball_error || 0) + (t.attack_error || 0)}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>TOTAL ERR</div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Impact Rankings */}
          <div style={{ ...S.card, padding: 16, marginBottom: 16 }}>
            <div style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, marginBottom: 10 }}>IMPACT RANKINGS</div>
            {rosterPlayers
              .map(p => ({ player: p, pis: matchPIS[p.id] || { total: 0, breakdown: {} } }))
              .filter(r => r.pis.total !== 0)
              .sort((a, b) => b.pis.total - a.pis.total)
              .map((r, i) => {
                const { player: p, pis } = r;
                return (
                  <div key={p.id} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", padding: "5px 0", borderBottom: "1px solid #1a1a24" }}>
                    <span style={{ fontWeight: 700, fontSize: 12 }}>#{p.number} {p.name?.split(" ")[0]}</span>
                    <span style={{ fontWeight: 800, fontSize: 13, color: pis.total > 0 ? "#22c55e" : pis.total < 0 ? "#ef4444" : "#6b7280" }}>
                      {pis.total > 0 ? "+" : ""}{pis.total.toFixed(1)}
                    </span>
                  </div>
                );
              })}
          </div>

          {/* Actions */}
          <button style={{ ...S.primaryBtn, marginBottom: 10 }} onClick={() => {
            setTab("stats");
            navigate("match");
          }}>
            View Full Stats
          </button>
          <button style={{ ...S.clearBtn, marginBottom: 10 }} onClick={() => {
            navigate("teamHome");
          }}>
            Back to Team
          </button>
        </div>
      </div>
    );
  }

  if (screen === "setup") {
    const rosterPlayers = ((currentMatch?.roster||[])).filter((p) => p.number) || [];
    const assignedIds = Object.values(lineupSlots);
    const availableForLineup = rosterPlayers.filter((p) => !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2);
    const benchPlayers = rosterPlayers.filter((p) => !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2);

    // ROSTER
    if (setupStep === "roster") {
      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={goBack}>‹</button>
            <h1 style={S.headerTitle}>Roster</h1>
          </div>
          <div style={S.pad}>
            <div style={{ marginBottom: 16 }}>
              <label style={S.label}>Opponent</label>
              <input style={S.input} placeholder="Team name" value={currentMatch?.opponent || ""}
                onChange={(e) => setCurrentMatch((p) => ({ ...p, opponent: e.target.value }))} />
            </div>
            <h3 style={S.sectionTitle}>Players</h3>
            <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
              {((currentMatch?.roster||[])).map((p, i) => (
                <div key={i} style={{ display: "flex", gap: 6, alignItems: "center" }}>
                  <input style={{ ...S.input, width: 50, textAlign: "center", padding: "8px 4px" }}
                    placeholder="#" value={p.number} inputMode="numeric"
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, number: val } : pl);
                        return { ...prev, roster };
                      });
                    }} />
                  <input style={{ ...S.input, flex: 1 }} placeholder="Name" value={p.name}
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, name: val } : pl);
                        return { ...prev, roster };
                      });
                    }} />
                  <select style={{ ...S.input, width: 62, padding: "8px 2px" }} value={p.position}
                    onChange={(e) => {
                      const val = e.target.value;
                      setCurrentMatch((prev) => {
                        const roster = prev.roster.map((pl, j) => j === i ? { ...pl, position: val } : pl);
                        return { ...prev, roster };
                      });
                    }}>
                    <option value="">Pos</option>
                    {POSITIONS.map((pos) => <option key={pos} value={pos}>{pos}</option>)}
                  </select>
                </div>
              ))}
            </div>
            <button style={{ ...S.primaryBtn, marginTop: 20 }}
              onClick={() => { setLineupSlots({}); setLineupPositions({}); setSelectedLibero(null); setSelectedLibero2(null); setMbBackRowMap({}); setSelectingPos(null); setSelectingLibero(null); setSetupStep("lineup"); }}
              disabled={rosterPlayers.length < 6}>
              Set Lineup →
            </button>
          </div>
        </div>
      );
    }

    // LINEUP
    if (setupStep === "lineup") {

      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={() => setSetupStep("roster")}>‹</button>
            <h1 style={S.headerTitle}>Starting Lineup</h1>
          </div>
          <div style={S.pad}>
            {/* Court diagram */}
            <div style={S.courtSetup}>
              <div style={S.netLabel}>── NET ──</div>
              <div style={S.courtGrid}>
                {[4, 3, 2, 5, 6, 1].map((pos) => {
                  const player = lineupSlots[pos] ? getPlayerById(lineupSlots[pos]) || rosterPlayers.find(p => p.id === lineupSlots[pos]) : null;
                  const slot = COURT_POS[pos];
                  const effPos = player ? (lineupPositions[player.id] || player.position) : "";
                  return (
                    <button key={pos} style={{
                      ...S.courtSlot,
                      ...(selectingPos === pos ? S.courtSlotActive : {}),
                      ...(player ? S.courtSlotFilled : {}),
                    }}
                      onClick={() => { setSelectingPos(pos); setSelectingLibero(null); }}>
                      <span style={S.courtPosLabel}>{pos}</span>
                      {player ? (
                        <>
                          <span style={S.courtPlayerNum}>{player.name?.split(" ")[0] || player.position}</span>
                          <span style={{ fontSize: 9, color: "#007bff", fontWeight: 700 }}>{effPos}</span>
                          <span style={S.courtPlayerName}>#{player.number}</span>
                        </>
                      ) : (
                        <span style={{ fontSize: 11, opacity: 0.4 }}>Tap to set</span>
                      )}
                    </button>
                  );
                })}
              </div>
            </div>

            {/* Position overrides */}
            {Object.keys(lineupSlots).length > 0 && (
              <div style={{ marginBottom: 12 }}>
                <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
                  MATCH POSITIONS
                </span>
                <div style={{ fontSize: 10, opacity: 0.4, marginBottom: 6 }}>
                  Defaults to roster position. Tap to change for this match.
                </div>
                <div style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                  {Object.entries(lineupSlots).map(([pos, pid]) => {
                    const p = rosterPlayers.find((r) => r.id === pid);
                    if (!p) return null;
                    const effPos = lineupPositions[pid] || p.position;
                    const isChanged = effPos !== p.position;
                    return (
                      <div key={pos} style={{ display: "flex", alignItems: "center", gap: 8, padding: "6px 10px", background: "#111118", borderRadius: 8, border: isChanged ? "1px solid #007bff" : "1px solid #1e1e28" }}>
                        <span style={{ fontSize: 12, fontWeight: 700, width: 70 }}>{p.name?.split(" ")[0]}</span>
                        <div style={{ display: "flex", gap: 4, flex: 1 }}>
                          {POSITIONS.filter((pos) => pos !== "L" && pos !== "DS").map((posOpt) => (
                            <button key={posOpt} style={{
                              padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                              background: effPos === posOpt ? "#007bff" : "#1a1a24",
                              color: effPos === posOpt ? "#fff" : "#6b7280",
                            }} onClick={() => {
                              setLineupPositions((prev) => ({ ...prev, [pid]: posOpt }));
                            }}>{posOpt}</button>
                          ))}
                        </div>
                        {isChanged && <span style={{ fontSize: 9, color: "#007bff", opacity: 0.6 }}>was {p.position}</span>}
                      </div>
                    );
                  })}
                </div>
              </div>
            )}

            {/* Libero slots */}
            <div style={{ marginTop: 12, marginBottom: 12 }}>
              <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>LIBEROS</span>
              <div style={{ display: "flex", gap: 8 }}>
                {/* Libero 1 */}
                <button style={{
                  ...S.courtSlot, flex: 1,
                  ...(selectingLibero === 1 ? S.courtSlotActive : {}),
                  ...(selectedLibero ? S.courtSlotFilled : {}),
                  background: selectedLibero ? "#1e3320" : "#111118",
                  borderColor: selectedLibero ? "#22c55e" : selectingLibero === 1 ? "#007bff" : "#1e1e28",
                }}
                  onClick={() => { setSelectingLibero(1); setSelectingPos(null); }}>
                  <span style={{ ...S.courtPosLabel, color: "#22c55e" }}>L1</span>
                  {selectedLibero ? (
                    <>
                      <span style={S.courtPlayerNum}>{rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "Libero"}</span>
                      <span style={S.courtPlayerName}>#{rosterPlayers.find(p => p.id === selectedLibero)?.number}</span>
                    </>
                  ) : (
                    <span style={{ fontSize: 11, opacity: 0.4 }}>Tap to set</span>
                  )}
                </button>
                {/* Libero 2 */}
                <button style={{
                  ...S.courtSlot, flex: 1,
                  ...(selectingLibero === 2 ? S.courtSlotActive : {}),
                  ...(selectedLibero2 ? S.courtSlotFilled : {}),
                  background: selectedLibero2 ? "#1e3320" : "#111118",
                  borderColor: selectedLibero2 ? "#22c55e" : selectingLibero === 2 ? "#007bff" : "#1e1e28",
                }}
                  onClick={() => { if (!selectedLibero) { showToast("Set Libero 1 first"); return; } setSelectingLibero(2); setSelectingPos(null); }}>
                  <span style={{ ...S.courtPosLabel, color: "#22c55e" }}>L2</span>
                  {selectedLibero2 ? (
                    <>
                      <span style={S.courtPlayerNum}>{rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "Libero 2"}</span>
                      <span style={S.courtPlayerName}>#{rosterPlayers.find(p => p.id === selectedLibero2)?.number}</span>
                    </>
                  ) : (
                    <span style={{ fontSize: 10, opacity: 0.3 }}>Optional</span>
                  )}
                </button>
              </div>
              {/* Remove libero buttons */}
              {(selectedLibero || selectedLibero2) && (
                <div style={{ display: "flex", gap: 6, marginTop: 6 }}>
                  {selectedLibero && (
                    <button style={{ ...S.clearBtn, fontSize: 10, padding: "4px 8px" }} onClick={() => {
                      setSelectedLibero(null); setSelectedLibero2(null); setMbBackRowMap({});
                    }}>Remove L1</button>
                  )}
                  {selectedLibero2 && (
                    <button style={{ ...S.clearBtn, fontSize: 10, padding: "4px 8px" }} onClick={() => {
                      setSelectedLibero2(null);
                      // Reset any MB assignments to libero2
                      setMbBackRowMap((prev) => {
                        const n = { ...prev };
                        for (const k of Object.keys(n)) { if (n[k] === "libero2") n[k] = "libero1"; }
                        return n;
                      });
                    }}>Remove L2</button>
                  )}
                </div>
              )}
            </div>

            {/* MB Back Row Assignment — only show if liberos are set and MBs exist */}
            {selectedLibero && (() => {
              const mbsInLineup = Object.entries(lineupSlots).map(([pos, pid]) => {
                const p = rosterPlayers.find((r) => r.id === pid);
                const effPos = lineupPositions[pid] || p?.position;
                return p && effPos === "MB" ? { pos: Number(pos), player: p } : null;
              }).filter(Boolean);
              if (mbsInLineup.length === 0) return null;
              const lib1Name = rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "L1";
              const lib2Name = selectedLibero2 ? (rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "L2") : null;
              return (
                <div style={{ marginBottom: 12 }}>
                  <span style={{ fontSize: 10, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
                    MB BACK ROW REPLACEMENT
                  </span>
                  <div style={{ fontSize: 10, opacity: 0.4, marginBottom: 6 }}>
                    Choose who replaces each MB when they rotate to the back row.
                  </div>
                  {mbsInLineup.map((mb) => {
                    const assignment = mbBackRowMap[mb.player.id] || "libero1";
                    return (
                      <div key={mb.player.id} style={{ display: "flex", alignItems: "center", gap: 6, padding: "8px 10px", background: "#111118", borderRadius: 8, marginBottom: 4, border: "1px solid #1e1e28" }}>
                        <span style={{ fontSize: 12, fontWeight: 700, width: 60 }}>{mb.player.name?.split(" ")[0]}</span>
                        <div style={{ display: "flex", gap: 4, flex: 1 }}>
                          <button style={{
                            padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                            background: assignment === "libero1" ? "#22c55e" : "#1a1a24",
                            color: assignment === "libero1" ? "#000" : "#6b7280",
                          }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "libero1" }))}>{lib1Name}</button>
                          {selectedLibero2 && (
                            <button style={{
                              padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                              background: assignment === "libero2" ? "#22c55e" : "#1a1a24",
                              color: assignment === "libero2" ? "#000" : "#6b7280",
                            }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "libero2" }))}>{lib2Name}</button>
                          )}
                          <button style={{
                            padding: "4px 8px", borderRadius: 6, border: "none", cursor: "pointer", fontSize: 10, fontWeight: 700,
                            background: assignment === "self" ? "#854d0e" : "#1a1a24",
                            color: assignment === "self" ? "#fff" : "#6b7280",
                          }} onClick={() => setMbBackRowMap((prev) => ({ ...prev, [mb.player.id]: "self" }))}>Plays BR</button>
                        </div>
                      </div>
                    );
                  })}
                </div>
              );
            })()}

            {/* Player picker */}
            {(selectingPos || selectingLibero) && (
              <div style={S.pickerBox}>
                <span style={S.pickerLabel}>
                  {selectingLibero ? `Select Libero ${selectingLibero}` : `Select player for position ${selectingPos}`}
                </span>
                <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
                  {sortByPosition(rosterPlayers
                    .filter((p) => {
                      if (selectingLibero) return !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2;
                      return !assignedIds.includes(p.id) && p.id !== selectedLibero && p.id !== selectedLibero2;
                    }))
                    .map((p) => (
                      <button key={p.id} style={S.pickerPlayer} onClick={() => {
                        if (selectingLibero === 1) {
                          setSelectedLibero(p.id);
                          setSelectingLibero(null);
                        } else if (selectingLibero === 2) {
                          setSelectedLibero2(p.id);
                          setSelectingLibero(null);
                        } else {
                          setLineupSlots((prev) => ({ ...prev, [selectingPos]: p.id }));
                          setLineupPositions((prev) => ({ ...prev, [p.id]: p.position }));
                          setSelectingPos(null);
                        }
                      }}>
                        <span style={{ fontWeight: 800, fontSize: 14 }}>{p.name?.split(" ")[0]}</span>
                        <span style={{ fontSize: 10, opacity: 0.5 }}>#{p.number}</span>
                        <span style={{ fontSize: 10, color: "#007bff" }}>{p.position}</span>
                      </button>
                    ))}
                </div>
                {/* Also allow removing current assignment */}
                {selectingPos && lineupSlots[selectingPos] && (
                  <button style={{ ...S.clearBtn, marginTop: 8, padding: "6px 12px" }} onClick={() => {
                    const pid = lineupSlots[selectingPos];
                    setLineupSlots(prev => { const n = { ...prev }; delete n[selectingPos]; return n; });
                    if (pid) setLineupPositions(prev => { const n = { ...prev }; delete n[pid]; return n; });
                    setSelectingPos(null);
                  }}>Remove from position</button>
                )}
              </div>
            )}

            <button style={{ ...S.primaryBtn, marginTop: 16 }}
              onClick={() => setSetupStep("options")}
              disabled={Object.keys(lineupSlots).length < 6}>
              Set Options →
            </button>
          </div>
        </div>
      );
    }

    // OPTIONS
    if (setupStep === "options") {
      const firstServerId = weServeFirst ? lineupSlots[1] : lineupSlots[2];
      const serverPlayer = firstServerId ? (getPlayerById(firstServerId) || rosterPlayers.find(p => p.id === firstServerId)) : null;

      return (
        <div style={S.container}>
          <div style={S.header}>
            <button style={S.backBtn} onClick={() => setSetupStep("lineup")}>‹</button>
            <h1 style={S.headerTitle}>Set Options</h1>
          </div>
          <div style={S.pad}>
            {/* Match Format */}
            <div style={{ display: "flex", gap: 8, marginBottom: 20 }}>
              <button style={{ ...S.optionBtn, ...(currentMatch?.format === 3 ? S.optionBtnActive : {}) }}
                onClick={() => setCurrentMatch((p) => ({ ...p, format: 3 }))}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Best of 3</span>
              </button>
              <button style={{ ...S.optionBtn, ...(currentMatch?.format === 5 ? S.optionBtnActive : {}) }}
                onClick={() => setCurrentMatch((p) => ({ ...p, format: 5 }))}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Best of 5</span>
              </button>
            </div>

            {/* Serve or Receive */}
            <div style={{ display: "flex", gap: 8, marginBottom: 20 }}>
              <button style={{ ...S.optionBtn, ...(weServeFirst ? S.optionBtnActive : {}) }}
                onClick={() => setWeServeFirst(true)}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Serve</span>
              </button>
              <button style={{ ...S.optionBtn, ...(!weServeFirst ? S.optionBtnActive : {}) }}
                onClick={() => setWeServeFirst(false)}>
                <span style={{ fontWeight: 700, fontSize: 13 }}>Receive</span>
              </button>
            </div>

            {/* First server info */}
            <div style={S.infoCard}>
              <span style={{ fontSize: 12, opacity: 0.5, display: "block", marginBottom: 4 }}>
                {weServeFirst ? "FIRST SERVER" : "FIRST SERVER (on sideout)"}
              </span>
              <span style={{ fontSize: 20, fontWeight: 800 }}>
                {serverPlayer?.name?.split(" ")[0]} <span style={{ fontSize: 14, opacity: 0.5 }}>#{serverPlayer?.number}</span>
              </span>
              <span style={{ fontSize: 12, opacity: 0.5, marginTop: 4, display: "block" }}>
                {weServeFirst
                  ? "Player in zone 1 serves first."
                  : "Player in zone 2 — rotates into zone 1 on sideout."}
              </span>
            </div>

            {/* Libero Serving — pick which MB rotation each libero serves for */}
            {selectedLibero && (() => {
              const mbsInLineup = Object.entries(lineupSlots).map(([pos, pid]) => {
                const p = rosterPlayers.find((r) => r.id === pid);
                const effPos = lineupPositions[pid] || p?.position;
                return p && effPos === "MB" ? { pos: Number(pos), player: p } : null;
              }).filter(Boolean);
              if (mbsInLineup.length < 2) return null;

              // Get liberos that are assigned to at least one MB
              const lib1Name = rosterPlayers.find(p => p.id === selectedLibero)?.name?.split(" ")[0] || "L1";
              const lib2Name = selectedLibero2 ? (rosterPlayers.find(p => p.id === selectedLibero2)?.name?.split(" ")[0] || "L2") : null;
              const lib1HasMBs = Object.values(mbBackRowMap).includes("libero1") || Object.keys(mbBackRowMap).length === 0;
              const lib2HasMBs = selectedLibero2 && Object.values(mbBackRowMap).includes("libero2");

              return (
                <div style={{ marginTop: 20 }}>
                  <h3 style={S.sectionTitle}>Libero Serving</h3>
                  <div style={{ fontSize: 11, opacity: 0.5, marginBottom: 8 }}>
                    Each libero can serve in one MB's rotation.
                  </div>
                  {/* Libero 1 serve choice */}
                  {lib1HasMBs && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4 }}>{lib1Name} serves for:</div>
                      <div style={{ display: "flex", gap: 8 }}>
                        {mbsInLineup.filter(mb => (mbBackRowMap[mb.player.id] || "libero1") === "libero1").map((mb) => (
                          <button key={mb.player.id} style={{
                            ...S.optionBtn,
                            ...(liberoServeChoice === mb.player.id ? S.optionBtnActive : {}),
                          }} onClick={() => setLiberoServeChoice(mb.player.id)}>
                            <span style={{ fontWeight: 800, fontSize: 14 }}>{mb.player.name?.split(" ")[0]}</span>
                            <span style={{ fontSize: 9, opacity: 0.5 }}>Zone {mb.pos}</span>
                          </button>
                        ))}
                        <button style={{
                          ...S.optionBtn,
                          ...(liberoServeChoice === "none" ? S.optionBtnActive : {}),
                        }} onClick={() => setLiberoServeChoice("none")}>
                          <span style={{ fontSize: 11 }}>No serve</span>
                        </button>
                      </div>
                    </div>
                  )}
                  {/* Libero 2 serve choice */}
                  {lib2HasMBs && (
                    <div style={{ marginBottom: 10 }}>
                      <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4 }}>{lib2Name} serves for:</div>
                      <div style={{ display: "flex", gap: 8 }}>
                        {mbsInLineup.filter(mb => mbBackRowMap[mb.player.id] === "libero2").map((mb) => (
                          <button key={mb.player.id} style={{
                            ...S.optionBtn,
                            ...(libero2ServeChoice === mb.player.id ? S.optionBtnActive : {}),
                          }} onClick={() => setLibero2ServeChoice(mb.player.id)}>
                            <span style={{ fontWeight: 800, fontSize: 14 }}>{mb.player.name?.split(" ")[0]}</span>
                            <span style={{ fontSize: 9, opacity: 0.5 }}>Zone {mb.pos}</span>
                          </button>
                        ))}
                        <button style={{
                          ...S.optionBtn,
                          ...(libero2ServeChoice === "none" ? S.optionBtnActive : {}),
                        }} onClick={() => setLibero2ServeChoice("none")}>
                          <span style={{ fontSize: 11 }}>No serve</span>
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}

            <button style={{ ...S.primaryBtn, marginTop: 24 }} onClick={() => {
              try {
                const setNum = (currentMatch?.sets?.length || 0) + 1;
                const newSet = emptySet(setNum);
                newSet.startingLineup = { ...lineupSlots };
                newSet.currentLineup = { ...lineupSlots };
                newSet.positionOverrides = { ...lineupPositions };
                newSet.liberoId = selectedLibero || null; // backwards compat
                newSet.libero1Id = selectedLibero || null;
                newSet.libero2Id = selectedLibero2 || null;
                newSet.liberoServeForMB = liberoServeChoice || null; // backwards compat
                newSet.mbBackRowMap = { ...mbBackRowMap };
                newSet.liberoServeMap = {};
                if (selectedLibero && liberoServeChoice && liberoServeChoice !== "none") {
                  newSet.liberoServeMap[selectedLibero] = liberoServeChoice;
                }
                if (selectedLibero2 && libero2ServeChoice && libero2ServeChoice !== "none") {
                  newSet.liberoServeMap[selectedLibero2] = libero2ServeChoice;
                }
                newSet.liberoSwaps = {};
                newSet.weServe = weServeFirst;
                newSet.rotation = 1;
                newSet.firstServerId = weServeFirst ? lineupSlots[1] : lineupSlots[2];

                const sets = [...(currentMatch?.sets || []), newSet];
                const updated = { ...currentMatch, sets };
                setCurrentMatch(updated);
                setMatches((prev) => {
                  const all = prev.map((m) => (m.id === updated.id ? updated : m));
                  if (!all.find((m) => m.id === updated.id)) all.push(updated);
                  save(all);
                  return all;
                });
                setCurrentSetIdx(sets.length - 1);
                setRallyPhase("idle");
                setCurrentRally(null);
                setSelectedPlayer(null);
                setUndoStack([]);
                setTab("court");
                navigate("match");
                showToast(`Set ${setNum} — Let's go!`);
              } catch (e) {
                showToast(`Error: ${e.message}`);
              }
            }}>
              Start Set →
            </button>
          </div>
        </div>
      );
    }
  }

  // ── STANDALONE SCOUT SCREEN ─────────────────────────
  if (screen === "scout" && currentScout) {
    const shots = currentScout.shots || [];
    const ZONES = [
      { id: 1, label: "Z1" },
      { id: 6, label: "Z6" },
      { id: 5, label: "Z5" },
      { id: 2, label: "Z2" },
      { id: 3, label: "Z3" },
      { id: 4, label: "Z4" },
    ];

    const handleCourtTap = (e, manualX, manualY) => {
      if (!scoutPending) return;
      let x, y;
      if (e && e.currentTarget) {
        const rect = e.currentTarget.getBoundingClientRect();
        x = ((e.clientX - rect.left) / rect.width) * 100;
        y = ((e.clientY - rect.top) / rect.height) * 100;
      } else {
        x = manualX; y = manualY;
      }
      const shot = {
        id: Date.now().toString(),
        originZone: scoutPending.originZone,
        outcome: scoutPending.outcome,
        x: Math.round(x * 10) / 10,
        y: Math.round(y * 10) / 10,
        timestamp: Date.now(),
      };
      const updated = { ...currentScout, shots: [...shots, shot] };
      setCurrentScout(updated);
      const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
      if (!sessions.find((s) => s.id === updated.id)) sessions.push(updated);
      saveScoutSessions(sessions);
      const isOOB = x < 0 || x > 100 || y < 0 || y > 100;
      showToast(`${({ kill: "KILL", dug: "DUG", error: "ERR" })[scoutPending.outcome]}${isOOB ? " (OUT)" : ""} from Z${scoutPending.originZone}`);
      setScoutPending(null);
    };

    const undoScoutShot = () => {
      const updated = { ...currentScout, shots: shots.slice(0, -1) };
      setCurrentScout(updated);
      const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
      saveScoutSessions(sessions);
      showToast("Shot removed");
    };

    const getOriginStats = () => {
      const stats = {};
      for (const z of ZONES) {
        const zShots = shots.filter((s) => s.originZone === z.id);
        stats[z.id] = { kills: zShots.filter((s) => s.outcome === "kill").length, dug: zShots.filter((s) => s.outcome === "dug").length, errors: zShots.filter((s) => s.outcome === "error").length, total: zShots.length };
      }
      return stats;
    };
    const originStats = getOriginStats();
    const filteredShots = scoutOriginFilter !== null ? shots.filter((s) => s.originZone === scoutOriginFilter) : shots;

    const outcomeColor = { kill: "#ef4444", dug: "#007bff", error: "#3b82f6" };
    const COURT_H = 200;

    const courtSvg = (shotList, interactive) => {
      const W = 300, H = COURT_H;
      const PAD = 14;
      const TW = W + PAD * 2, TH = H + PAD * 2;
      const outcomeGlow = { kill: [239,68,68], dug: [245,158,11], error: [59,130,246] };
      const inBounds = shotList.filter((s) => s.x >= 0 && s.x <= 100 && s.y >= 0 && s.y <= 100);
      const oob = shotList.filter((s) => s.x < 0 || s.x > 100 || s.y < 0 || s.y > 100);

      const handleSvgClick = (e) => {
        if (!scoutPending) return;
        const rect = e.currentTarget.getBoundingClientRect();
        const rawX = (e.clientX - rect.left) / rect.width * TW;
        const rawY = (e.clientY - rect.top) / rect.height * TH;
        const x = ((rawX - PAD) / W) * 100;
        const y = ((rawY - PAD) / H) * 100;
        handleCourtTap(null, x, y);
      };

      // Weather-channel density heatmap
      const COLS = 20, ROWS = 14;
      const cellW = W / COLS, cellH = H / ROWS;
      const RADIUS = 3.5; // influence radius in cells
      const heatCells = [];
      if (!interactive && inBounds.length > 0) {
        const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let maxD = 0;
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            let density = 0;
            for (const s of inBounds) {
              const sc = s.x / 100 * COLS;
              const sr = s.y / 100 * ROWS;
              const dist = Math.sqrt((c - sc) ** 2 + (r - sr) ** 2);
              if (dist < RADIUS) density += Math.exp(-(dist * dist) / (RADIUS * 0.7));
            }
            grid[r][c] = density;
            if (density > maxD) maxD = density;
          }
        }
        // Color scale: transparent → blue → cyan → green → yellow → orange → red
        const heatColor = (val) => {
          if (maxD === 0) return "transparent";
          const t = val / maxD;
          if (t < 0.05) return "transparent";
          const stops = [
            [0.05, 0, 0, 180, 0.3],
            [0.2, 0, 100, 255, 0.45],
            [0.35, 0, 200, 200, 0.55],
            [0.5, 0, 220, 0, 0.65],
            [0.65, 180, 220, 0, 0.7],
            [0.8, 255, 180, 0, 0.8],
            [1.0, 255, 40, 0, 0.9],
          ];
          let lo = stops[0], hi = stops[stops.length - 1];
          for (let i = 0; i < stops.length - 1; i++) {
            if (t >= stops[i][0] && t <= stops[i + 1][0]) { lo = stops[i]; hi = stops[i + 1]; break; }
          }
          const f = (t - lo[0]) / (hi[0] - lo[0] || 1);
          const lerp = (a, b) => Math.round(a + (b - a) * f);
          return `rgba(${lerp(lo[1], hi[1])},${lerp(lo[2], hi[2])},${lerp(lo[3], hi[3])},${(lo[4] + (hi[4] - lo[4]) * f).toFixed(2)})`;
        };
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            if (grid[r][c] > maxD * 0.05) {
              heatCells.push(<rect key={`h${r}-${c}`} x={PAD + c * cellW} y={PAD + r * cellH} width={cellW + 0.5} height={cellH + 0.5} fill={heatColor(grid[r][c])} />);
            }
          }
        }
      }

      return (
        <div style={{ position: "relative", width: "100%", cursor: interactive && scoutPending ? "crosshair" : "default", userSelect: "none", touchAction: "none", borderRadius: 8, overflow: "hidden" }}
          onClick={interactive ? handleSvgClick : undefined}>
          <svg width="100%" viewBox={`0 0 ${TW} ${TH}`} style={{ display: "block" }}>
            {/* OOB area */}
            <rect x="0" y="0" width={TW} height={TH} fill="#0a0a0f" />
            {/* Court */}
            <rect x={PAD} y={PAD} width={W} height={H} fill="#0d1118" stroke="#2a2a34" strokeWidth="2" />
            {/* OOB label */}
            {interactive && scoutPending && <>
              <text x={TW / 2} y={PAD / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text>
              <text x={TW / 2} y={TH - PAD / 2 + 4} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text>
              <text x={PAD / 2} y={TH / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text>
              <text x={TW - PAD / 2} y={TH / 2 + 3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text>
            </>}
            {/* Density heatmap */}
            {heatCells}
            {/* Court lines */}
            <line x1={PAD} y1={PAD + H * 0.33} x2={PAD + W} y2={PAD + H * 0.33} stroke={interactive ? "#2a2a34" : "#ffffff33"} strokeWidth="2" strokeDasharray="8,4" />
            <line x1={PAD + 100} y1={PAD} x2={PAD + 100} y2={PAD + H} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            <line x1={PAD + 200} y1={PAD} x2={PAD + 200} y2={PAD + H} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            <line x1={PAD} y1={PAD + H * 0.5} x2={PAD + W} y2={PAD + H * 0.5} stroke={interactive ? "#1a1a24" : "#ffffff15"} strokeWidth="0.5" />
            {/* Input dots */}
            {interactive && inBounds.map((s, i) => (
              <circle key={s.id || i} cx={PAD + s.x * W / 100} cy={PAD + s.y * H / 100} r={5}
                fill={outcomeColor[s.outcome] || "#999"} opacity={0.9} stroke="#000" strokeWidth="0.5" />
            ))}
            {/* OOB dots in border */}
            {interactive && oob.map((s, i) => {
              const ox = Math.max(3, Math.min(TW - 3, PAD + s.x * W / 100));
              const oy = Math.max(3, Math.min(TH - 3, PAD + s.y * H / 100));
              return <circle key={`o${i}`} cx={ox} cy={oy} r={4} fill={outcomeColor[s.outcome] || "#999"} opacity={0.7} stroke="#ef4444" strokeWidth="0.5" />;
            })}
            {/* Heatmap white markers */}
            {!interactive && inBounds.map((s, i) => (
              <circle key={s.id || i} cx={PAD + s.x * W / 100} cy={PAD + s.y * H / 100} r={2} fill="#fff" opacity={0.7} />
            ))}
          </svg>
          {interactive && scoutPending && shotList.length === 0 && (
            <div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%,-50%)", pointerEvents: "none", fontSize: 11, fontWeight: 700, color: "#007bff", opacity: 0.4, letterSpacing: 1, textAlign: "center" }}>TAP EXACT SPOT<br/>BALL LANDED</div>
          )}
        </div>
      );
    };

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => {
            const sessions = scoutSessions.map((s) => s.id === currentScout.id ? currentScout : s);
            if (!sessions.find((s) => s.id === currentScout.id)) sessions.push(currentScout);
            saveScoutSessions(sessions);
            setCurrentScout(null);
            setScoutPending(null);
            goBack();
          }}>&larr;</button>
          <h1 style={S.headerTitle}>Scout: {currentScout.name}</h1>
          <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length}</span>
        </div>

        <div style={S.pad}>
          <div style={{ display: "flex", gap: 4, marginBottom: 8 }}>
            <button style={{ ...S.gb, flex: 1, background: scoutView === "input" ? "#007bff" : "#1a1a24", color: scoutView === "input" ? "#000" : "#fff" }}
              onClick={() => { setScoutView("input"); setScoutPending(null); setScoutOriginFilter(null); }}>+ Log Attacks</button>
            <button style={{ ...S.gb, flex: 1, background: scoutView === "heatmap" ? "#007bff" : "#1a1a24", color: scoutView === "heatmap" ? "#000" : "#fff" }}
              onClick={() => { setScoutView("heatmap"); setScoutPending(null); setScoutOriginFilter(null); }}>Heat Map ({shots.length})</button>
          </div>

          {/* ═══ INPUT MODE ═══ */}
          {scoutView === "input" && (
            <div>
              <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 6 }}>
                {!scoutPending ? "STEP 1: TAP ORIGIN + OUTCOME" : "STEP 2: TAP WHERE BALL LANDED"}
              </div>

              {/* Their court - 6 zones with K/D/E */}
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr", gap: 2, background: "#0f1218", borderRadius: "8px", overflow: "hidden", border: "2px solid #2a2a34"}}>
                {ZONES.map((z) => {
                  const os = originStats[z.id];
                  const isPending = scoutPending?.originZone === z.id;
                  return (
                    <div key={z.id} style={{ background: isPending ? "#0a1929" : "#0d0d14", padding: 4, minHeight: 54, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", opacity: scoutPending ? (isPending ? 1 : 0.25) : 1, position: "relative", border: isPending ? "2px solid #007bff" : "1px solid transparent" }}>
                      <span style={{ fontSize: 8, opacity: 0.3, position: "absolute", top: 2, left: 4 }}>{z.id}</span>
                      <div style={{ display: "flex", gap: 4 }}>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #ef4444", background: isPending && scoutPending.outcome === "kill" ? "#ef4444" : "transparent", color: isPending && scoutPending.outcome === "kill" ? "#000" : "#ef4444", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "kill" })}>K</button>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #007bff", background: isPending && scoutPending.outcome === "dug" ? "#007bff" : "transparent", color: isPending && scoutPending.outcome === "dug" ? "#000" : "#007bff", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "dug" })}>D</button>
                        <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #3b82f6", background: isPending && scoutPending.outcome === "error" ? "#3b82f6" : "transparent", color: isPending && scoutPending.outcome === "error" ? "#000" : "#3b82f6", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "error" })}>E</button>
                      </div>
                      {os.total > 0 && !scoutPending && (
                        <div style={{ display: "flex", gap: 3, marginTop: 2, fontSize: 7 }}>
                          {os.kills > 0 && <span style={{ color: "#ef4444" }}>{os.kills}K</span>}
                          {os.dug > 0 && <span style={{ color: "#007bff" }}>{os.dug}D</span>}
                          {os.errors > 0 && <span style={{ color: "#3b82f6" }}>{os.errors}E</span>}
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>

              {/* NET */}
              <div style={{ background: scoutPending ? "#007bff" : "#2a2a34", textAlign: "center", fontSize: 9, fontWeight: 900, color: scoutPending ? "#000" : "#9ca3af", padding: "4px 0", letterSpacing: 3, margin: "4px 0", borderRadius: 4 }}>
                {scoutPending ? "\u25bc TAP EXACT LANDING SPOT \u25bc" : "\u2500\u2500\u2500 NET \u2500\u2500\u2500"}
              </div>

              
              {courtSvg(shots, true)}

              {/* Footer */}
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 8 }}>
                <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length} shots</span>
                <div style={{ display: "flex", gap: 6 }}>
                  {scoutPending && <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} onClick={() => setScoutPending(null)}>Cancel</button>}
                  <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} disabled={shots.length === 0} onClick={undoScoutShot}>Undo</button>
                </div>
              </div>

              {/* Legend */}
              <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
              </div>
            </div>
          )}

          {/* ═══ HEAT MAP MODE ═══ */}
          {scoutView === "heatmap" && (
            <div>
              {shots.length === 0 ? (
                <div style={{ textAlign: "center", padding: 32, opacity: 0.4 }}>No shots yet. Log attacks first.</div>
              ) : (
                <>
                  {/* Origin filter */}
                  <div style={{ fontSize: 10, fontWeight: 700, color: "#9ca3af", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>FILTER BY ATTACK ORIGIN</div>
                  <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "auto auto", gap: 2, background: "#0f1218", border: "2px solid #2a2a34", borderRadius: "8px", overflow: "hidden", marginBottom: 4 }}>
                    {ZONES.map((z) => {
                      const os = originStats[z.id];
                      const isActive = scoutOriginFilter === z.id;
                      return (
                        <button key={z.id} style={{ background: isActive ? "#0a1929" : "#0d0d14", padding: 5, border: "none", color: "#fff", cursor: "pointer", textAlign: "center", borderBottom: isActive ? "2px solid #007bff" : "2px solid transparent" }}
                          onClick={() => setScoutOriginFilter(isActive ? null : z.id)}>
                          <div style={{ fontSize: 8, opacity: 0.4 }}>Z{z.id}</div>
                          {os.total > 0 && <div style={{ fontSize: 10, fontWeight: 700 }}>{os.total} <span style={{ fontSize: 7, opacity: 0.5 }}>({os.kills}K)</span></div>}
                        </button>
                      );
                    })}
                  </div>
                  {scoutOriginFilter !== null && (
                    <button style={{ ...S.gb, background: "#2a2a34", width: "100%", marginBottom: 4, fontSize: 10 }} onClick={() => setScoutOriginFilter(null)}>Zone {scoutOriginFilter} filter &mdash; tap to clear</button>
                  )}

                  <div style={{ background: "#007bff", textAlign: "center", fontSize: 9, fontWeight: 900, color: "#000", padding: "3px 0", letterSpacing: 3, margin: "2px 0", borderRadius: 4 }}>{"\u2500\u2500\u2500"} NET {"\u2500\u2500\u2500"}</div>

                  {/* Heat map court */}
                  {courtSvg(filteredShots, false)}

                  {/* Summary */}
                  <div style={{ ...S.card, marginTop: 8 }}>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, textAlign: "center" }}>
                      <div><div style={{ fontSize: 20, fontWeight: 800 }}>{filteredShots.length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Attacks</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#ef4444" }}>{filteredShots.filter((s) => s.outcome === "kill").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Kills</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#22c55e" }}>{filteredShots.filter((s) => s.outcome === "dug").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Digs</div></div>
                      <div><div style={{ fontSize: 20, fontWeight: 800, color: "#3b82f6" }}>{filteredShots.filter((s) => s.outcome === "error").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Errors</div></div>
                    </div>
                  </div>

                  {/* Legend */}
                  <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                    <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                  </div>
                </>
              )}

              {/* Scout Notes */}
              <div style={{ marginTop: 16 }}>
                <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, letterSpacing: 1, marginBottom: 6 }}>SCOUTING NOTES</div>
                <textarea
                  style={{ width: "100%", minHeight: 120, padding: 12, background: "#111118", border: "1px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", fontSize: 13, lineHeight: 1.5, resize: "vertical", outline: "none", boxSizing: "border-box", fontFamily: "inherit" }}
                  placeholder="Add notes about tendencies, key players, rotation patterns..."
                  value={currentScout.notes || ""}
                  onChange={(e) => {
                    const updated = { ...currentScout, notes: e.target.value };
                    setCurrentScout(updated);
                    const sessions = scoutSessions.map((s) => s.id === updated.id ? updated : s);
                    if (!sessions.find((s) => s.id === updated.id)) sessions.push(updated);
                    saveScoutSessions(sessions);
                  }}
                />
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ── PRACTICE SCREEN ──────────────────────────────────
  if (screen === "practice" && currentPractice) {
    const team = savedTeams.find((t) => t.id === currentPractice.teamId);
    const rosterP = team ? ((team.players||[])).filter((p) => p.number) : [];

    // Gather all events across all saved rounds + active round for live stats
    const practicePlayerStats = {};
    const addEvt = (ev) => {
      if (!practicePlayerStats[ev.playerId]) practicePlayerStats[ev.playerId] = { 0: 0, 1: 0, 2: 0, 3: 0, total: 0 };
      const ps = practicePlayerStats[ev.playerId];
      ps[ev.quality] = (ps[ev.quality] || 0) + 1;
      ps.total++;
    };
    for (const r of currentPractice.rounds) {
      for (const g of (r.groups || [])) {
        for (const ev of (g.events || [])) addEvt(ev);
      }
      // Legacy flat events support
      if (r.events) for (const ev of (r.events || [])) addEvt(ev);
    }
    // Active round groups
    if (practiceRound) {
      for (const g of (practiceRound.groups || [])) {
        for (const ev of (g.events || [])) addEvt(ev);
      }
    }

    const savePracticeData = (prac) => {
      setCurrentPractice(prac);
      const all = practices.map((p) => p.id === prac.id ? prac : p);
      if (!all.find((p) => p.id === prac.id)) all.push(prac);
      savePractices(all);
    };

    // Active group is last in practiceRound.groups
    const activeGroup = practiceRound?.groups?.length > 0 ? practiceRound.groups[practiceRound.groups.length - 1] : null;
    const isStatting = practiceRound && !practicePasserPick && activeGroup;
    const roundNum = ((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0);

    // Round-level stats (all groups in current active round)
    const roundPlayerStats = {};
    if (practiceRound) {
      for (const g of (practiceRound.groups || [])) {
        for (const ev of (g.events || [])) {
          if (!roundPlayerStats[ev.playerId]) roundPlayerStats[ev.playerId] = { 0: 0, 1: 0, 2: 0, 3: 0, total: 0 };
          const ps = roundPlayerStats[ev.playerId];
          ps[ev.quality] = (ps[ev.quality] || 0) + 1;
          ps.total++;
        }
      }
    }

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}
        <div style={S.header}>
          <button style={S.backBtn} onClick={() => {
            if (practiceRound && practiceRound.groups?.some((g) => ((g.events||[])).length > 0)) {
              const { _pendingPassers, ...cleanRound } = practiceRound;
              const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
              savePracticeData(updated);
            } else {
              savePracticeData(currentPractice);
            }
            setCurrentPractice(null);
            setPracticeRound(null);
            setPracticePasserPick(false);
            goBack();
          }}>‹</button>
          <h1 style={{ ...S.headerTitle, flex: 1 }}>{currentPractice.name}</h1>
          {practiceRound && (
            <span style={{ fontSize: 11, color: "#007bff", fontWeight: 700 }}>R{roundNum} / G{practiceRound.groups?.length || 0}</span>
          )}
        </div>

        <div style={S.pad}>
          {/* NO ACTIVE ROUND — show round list + start button */}
          {!practiceRound && (
            <div>
              <button style={{ ...S.primaryBtn, margin: "0 0 16px" }} onClick={() => {
                setPracticeRound({ id: Date.now().toString(), groups: [], _pendingPassers: [] });
                setPracticePasserPick(true);
              }}>
                Start Round {((currentPractice.rounds||[])).length + 1}
              </button>

              {((currentPractice.rounds||[])).length > 0 && (
                <>
                  <h3 style={S.sectionTitle}>COMPLETED ROUNDS</h3>
                  {((currentPractice.rounds||[])).map((r, ri) => {
                    const groups = r.groups || [];
                    const totalEvts = groups.reduce((t, g) => t + ((g.events||[])).length, 0) + (r.events?.length || 0);
                    const uniquePassers = new Set();
                    for (const g of groups) for (const e of (g.events || [])) uniquePassers.add(e.playerId);
                    if (r.events) for (const e of (r.events || [])) uniquePassers.add(e.playerId);
                    return (
                      <div key={r.id || ri} style={{ ...S.card, marginBottom: 8 }}>
                        <div style={{ display: "flex", justifyContent: "space-between" }}>
                          <span style={{ fontWeight: 700 }}>Round {ri + 1}</span>
                          <span style={{ fontSize: 11, opacity: 0.4 }}>{groups.length} group{groups.length !== 1 ? "s" : ""} / {totalEvts} passes</span>
                        </div>
                        <div style={{ fontSize: 11, opacity: 0.5, marginTop: 2 }}>{uniquePassers.size} player{uniquePassers.size !== 1 ? "s" : ""}</div>
                      </div>
                    );
                  })}
                </>
              )}
            </div>
          )}

          {/* ACTIVE ROUND — passer selection for new group */}
          {practiceRound && practicePasserPick && (
            <div>
              <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>
                ROUND {roundNum} — {practiceRound.groups?.length > 0 ? "NEW GROUP" : "SET UP FIRST GROUP"}
              </div>
              <h3 style={S.sectionTitle}>SELECT PASSERS</h3>
              <div style={{ fontSize: 11, opacity: 0.5, marginBottom: 8 }}>Tap all players passing in this group</div>
              <div style={{ display: "flex", flexWrap: "wrap", gap: 6, marginBottom: 16 }}>
                {sortByPosition(rosterP).map((p) => {
                  const selected = (practiceRound._pendingPassers || []).includes(p.id);
                  return (
                    <button key={p.id} style={{
                      padding: "8px 12px", borderRadius: 8, border: "2px solid", cursor: "pointer",
                      borderColor: selected ? "#007bff" : "#2a2a34",
                      background: selected ? "#0a1929" : "#0d0d14",
                      color: "#e2e8f0",
                    }} onClick={() => {
                      setPracticeRound((prev) => {
                        const pending = prev._pendingPassers || [];
                        const has = pending.includes(p.id);
                        return { ...prev, _pendingPassers: has ? pending.filter((x) => x !== p.id) : [...pending, p.id] };
                      });
                    }}>
                      <span style={{ fontWeight: 800, fontSize: 14 }}>{p.name?.split(" ")[0]}</span>
                      <span style={{ fontSize: 10, marginLeft: 4, opacity: 0.5 }}>#{p.number}</span>
                      <span style={{ fontSize: 9, marginLeft: 4, color: "#007bff" }}>{p.position}</span>
                    </button>
                  );
                })}
              </div>
              <button style={{ ...S.primaryBtn, margin: 0 }}
                disabled={!(practiceRound._pendingPassers?.length > 0)}
                onClick={() => {
                  const newGroup = { id: Date.now().toString(), selectedPassers: [...practiceRound._pendingPassers], events: [] };
                  setPracticeRound((prev) => {
                    const { _pendingPassers, ...rest } = prev;
                    return { ...rest, groups: [...(rest.groups || []), newGroup], _pendingPassers: [] };
                  });
                  setPracticePasserPick(false);
                }}>
                Start Group ({practiceRound._pendingPassers?.length || 0} passers)
              </button>

              {practiceRound.groups?.length > 0 && (
                <button style={{ ...S.cancelBtn, marginTop: 8 }} onClick={() => {
                  if (practiceRound.groups.some((g) => ((g.events||[])).length > 0)) {
                    const { _pendingPassers, ...cleanRound } = practiceRound;
                    const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
                    savePracticeData(updated);
                  }
                  setPracticeRound(null);
                  setPracticePasserPick(false);
                }}>End Round</button>
              )}
            </div>
          )}

          {/* ACTIVE GROUP — stat passes */}
          {isStatting && (
            <div>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 8 }}>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1 }}>
                  ROUND {roundNum} / GROUP {practiceRound.groups.length}
                </div>
                <span style={{ fontSize: 10, opacity: 0.4 }}>{((activeGroup.events||[])).length} passes</span>
              </div>

              {activeGroup.selectedPassers.map((pid) => {
                const player = rosterP.find((p) => p.id === pid);
                if (!player) return null;
                const groupEvts = ((activeGroup.events||[])).filter((e) => e.playerId === pid);
                const groupTotal = groupEvts.length;
                const groupAvg = groupTotal > 0 ? groupEvts.reduce((s, e) => s + e.quality, 0) / groupTotal : 0;
                return (
                  <div key={pid} style={{ ...S.card, marginBottom: 8, padding: 10 }}>
                    <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 6 }}>
                      <span style={{ fontWeight: 700, fontSize: 14 }}>{player.name?.split(" ")[0]} <span style={{ fontWeight: 400, fontSize: 11, opacity: 0.5 }}>#{player.number}</span></span>
                      <span style={{ fontSize: 11, opacity: 0.5 }}>{groupTotal} {groupTotal > 0 ? `(${groupAvg.toFixed(1)} avg)` : ""}</span>
                    </div>
                    <div style={{ display: "flex", gap: 6 }}>
                      {[0, 1, 2, 3].map((q) => (
                        <button key={q} style={{
                          flex: 1, padding: "14px 0", borderRadius: 8, border: "none", cursor: "pointer", fontWeight: 800, fontSize: 20,
                          background: q === 0 ? "#7f1d1d" : q === 1 ? "#991b1b" : q === 2 ? "#854d0e" : "#166534",
                          color: "#fff",
                        }} onClick={() => {
                          const ev = { playerId: pid, quality: q, timestamp: Date.now() };
                          setPracticeRound((prev) => {
                            const groups = [...prev.groups];
                            const lastG = { ...groups[groups.length - 1] };
                            lastG.events = [...(lastG.events||[]), ev];
                            groups[groups.length - 1] = lastG;
                            return { ...prev, groups };
                          });
                          showToast(`${player.name?.split(" ")[0]} / ${q}`);
                        }}>{q}</button>
                      ))}
                    </div>
                  </div>
                );
              })}

              {((activeGroup.events||[])).length > 0 && (
                <button style={{ ...S.gb, width: "100%", marginBottom: 8, background: "#2a2a34" }} onClick={() => {
                  setPracticeRound((prev) => {
                    const groups = [...prev.groups];
                    const lastG = { ...groups[groups.length - 1] };
                    lastG.events = ((lastG.events||[])).slice(0, -1);
                    groups[groups.length - 1] = lastG;
                    return { ...prev, groups };
                  });
                  showToast("Undone");
                }}>Undo Last</button>
              )}

              <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
                <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#0056b3" }} onClick={() => {
                  setPracticePasserPick(true);
                  setPracticeRound((prev) => ({ ...prev, _pendingPassers: [] }));
                }}>New Group</button>
                <button style={{ ...S.primaryBtn, flex: 1, margin: 0, background: "#991b1b" }} onClick={() => {
                  if (practiceRound.groups.some((g) => ((g.events||[])).length > 0)) {
                    const { _pendingPassers, ...cleanRound } = practiceRound;
                    const updated = { ...currentPractice, rounds: [...currentPractice.rounds, cleanRound] };
                    savePracticeData(updated);
                  }
                  setPracticeRound(null);
                  setPracticePasserPick(false);
                }}>End Round</button>
              </div>
            </div>
          )}

          {/* ROUND STATS — current active round */}
          {practiceRound && Object.keys(roundPlayerStats).length > 0 && (
            <div style={{ ...S.card, marginTop: 16 }}>
              <h3 style={S.cardTitle}>ROUND {roundNum} STATS</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead><tr><th style={S.sth}>Player</th><th style={S.sth}>Tot</th><th style={S.sth}>3s</th><th style={S.sth}>2s</th><th style={S.sth}>1s</th><th style={S.sth}>0s</th><th style={S.sth}>Avg</th></tr></thead>
                  <tbody>
                    {Object.entries(roundPlayerStats).sort((a, b) => b[1].total - a[1].total).map(([pid, ps]) => {
                      const player = rosterP.find((p) => p.id === pid);
                      if (!player) return null;
                      const avg = ps.total > 0 ? (ps[1]*1 + ps[2]*2 + ps[3]*3) / ps.total : 0;
                      const avgColor = avg >= 2.5 ? "#22c55e" : avg >= 2.0 ? "#007bff" : "#ef4444";
                      return (<tr key={pid}><td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>#{player.number} {player.name?.split(" ")[0]}</td><td style={S.std}>{ps.total}</td><td style={{ ...S.std, color: "#22c55e" }}>{ps[3]}</td><td style={{ ...S.std, color: "#007bff" }}>{ps[2]}</td><td style={{ ...S.std, color: "#ef4444" }}>{ps[1]}</td><td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps[0]}</td><td style={{ ...S.std, fontWeight: 800, color: avgColor }}>{avg.toFixed(1)}</td></tr>);
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {/* FULL PRACTICE STATS */}
          {Object.keys(practicePlayerStats).length > 0 && (
            <div style={{ ...S.card, marginTop: 12 }}>
              <h3 style={S.cardTitle}>FULL PRACTICE STATS</h3>
              <p style={S.cardSub}>{((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0)} round{((currentPractice.rounds||[])).length + (practiceRound ? 1 : 0) !== 1 ? "s" : ""}</p>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead><tr><th style={S.sth}>Player</th><th style={S.sth}>Tot</th><th style={S.sth}>3s</th><th style={S.sth}>2s</th><th style={S.sth}>1s</th><th style={S.sth}>0s</th><th style={S.sth}>Avg</th></tr></thead>
                  <tbody>
                    {Object.entries(practicePlayerStats).sort((a, b) => b[1].total - a[1].total).map(([pid, ps]) => {
                      const player = rosterP.find((p) => p.id === pid);
                      if (!player) return null;
                      const avg = ps.total > 0 ? (ps[1]*1 + ps[2]*2 + ps[3]*3) / ps.total : 0;
                      const avgColor = avg >= 2.5 ? "#22c55e" : avg >= 2.0 ? "#007bff" : "#ef4444";
                      return (<tr key={pid}><td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>#{player.number} {player.name?.split(" ")[0]}</td><td style={S.std}>{ps.total}</td><td style={{ ...S.std, color: "#22c55e" }}>{ps[3]}</td><td style={{ ...S.std, color: "#007bff" }}>{ps[2]}</td><td style={{ ...S.std, color: "#ef4444" }}>{ps[1]}</td><td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps[0]}</td><td style={{ ...S.std, fontWeight: 800, color: avgColor }}>{avg.toFixed(1)}</td></tr>);
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  // ── MATCH SCREEN ────────────────────────────────────
  if (screen === "match" && currentMatch) {
    let set = getCurrentSet();
    if (!set) {
      return <div style={S.container}><div style={S.loading}>Loading set...</div></div>;
    }

    // ALWAYS log lineup state for diagnostics
    console.log("[MATCH] Set", currentSetIdx, "lineup:", JSON.stringify(set.currentLineup), 
      "starting:", JSON.stringify(set.startingLineup), 
      "lib1:", set.libero1Id, "lib2:", set.libero2Id,
      "rotation:", set.rotation, "weServe:", set.weServe,
      "posOverrides:", JSON.stringify(set.positionOverrides));
    
    // Auto-repair: if any zone 1-6 is empty, rebuild from startingLineup (one-time)
    const _lineupValid = [1,2,3,4,5,6].every(z => !!set.currentLineup?.[z]);
    if (!_lineupValid && set.startingLineup && Object.keys(set.startingLineup).length >= 6 && !set._repaired) {
      const rotCount = ((set.rotation || 1) - 1) % 6;
      let rebuilt = {};
      for (let z = 1; z <= 6; z++) rebuilt[z] = set.startingLineup[z] || set.startingLineup[String(z)];
      for (let i = 0; i < rotCount; i++) rebuilt = rotate(rebuilt);
      console.warn("[AUTO-REPAIR] Lineup had empty zones, rebuilt from starting + rotation", rotCount);
      console.warn("[AUTO-REPAIR] Before:", JSON.stringify(set.currentLineup), "After:", JSON.stringify(rebuilt));
      // Trigger proper state update
      updateCurrentSet((s) => ({ ...s, currentLineup: rebuilt, _repaired: true }));
      // Also use rebuilt for this render cycle
      set = { ...set, currentLineup: rebuilt, _repaired: true };
    }

    const onCourt = getOnCourtLineup(set) || {};
    const server = getCurrentServer(set);
    const nextServer = getNextServer(set);
    const passers = getPassers(set) || [];
    const passerIds = passers.map((p) => p.playerId);
    const primaryPasserIds = passers.filter((p) => p.primary).map((p) => p.playerId);
    const setTotals = getSetTotals(set);
    const setProgress = getCurrentSetProgress(set);
    const swingDist = getSwingDistribution(set);
    const totalSwings = swingDist.reduce((s, d) => s + d.attacks, 0);
    const serveRisk = getServeRisk(set);
    const rosterPlayers = ((currentMatch.roster||[])).filter((p) => p.number);
    const onCourtIds = Object.values(onCourt).filter((v) => typeof v === "string");
    const benchPlayers = rosterPlayers.filter((p) => !Object.values(set?.currentLineup || {}).includes(p.id) && !isLiberoId(p.id, set));

    return (
      <div style={S.container}>
        {toast && <div style={S.toast}>{toast}</div>}

        {/* TIMEOUT OVERLAY */}
        {showTimeout && (() => {
          // Current set stats
          const st = getSetTotals(set);
          const att = (st.kill||0)+(st.attack_error||0)+(st.attack_blocked||0);
          const kPct = att > 0 ? ((st.kill||0)-(st.attack_error||0))/att : 0;
          // Full match stats
          const mt = getMatchTotals();
          const mAtt = (mt.kill||0)+(mt.attack_error||0)+(mt.attack_blocked||0);
          const mKPct = mAtt > 0 ? ((mt.kill||0)-(mt.attack_error||0))/mAtt : 0;
          const topH = rosterPlayers.map((p) => {
            const ps = getPlayerSetStats(p.id, set);
            const a = (ps.kill||0)+(ps.attack_error||0)+(ps.attack_blocked||0);
            return { name: p.name?.split(" ")[0]||`#${p.number}`, k: ps.kill||0, e: ps.attack_error||0, att: a, pct: a > 0 ? ((ps.kill||0)-(ps.attack_error||0))/a : null };
          }).filter((h) => h.att > 0).sort((a,b) => b.k - a.k).slice(0, 4);

          // Formula comparison using new engine
          const fa = formulaAnalysis;
          const currentVars = set ? computeFormulaRow(set) : {};

          // Build suggestions from match + formula context
          const sug = [];
          const scoreDiff = (set?.ourScore || 0) - (set?.theirScore || 0);
          const matchSetsWon = ((currentMatch.sets||[])).filter((s) => s.complete && s.ourScore > s.theirScore).length;
          const matchSetsLost = ((currentMatch.sets||[])).filter((s) => s.complete && s.ourScore < s.theirScore).length;

          // Formula-driven suggestions
          if (fa.hasEnoughData) {
            const highImpact = fa.variables.filter(v => v.priorityZone === "high_impact");
            const onTarget = fa.variables.filter(v => v.priorityZone === "on_target");
            if (highImpact.length > 0) {
              const top = highImpact[0];
              const curr = currentVars[top.name];
              const isBelow = top.name === "reception_error_rate" ? curr > top.threshold : curr < top.threshold;
              if (isBelow) sug.push(`${top.displayName} is below your winning threshold of ${top.format(top.threshold)} — this is your top priority.`);
            }
            if (onTarget.length > 0) {
              const best = onTarget[0];
              const curr = currentVars[best.name];
              const isAbove = best.name === "reception_error_rate" ? curr < best.threshold : curr > best.threshold;
              if (isAbove) sug.push(`${best.displayName} is above target — keep riding this strength.`);
            }
          }

          // Performance-driven suggestions
          if (kPct < 0.10 && att > 5) sug.push("Attack efficiency critically low — run middles/quicks to open the pins.");
          else if (kPct < 0.20 && att > 5) sug.push("Hitting below .200 — consider spreading offense to force defensive adjustments.");
          if ((st.serve_error||0) > (st.ace||0) + 1) sug.push("Serve errors exceed aces — dial back risk, prioritize placement.");
          if ((st.ball_error||0) >= 3) sug.push(`${st.ball_error} ball handling errors — clean up passing and setting contacts.`);

          // Individual player analysis
          const hot = topH.find((h) => h.pct !== null && h.pct > 0.3 && h.att >= 3);
          if (hot) sug.push(`${hot.name} is hitting .${Math.round(hot.pct*1000).toString().padStart(3,"0")} — keep feeding them.`);
          const cold = topH.find((h) => h.pct !== null && h.pct < 0 && h.att >= 3);
          if (cold) sug.push(`${cold.name} negative hitting (${cold.k}K/${cold.e}E) — reduce their swings or move them.`);

          // Score-driven suggestions
          if (scoreDiff <= -5) sug.push("Down 5+ — consider lineup change or aggressive serving to break their rhythm.");
          else if (scoreDiff <= -3) sug.push("Down 3 — stay disciplined, minimize unforced errors, make them earn it.");
          else if (scoreDiff >= 5 && (set?.ourScore||0) >= 20) sug.push("Commanding lead — stay aggressive, close it out.");

          // Match context
          if (matchSetsLost > matchSetsWon && ((currentMatch.sets||[])).length > 1) sug.push("Down in match — consider adjustments from earlier sets.");
          if ((st.dig||0) < 3 && (set?.theirScore||0) >= 10) sug.push("Low digs — adjust defensive base positions.");
          if ((st.stuff_block||0) === 0 && (set?.theirScore||0) >= 10) sug.push("No stuff blocks — re-evaluate blocking scheme and assignments.");
          if (sug.length === 0) sug.push("Keep tracking — every stat builds the picture.");

          // Pre-formula context: add generic comparative insights
          if (!fa.hasEnoughData) {
            const totalPtsPlayed = (set?.ourScore || 0) + (set?.theirScore || 0);
            if (totalPtsPlayed > 10) {
              const sideoutPct = totalPtsPlayed > 0 ? Math.round(((set?.ourScore || 0) / totalPtsPlayed) * 100) : 0;
              if (sideoutPct >= 55) sug.push(`Winning ${sideoutPct}% of total points — strong tempo, stay on it.`);
              else if (sideoutPct <= 40) sug.push(`Only ${sideoutPct}% of total points — need a run. Consider lineup or serving changes.`);
            }
            const totalErrors = (st.attack_error||0) + (st.ball_error||0) + (st.serve_error||0);
            if (totalErrors >= 5 && totalErrors > (st.kill||0)) sug.push(`${totalErrors} total errors exceed ${st.kill||0} kills — clean up unforced mistakes.`);
          }

          return (
          <div style={{ position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.92)", zIndex: 200, display: "flex", alignItems: "center", justifyContent: "center" }}>
            <div style={{ background: "#0a0a0f", border: "2px solid #007bff", borderRadius: 12, padding: 16, width: "92%", maxWidth: 400, maxHeight: "85vh", overflowY: "auto" }}>
              <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 }}>
                <span style={{ fontWeight: 800, fontSize: 16, color: "#007bff", letterSpacing: 2 }}>TIMEOUT</span>
                <button style={{ background: "#2a2a34", border: "none", color: "#fff", padding: "6px 14px", borderRadius: 6, fontWeight: 700, cursor: "pointer" }} onClick={() => setShowTimeout(false)}>CLOSE</button>
              </div>
              {/* Score */}
              <div style={{ display: "flex", justifyContent: "center", gap: 20, marginBottom: 4, fontSize: 28, fontWeight: 800 }}>
                <span style={{ color: set.ourScore >= set.theirScore ? "#22c55e" : "#ef4444" }}>{set.ourScore}</span>
                <span style={{ opacity: 0.3 }}>-</span>
                <span>{set.theirScore}</span>
              </div>
              {((currentMatch.sets||[])).length > 1 && (
                <div style={{ textAlign: "center", fontSize: 10, opacity: 0.4, marginBottom: 10 }}>Match: {matchSetsWon}-{matchSetsLost}</div>
              )}
              {/* Quick stats */}
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 6, marginBottom: 12 }}>
                {[
                  { v: att > 0 ? (kPct >= 0 ? "." : "-.") + Math.abs(Math.round(kPct*1000)).toString().padStart(3,"0") : "-", l: "HIT%", c: kPct >= 0.2 ? "#22c55e" : kPct >= 0 ? "#007bff" : "#ef4444" },
                  { v: st.kill||0, l: "KILLS", c: "#22c55e" },
                  { v: `${st.ace||0}/${st.serve_error||0}`, l: "SA/SE", c: "#007bff" },
                  { v: st.stuff_block||0, l: "STUFFS", c: "#22c55e" },
                ].map((d, i) => (
                  <div key={i} style={{ textAlign: "center", background: "#0d1118", borderRadius: 6, padding: 6 }}>
                    <div style={{ fontSize: 18, fontWeight: 800, color: d.c }}>{d.v}</div>
                    <div style={{ fontSize: 8, opacity: 0.5 }}>{d.l}</div>
                  </div>
                ))}
              </div>
              {/* Formula vs actual */}
              {fa.hasEnoughData ? (
                <div style={{ marginBottom: 12 }}>
                  <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4, letterSpacing: 1 }}>VS FORMULA</div>
                  {fa.variables.filter(v => v.threshold !== null && v.priorityZone !== "low_relationship").slice(0, 4).map((v) => {
                    const curr = currentVars[v.name] ?? 0;
                    const isInverse = v.name === "reception_error_rate";
                    const onTarget = isInverse ? curr <= v.threshold : curr >= v.threshold;
                    return (
                      <div key={v.name} style={{ display: "flex", justifyContent: "space-between", alignItems: "center", fontSize: 11, padding: "3px 0", borderBottom: "1px solid #1a1a24" }}>
                        <span style={{ fontWeight: 600, flex: 1 }}>{v.displayName}</span>
                        <span style={{ fontWeight: 800, color: onTarget ? "#22c55e" : "#ef4444", marginRight: 6 }}>{v.format(curr)}</span>
                        <span style={{ fontSize: 9, opacity: 0.4, minWidth: 50, textAlign: "right" }}>tgt {v.format(v.threshold)}</span>
                      </div>
                    );
                  })}
                </div>
              ) : (
                <div style={{ marginBottom: 8, padding: "6px 8px", background: "#0d1118", borderRadius: 6, textAlign: "center" }}>
                  <div style={{ display: "flex", gap: 3, justifyContent: "center", marginBottom: 4 }}>
                    {[1,2,3,4,5,6,7,8].map((n) => (
                      <div key={n} style={{
                        width: 14, height: 14, borderRadius: 3, fontSize: 7, fontWeight: 800,
                        display: "flex", alignItems: "center", justifyContent: "center",
                        background: n <= (fa.totalSets || 0) ? "#007bff" : "#1e1e28",
                        color: n <= (fa.totalSets || 0) ? "#fff" : "#4b5563",
                      }}>{n}</div>
                    ))}
                  </div>
                  <div style={{ fontSize: 9, opacity: 0.4 }}>Formula unlocks after {Math.max(0, 8 - (fa.totalSets || 0))} more set{8 - (fa.totalSets || 0) === 1 ? "" : "s"}</div>
                </div>
              )}
              {/* Top hitters */}
              {topH.length > 0 && (
                <div style={{ marginBottom: 12 }}>
                  <div style={{ fontSize: 10, fontWeight: 700, opacity: 0.5, marginBottom: 4, letterSpacing: 1 }}>TOP HITTERS</div>
                  {topH.map((h, i) => (
                    <div key={i} style={{ display: "flex", justifyContent: "space-between", fontSize: 12, padding: "3px 0", borderBottom: "1px solid #1a1a24" }}>
                      <span style={{ fontWeight: 700 }}>{h.name}</span>
                      <span>{h.k}K / {h.e}E / {h.att}att {h.pct !== null ? (h.pct >= 0 ? "." : "-.") + Math.abs(Math.round(h.pct*1000)).toString().padStart(3,"0") : ""}</span>
                    </div>
                  ))}
                </div>
              )}
              {/* Suggestions */}
              <div style={{ background: "#0a1a0a", borderRadius: 8, padding: 10, border: "1px solid #22c55e44" }}>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#22c55e", marginBottom: 6, letterSpacing: 1 }}>ADJUSTMENTS</div>
                {sug.map((s, i) => (
                  <div key={i} style={{ fontSize: 11, marginBottom: 4, paddingLeft: 8, borderLeft: "2px solid #22c55e44" }}>{s}</div>
                ))}
              </div>
            </div>
          </div>
          );
        })()}

        {/* Score header */}
        <div style={{ display: "flex", alignItems: "center", padding: "10px 10px 6px", borderBottom: "1px solid #1a1a24" }}>
          <div style={{ display: "flex", gap: 6, minWidth: 76 }}>
            <button style={{ background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", fontSize: 14, padding: "6px 10px", cursor: "pointer", lineHeight: 1 }} onClick={goBack}>
              <span style={{ display: "inline-block", width: 8, height: 8, borderLeft: "2px solid #e2e8f0", borderBottom: "2px solid #e2e8f0", transform: "rotate(45deg)", marginRight: 1 }} />
            </button>
            <button style={{ background: "#991b1b", border: "1px solid #7f1d1d", borderRadius: 8, color: "#fff", fontSize: 11, fontWeight: 800, padding: "6px 10px", cursor: "pointer", letterSpacing: 0.5 }} onClick={() => setShowTimeout(true)}>T/O</button>
          </div>
          <div style={{ flex: 1, display: "flex", justifyContent: "center" }}>
            <div style={S.scoreBoard}>
              <div style={S.teamCol}>
                <span style={S.teamLabel}>US</span>
                <span style={S.bigScore}>{set?.ourScore || 0}</span>
              </div>
              <div style={S.setChip}>
                S{set?.number || 1}
                <span style={{ fontSize: 9, display: "block", opacity: 0.7 }}>
                  {(() => {
                    const sw = (currentMatch.sets||[]).filter((s) => s.complete && s.ourScore > s.theirScore).length;
                    const sl = (currentMatch.sets||[]).filter((s) => s.complete && s.ourScore < s.theirScore).length;
                    return sw > 0 || sl > 0 ? `${sw}-${sl}` : `R${set?.rotation || 1}`;
                  })()}
                </span>
              </div>
              <div style={S.teamCol}>
                <span style={S.teamLabel}>{currentMatch.opponent?.slice(0, 5)?.toUpperCase() || "THEM"}</span>
                <span style={S.bigScore}>{set?.theirScore || 0}</span>
              </div>
            </div>
          </div>
          <div style={{ minWidth: 76, display: "flex", justifyContent: "flex-end" }}>
            <button style={S.undoBtn} onClick={undoLastAction} disabled={undoStack.length === 0}>↩</button>
          </div>
        </div>

        {/* Serve indicator — tap to fix rotation */}
        <div style={{ ...S.serveIndicator, background: set?.weServe ? "#0a1a0a" : "#1a0a0a", display: "flex", alignItems: "center", justifyContent: "center", gap: 8, cursor: "pointer" }}
          onClick={() => setShowRotationFix(true)}>
          {set?.weServe ? (
            <span>Our serve — <strong>{getPlayerById(server)?.name?.split(" ")[0] || `#${getPlayerById(server)?.number}`}</strong> serving</span>
          ) : (
            <span>Receiving — Next server: <strong>{getPlayerById(nextServer)?.name?.split(" ")[0] || `#${getPlayerById(nextServer)?.number}`}</strong></span>
          )}
          <span style={{ fontSize: 10, opacity: 0.3, marginLeft: 4 }}>R{set?.rotation || 1} ▸</span>
        </div>

        {/* Rotation fix overlay */}
        {showRotationFix && (() => {
          const starting = set?.startingLineup || {};
          const starters = [];
          for (let z = 1; z <= 6; z++) {
            const pid = starting[z];
            if (pid) starters.push({ zone: z, player: getPlayerById(pid), id: pid });
          }
          const currentZone1 = set?.currentLineup?.[1];
          return (
            <div style={S.overlay} onClick={() => setShowRotationFix(false)}>
              <div style={{ ...S.popup, maxWidth: 340 }} onClick={(e) => e.stopPropagation()}>
                <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 12 }}>
                  <span style={{ fontWeight: 800, fontSize: 16, color: "#007bff", letterSpacing: 2 }}>FIX ROTATION</span>
                  <button style={{ background: "#2a2a34", border: "none", color: "#fff", padding: "6px 14px", borderRadius: 6, fontWeight: 700, cursor: "pointer" }}
                    onClick={() => setShowRotationFix(false)}>CLOSE</button>
                </div>
                <div style={{ fontSize: 11, opacity: 0.5, marginBottom: 12 }}>
                  Select who should be serving, then choose serve or receive.
                </div>
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 6, marginBottom: 12 }}>
                  {starters.map((s) => {
                    const isCurrent = s.id === currentZone1;
                    return (
                      <div key={s.id} style={{ display: "flex", flexDirection: "column", gap: 4 }}>
                        <button
                          style={{ padding: "10px 8px", background: isCurrent ? "#0a1525" : "#111118", border: `2px solid ${isCurrent ? "#007bff" : "#1e1e28"}`, borderRadius: 8, color: "#e2e8f0", cursor: "pointer", textAlign: "center" }}
                          onClick={() => {}}>
                          <div style={{ fontWeight: 800, fontSize: 14 }}>#{s.player?.number} {s.player?.name?.split(" ")[0]}</div>
                          <div style={{ fontSize: 9, opacity: 0.4 }}>{getEffectivePosition(s.id) || "?"} • started Z{s.zone}</div>
                        </button>
                        <div style={{ display: "flex", gap: 4 }}>
                          <button style={{ flex: 1, padding: "7px 4px", background: "#065f46", border: "none", borderRadius: 6, color: "#fff", fontSize: 10, fontWeight: 800, cursor: "pointer" }}
                            onClick={() => applyManualRotation(s.id, true)}>
                            SERVE
                          </button>
                          <button style={{ flex: 1, padding: "7px 4px", background: "#991b1b", border: "none", borderRadius: 6, color: "#fff", fontSize: 10, fontWeight: 800, cursor: "pointer" }}
                            onClick={() => applyManualRotation(s.id, false)}>
                            RECEIVE
                          </button>
                        </div>
                      </div>
                    );
                  })}
                </div>
                <div style={{ fontSize: 10, opacity: 0.3, textAlign: "center" }}>
                  Current: R{set?.rotation || 1} — {set?.weServe ? "Our serve" : "Receiving"}
                </div>
              </div>
            </div>
          );
        })()}

        {/* Formula status badge */}
        {(() => {
          const budget = getFormulaBudget(set, formulaAnalysis);
          if (budget === null) return null;
          const good = budget.pct >= 50;
          const color = good ? "#22c55e" : "#ef4444";
          const bg = good ? "#0a1a0a" : "#1a0a0a";
          return (
            <div style={{ display: "flex", justifyContent: "center", alignItems: "center", gap: 6, padding: "3px 0", background: bg, borderBottom: "1px solid #1a1a24" }}>
              <span style={{ fontSize: 9, fontWeight: 700, opacity: 0.5, letterSpacing: 1 }}>FORMULA</span>
              <span style={{ fontSize: 13, fontWeight: 800, color }}>{budget.above}/{budget.total}</span>
              <span style={{ fontSize: 9, opacity: 0.4 }}>targets hit</span>
            </div>
          );
        })()}

        {/* Tabs */}
        <div style={S.tabs}>
          {[
            { key: "court", label: "Court" },
            { key: "stats", label: "Stats" },
            { key: "formula", label: "Formula" },
            { key: "offense", label: "Offense" },
            { key: "scout", label: "Scout" },
            { key: "subs", label: "Subs" },
          ].map((t) => (
            <button key={t.key} style={{ ...S.tab, ...(tab === t.key ? S.tabActive : {}) }}
              onClick={() => setTab(t.key)}>
              {t.label}
              {t.key === "subs" && set?.subCount > 0 && (
                <span style={S.badge}>{set.subCount}</span>
              )}
            </button>
          ))}
        </div>

        {/* COURT TAB - PLAYER LIST VIEW */}
        {tab === "court" && (() => {
          try {
          const setter = getSetterOnCourt(set);
          const hitterIds = getHittersOnCourt(set) || [];
          const phase = rallyPhase === "idle" ? "pre_rally" : rallyPhase;
          const positions = [4, 3, 2, 5, 6, 1];
          const onCourtPlayerIds = Object.values(onCourt).filter((v) => typeof v === "string");

          return (
          <div style={{ ...S.matchContent, padding: "6px 8px 100px" }}>
            {/* Assist selection popup */}
            {assistPrompt && (
              <div style={S.overlay}>
                <div style={S.popup}>
                  <div style={{ fontSize: 13, fontWeight: 800, color: "#007bff", marginBottom: 10, textAlign: "center" }}>
                    Who got the assist?
                  </div>
                  <div style={{ display: "flex", flexWrap: "wrap", gap: 6, justifyContent: "center" }}>
                    {/* Sort setter first */}
                    {onCourtPlayerIds
                      .filter((id) => id !== assistPrompt.killerId)
                      .sort((a, b) => (a === setter ? -1 : b === setter ? 1 : 0))
                      .map((id) => {
                      const p = getPlayerById(id);
                      const isSt = id === setter;
                      return (
                        <button key={id} style={{
                          ...S.ib,
                          background: isSt ? "#0056b3" : "#0a1929",
                          padding: isSt ? "10px 16px" : "8px 12px",
                          fontSize: isSt ? 14 : 12,
                          border: isSt ? "2px solid #5ba3ff" : "none",
                        }} onClick={() => {
                          recordEvent(id, "assist");
                          showToast(`${p?.name?.split(" ")[0]} AST`);
                          endRally(true, { ...assistPrompt.rally, endStat: "kill", attacker: assistPrompt.killerId, assister: id });
                          setAssistPrompt(null);
                        }}>
                          {p?.name?.split(" ")[0] || `#${p?.number}`}
                          {isSt && <span style={{ fontSize: 9, opacity: 0.7, display: "block" }}>SETTER</span>}
                        </button>
                      );
                    })}
                  </div>
                  <button style={{ ...S.gb, marginTop: 10, background: "#2a2a34", width: "100%" }} onClick={() => {
                    endRally(true, { ...assistPrompt.rally, endStat: "kill", attacker: assistPrompt.killerId });
                    setAssistPrompt(null);
                  }}>No Assist</button>
                </div>
              </div>
            )}

            {/* Phase bar */}
            <div style={{
              padding: "4px 10px", borderRadius: 6, textAlign: "center", marginBottom: 3,
              background: phase === "offense" ? "#0a1a0a" : phase === "defense" ? "#1a0a0a" : set?.weServe ? "#0a1020" : "#0a1525",
            }}>
              <span style={{ fontSize: 10, fontWeight: 800, letterSpacing: 2, color: "#007bff" }}>
                {phase === "pre_rally" && set?.weServe && `SERVING \u2014 ${getPlayerById(server)?.name?.split(" ")[0] || ""}`}
                {phase === "pre_rally" && !set?.weServe && "RECEIVE"}
                {phase === "offense" && "OFFENSE \u2014 tap a stat"}
                {phase === "defense" && "DEFENSE \u2014 tap a stat"}
              </span>
            </div>

            <div style={S.rowDivider}>&mdash; FRONT &mdash;</div>

            {positions.map((pos, idx) => {
              const pid = onCourt[pos];
              // Try full roster (including bench) if main lookup fails
              let player = pid ? getPlayerById(pid) : null;
              if (!player && pid) {
                // Libero or subbed player might not match filtered roster — search full roster
                player = (currentMatch.roster||[]).find((p) => p.id === pid);
              }
              if (!player && pid) {
                // Still not found — create minimal placeholder from the ID
                console.warn("[COURT] Player not found in roster:", pid, "zone:", pos);
                player = { id: pid, name: "?", number: "?", position: "" };
              }
              if (!player) {
                // Zone is truly empty — show placeholder
                return (
                  <React.Fragment key={pos}>
                    {idx === 3 && <div style={S.rowDivider}>&mdash; BACK &mdash;</div>}
                    <div style={{ ...S.pRow, opacity: 0.3, borderLeftColor: "#991b1b" }}>
                      <div style={S.pId}>
                        <span style={S.pName}>Empty Z{pos}</span>
                      </div>
                    </div>
                  </React.Fragment>
                );
              }

              const isServer = pid === server && set?.weServe;
              const isLibero = isLiberoId(pid, set);
              const isSetter = pid === setter;
              const isHitter = hitterIds.includes(pid);
              const isPasser = passerIds.includes(pid);
              const isPrimary = primaryPasserIds.includes(pid);
              const isFront = [4, 3, 2].includes(pos);
              const firstName = player.name?.split(" ")[0] || `#${player.number}`;

              let active = true;
              if (phase === "pre_rally" && set?.weServe) active = isServer || isLibero;
              else if (phase === "pre_rally" && !set?.weServe) active = true;
              else if (phase === "offense") active = true;

              const borderColor = isServer ? "#007bff" : (phase === "pre_rally" && !set?.weServe && isPrimary) ? "#007bff" : isLibero ? "#22c55e" : isSetter ? "#5ba3ff" : isHitter && phase === "offense" ? "#007bff" : "#1e1e28";

              // SWAP logic — only on libero row, only pre_rally
              let swapBtn = null;
              if (isLibero && phase === "pre_rally") {
                const { lib1, lib2 } = getSetLiberos(set);
                const mbId = onCourt._liberoFor;
                if (mbId && (lib1 && lib2)) {
                  const options = [lib1, lib2, "self"].filter(Boolean);
                  const uniqueOptions = [...new Set(options)];
                  if (uniqueOptions.length >= 2) {
                    const currentSub = pid;
                    const currentIdx = uniqueOptions.indexOf(currentSub);
                    const nextSub = uniqueOptions[(currentIdx + 1) % uniqueOptions.length];
                    const nextLabel = nextSub === "self" ? getPlayerById(mbId)?.name?.split(" ")[0] || "MB" : getPlayerById(nextSub)?.name?.split(" ")[0] || "LIB";
                    swapBtn = (
                      <button style={{ fontSize: 9, fontWeight: 700, color: "#22c55e", background: "#0a1a0a", border: "1px solid #22c55e", borderRadius: 4, padding: "2px 6px", cursor: "pointer" }} onClick={(e) => {
                        e.stopPropagation();
                        updateCurrentSet((s) => ({ ...s, liberoSwaps: { ...(s.liberoSwaps || {}), [mbId]: nextSub } }));
                        showToast(`SWAP → ${nextLabel}`);
                      }}>SWAP</button>
                    );
                  }
                }
              }

              return (
                <div key={pos}>
                  {idx === 3 && <div style={S.rowDivider}>&mdash; BACK &mdash;</div>}
                  <div style={{
                    display: "flex", alignItems: "center", gap: 4, padding: "3px 6px",
                    background: "#0d0d14", borderRadius: 6, marginBottom: 2,
                    borderLeft: `3px solid ${borderColor}`,
                    opacity: active ? 1 : 0.25,
                  }}>
                    {/* Name + zone */}
                    <div style={{ minWidth: 48, flexShrink: 0 }}>
                      <div style={{ fontSize: 12, fontWeight: 700, lineHeight: 1.1 }}>{firstName}</div>
                      <div style={{ fontSize: 8, opacity: 0.35, lineHeight: 1 }}>Z{pos}{isServer ? " · SRV" : ""}</div>
                    </div>

                    {/* Buttons — right aligned, consistent grid */}
                    <div style={{ display: "flex", gap: 2, flex: 1, justifyContent: "flex-end", alignItems: "center", flexWrap: "nowrap" }}>

                      {/* SWAP on libero */}
                      {swapBtn}

                      {/* SERVE */}
                      {phase === "pre_rally" && set?.weServe && isServer && (
                        <>
                          <button style={S.cb} onClick={() => {
                            recordEvent(pid, "ace"); showToast(`${firstName} ACE`);
                            endRally(true, { type: "our_serve", server: pid, result: "ace" });
                          }}>ACE</button>
                          <button style={{ ...S.cb, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "serve_error"); showToast(`${firstName} ERR`);
                            endRally(false, { type: "our_serve", server: pid, result: "serve_error" });
                          }}>ERR</button>
                          <button style={{ ...S.cb, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 1 }); showToast("\u21921");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 1 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}1</button>
                          <button style={{ ...S.cb, background: "#854d0e" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 2 }); showToast("\u21922");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 2 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}2</button>
                          <button style={{ ...S.cb, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "serve_in", { forcedPass: 3 }); showToast("\u21923");
                            setCurrentRally({ type: "our_serve", server: pid, serveForced: 3 });
                            setRallyPhase("defense");
                          }}>{"\u2192"}3</button>
                        </>
                      )}

                      {/* RECEIVE */}
                      {phase === "pre_rally" && !set?.weServe && isPasser && (
                        <div style={{ display: "flex", gap: 2, opacity: isPrimary ? 1 : 0.55 }}>
                          <button style={{ ...S.cb, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 0 }); recordEvent(pid, "reception_error");
                            showToast(`${firstName} ACED`);
                            endRally(false, { type: "their_serve", passer: pid, passQuality: 0 });
                          }}>0</button>
                          <button style={{ ...S.cb, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 1 }); showToast(`${firstName} 1`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 1 });
                            setRallyPhase("offense");
                          }}>1</button>
                          <button style={{ ...S.cb, background: "#854d0e" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 2 }); showToast(`${firstName} 2`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 2 });
                            setRallyPhase("offense");
                          }}>2</button>
                          <button style={{ ...S.cb, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "reception", { quality: 3 }); showToast(`${firstName} 3`);
                            setCurrentRally({ type: "their_serve", passer: pid, passQuality: 3 });
                            setRallyPhase("offense");
                          }}>3</button>
                        </div>
                      )}

                      {/* OFFENSE: hitters — KILL | ATT E | BLKD | CVR | DUG | ERR */}
                      {phase === "offense" && isHitter && (
                        <>
                          <button style={{ ...S.cb, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "kill"); showToast(`${firstName} KILL`);
                            setAssistPrompt({ killerId: pid, rally: { ...currentRally } });
                          }}>KILL</button>
                          <button style={{ ...S.cb, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "attack_error"); showToast(`${firstName} E`);
                            endRally(false, { ...currentRally, endStat: "attack_error", attacker: pid });
                          }}>ATT E</button>
                          <button style={{ ...S.cb, background: "#0a1929" }} onClick={() => {
                            recordEvent(pid, "attack_blocked"); showToast(`${firstName} BLKD`);
                            endRally(false, { ...currentRally, endStat: "attack_blocked", attacker: pid });
                          }}>BLKD</button>
                          <button style={{ ...S.cb, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.cb, background: "#854d0e" }} onClick={() => {
                            showToast("Dug \u2192 DEF");
                            setRallyPhase("defense");
                          }}>DUG</button>
                          <button style={{ ...S.cb, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* OFFENSE: setter — SET | KILL | ATT E | BLKD | CVR | DUG | ERR */}
                      {phase === "offense" && isSetter && (
                        <>
                          <button style={{ ...S.cb, background: "#0056b3" }} onClick={() => {
                            showToast(`${firstName} SET`);
                          }}>SET</button>
                          <button style={{ ...S.cb, background: "#166534" }} onClick={() => {
                            recordEvent(pid, "kill"); showToast(`${firstName} KILL`);
                            setAssistPrompt({ killerId: pid, rally: { ...currentRally } });
                          }}>KILL</button>
                          <button style={{ ...S.cb, background: "#7f1d1d" }} onClick={() => {
                            recordEvent(pid, "attack_error"); showToast(`${firstName} E`);
                            endRally(false, { ...currentRally, endStat: "attack_error", attacker: pid });
                          }}>ATT E</button>
                          <button style={{ ...S.cb, background: "#0a1929" }} onClick={() => {
                            recordEvent(pid, "attack_blocked"); showToast(`${firstName} BLKD`);
                            endRally(false, { ...currentRally, endStat: "attack_blocked", attacker: pid });
                          }}>BLKD</button>
                          <button style={{ ...S.cb, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.cb, background: "#854d0e" }} onClick={() => {
                            showToast("Dug \u2192 DEF");
                            setRallyPhase("defense");
                          }}>DUG</button>
                          <button style={{ ...S.cb, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* OFFENSE: non-hitter/non-setter — CVR | ERR */}
                      {phase === "offense" && !isHitter && !isSetter && (
                        <>
                          <button style={{ ...S.cb, background: "#1e3a5f" }} onClick={() => {
                            recordEvent(pid, "cvr"); showToast(`${firstName} CVR`);
                          }}>CVR</button>
                          <button style={{ ...S.cb, background: "#991b1b" }} onClick={() => {
                            recordEvent(pid, "ball_error"); showToast(`${firstName} ERR`);
                            endRally(false, { ...currentRally, endStat: "ball_error" });
                          }}>ERR</button>
                        </>
                      )}

                      {/* DEFENSE */}
                      {phase === "defense" && (
                        <>
                          {isFront && (
                            <>
                              <button style={{ ...S.cb, background: "#0a1929" }} onClick={() => {
                                recordEvent(pid, "block"); showToast(`${firstName} BLK`);
                              }}>BLK</button>
                              <button style={{ ...S.cb, background: "#16a34a" }} onClick={() => {
                                recordEvent(pid, "stuff_block"); showToast(`${firstName} STUFF`);
                                endRally(true, { ...currentRally, endStat: "stuff_block", blocker: pid });
                              }}>STUFF</button>
                            </>
                          )}
                          <button style={{ ...S.cb, background: "#365314" }} onClick={() => {
                            recordEvent(pid, "dig"); showToast(`${firstName} DIG`);
                            setRallyPhase("offense");
                          }}>DIG</button>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              );
            })}

            {/* Global buttons */}
            <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: 3, marginTop: 4 }}>
              <button style={{ ...S.gb, padding: "6px 4px", fontSize: 10 }} onClick={() => {
                showToast("Opp Error +1");
                if (phase !== "pre_rally") endRally(true, { ...currentRally, endStat: "opponent_error" });
                else {
                  recordEvent(null, "opponent_error");
                  scorePoint(true);
                }
              }}>OPP ERR +1</button>
              <button style={{ ...S.gb, padding: "6px 4px", fontSize: 10, background: "#991b1b" }} onClick={() => {
                showToast("Their Kill");
                if (phase !== "pre_rally") endRally(false, { ...currentRally, endStat: "their_kill" });
                else scorePoint(false);
              }}>THEIR KILL</button>
              <button style={{ ...S.gb, padding: "6px 4px", fontSize: 10, background: "#1a1a24" }} onClick={() => { scorePoint(true); showToast("+1 Us"); }}>+US</button>
              <button style={{ ...S.gb, padding: "6px 4px", fontSize: 10, background: "#1a1a24" }} onClick={() => { scorePoint(false); showToast("+1 Them"); }}>+THEM</button>
              <button style={{ ...S.gb, padding: "6px 4px", fontSize: 10, background: "#1a3a1a", gridColumn: "1 / -1" }} onClick={() => {
                if (phase === "offense") {
                  showToast("Free Ball → DEF");
                  setRallyPhase("defense");
                } else if (phase === "defense") {
                  showToast("Free Ball → OFF");
                  setRallyPhase("offense");
                } else {
                  if (set?.weServe) {
                    showToast("Free Ball → DEF");
                    setCurrentRally({ type: "our_serve", server: server });
                    setRallyPhase("defense");
                  } else {
                    showToast("Free Ball → OFF");
                    setCurrentRally({ type: "their_serve" });
                    setRallyPhase("offense");
                  }
                }
              }}>FREE BALL</button>
            </div>

            <div style={{ display: "flex", gap: 4, marginTop: 4 }}>
              <button style={{ flex: 1, padding: 8, background: "none", border: "1px solid #007bff", borderRadius: 8, color: "#007bff", fontSize: 11, fontWeight: 700, cursor: "pointer" }} onClick={endCurrentSet}>
                End Set {set?.number}
              </button>
              <button style={{ flex: 1, padding: 8, background: "none", border: "1px solid #ef4444", borderRadius: 8, color: "#ef4444", fontSize: 11, fontWeight: 600, cursor: "pointer", opacity: 0.6 }} onClick={endMatchEarly}>
                End Match
              </button>
            </div>
          </div>
          );
          } catch (e) {
            return <div style={{ padding: 16, color: "#ef4444" }}>Court error: {e.message}. <button onClick={() => setRallyPhase("idle")} style={{ color: "#007bff", background: "none", border: "1px solid #007bff", borderRadius: 8, padding: "4px 12px", cursor: "pointer" }}>Reset</button></div>;
          }
        })()}

        {/* STATS TAB */}
        {tab === "stats" && (() => {
          // Determine which data to show
          const viewSets = currentMatch?.sets || [];
          const isMatchView = statsSetView === "match";
          const viewSetData = isMatchView ? null : (statsSetView === "current" ? set : viewSets[Number(statsSetView)]);

          // Build stats for the selected view
          const getViewStats = (playerId) => {
            const stats = {};
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.player === playerId && ev.stat !== "serve_in") stats[ev.stat] = (stats[ev.stat] || 0) + 1;
              }
            }
            return stats;
          };

          const getViewTotals = () => {
            const totals = {};
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.stat !== "serve_in") totals[ev.stat] = (totals[ev.stat] || 0) + 1;
              }
            }
            return totals;
          };

          const getViewPassingStats = (playerId) => {
            const passes = { 0: 0, 1: 0, 2: 0, 3: 0 };
            let total = 0;
            const setsToScan = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
            for (const s of setsToScan) {
              for (const ev of (s.events || [])) {
                if (ev.player === playerId && ev.stat === "reception" && ev.quality !== undefined) {
                  passes[ev.quality] = (passes[ev.quality] || 0) + 1;
                  total++;
                }
              }
            }
            if (total === 0) return null;
            let weightedSum = 0, weightTotal = 0;
            for (const [q, count] of Object.entries(passes)) {
              const w = PASS_WEIGHTS[q] || 0;
              weightedSum += Number(q) * w * count;
              weightTotal += w * count;
            }
            return { passes, total, weightedScore: weightTotal > 0 ? weightedSum / weightTotal : 0, simpleAvg: (passes[0]*0+passes[1]*1+passes[2]*2+passes[3]*3)/total };
          };

          const vTotals = getViewTotals();
          const viewLabel = isMatchView ? "MATCH" : (statsSetView === "current" ? `SET ${set?.number}` : `SET ${Number(statsSetView) + 1}`);

          // Player Impact Rating for current view
          const viewPIS = {};
          const setsForPIS = isMatchView ? viewSets : (viewSetData ? [viewSetData] : []);
          const mult = getFormulaMultipliers();
          for (const p of rosterPlayers) {
            const allEvts = [];
            for (const s of setsForPIS) for (const ev of (s.events || [])) allEvts.push(ev);
            const pis = calculatePlayerImpact(allEvts, p.id, mult);
            viewPIS[p.id] = pis;
          }

          return (
          <div style={S.matchContent}>
            {/* Set selector */}
            <div style={{ display: "flex", gap: 4, marginBottom: 8, flexWrap: "wrap" }}>
              {viewSets.map((s, i) => (
                <button key={i} style={{ ...S.ib, background: (statsSetView === "current" && i === currentSetIdx) || statsSetView === String(i) ? "#007bff" : "#1a1a24", color: (statsSetView === "current" && i === currentSetIdx) || statsSetView === String(i) ? "#000" : "#e2e8f0", fontWeight: 700, fontSize: 11, padding: "6px 10px" }}
                  onClick={() => setStatsSetView(i === currentSetIdx ? "current" : String(i))}>
                  S{s.number} ({s.ourScore}-{s.theirScore})
                </button>
              ))}
              {viewSets.length > 1 && (
                <button style={{ ...S.ib, background: isMatchView ? "#007bff" : "#1a1a24", color: isMatchView ? "#000" : "#e2e8f0", fontWeight: 700, fontSize: 11, padding: "6px 10px" }}
                  onClick={() => setStatsSetView("match")}>
                  MATCH
                </button>
              )}
            </div>

            {/* Player stats table */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>PLAYER STATS &mdash; {viewLabel}</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>PIR</th>
                      <th style={S.sth}>K</th>
                      <th style={S.sth}>AE</th>
                      <th style={S.sth}>Att</th>
                      <th style={S.sth}>Att%</th>
                      <th style={S.sth}>A</th>
                      <th style={S.sth}>SA</th>
                      <th style={S.sth}>SE</th>
                      <th style={S.sth}>D</th>
                      <th style={S.sth}>CV</th>
                      <th style={S.sth}>BK</th>
                      <th style={S.sth}>SB</th>
                      <th style={S.sth}>BE</th>
                      <th style={S.sth}>R</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rosterPlayers.map((p) => {
                      const ps = getViewStats(p.id);
                      const att = (ps.kill || 0) + (ps.attack_error || 0) + (ps.attack_blocked || 0);
                      const kPct = att > 0 ? ((ps.kill || 0) - (ps.attack_error || 0)) / att : null;
                      const pis = viewPIS[p.id] || { total: 0 };
                      const hasStats = Object.keys(ps).length > 0 || pis.total !== 0;
                      if (!hasStats) return null;
                      return (
                        <tr key={p.id}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>{p.name?.split(" ")[0] || `#${p.number}`}</td>
                          <td style={{ ...S.std, fontWeight: 800, color: pis.total > 0 ? "#22c55e" : pis.total < 0 ? "#ef4444" : "#6b7280" }}>{pis.total > 0 ? "+" : ""}{pis.total.toFixed(1)}</td>
                          <td style={{ ...S.std, color: (ps.kill || 0) > 0 ? "#22c55e" : "#6b7280" }}>{ps.kill || 0}</td>
                          <td style={{ ...S.std, color: (ps.attack_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.attack_error || 0}</td>
                          <td style={S.std}>{att}</td>
                          <td style={{ ...S.std, fontWeight: 700, color: kPct !== null && kPct > 0 ? "#22c55e" : kPct !== null && kPct < 0 ? "#ef4444" : "#6b7280" }}>{kPct === null ? "-" : (kPct >= 0 ? "." : "-.") + Math.abs(Math.round(kPct * 1000)).toString().padStart(3, "0")}</td>
                          <td style={{ ...S.std, color: "#5ba3ff" }}>{ps.assist || 0}</td>
                          <td style={{ ...S.std, color: "#007bff" }}>{ps.ace || 0}</td>
                          <td style={{ ...S.std, color: (ps.serve_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.serve_error || 0}</td>
                          <td style={S.std}>{ps.dig || 0}</td>
                          <td style={{ ...S.std, color: "#60a5fa" }}>{ps.cvr || 0}</td>
                          <td style={S.std}>{ps.block || 0}</td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{ps.stuff_block || 0}</td>
                          <td style={{ ...S.std, color: (ps.ball_error || 0) > 0 ? "#ef4444" : "#6b7280" }}>{ps.ball_error || 0}</td>
                          <td style={S.std}>{ps.reception || 0}</td>
                        </tr>
                      );
                    })}
                    {/* Team totals */}
                    <tr style={{ borderTop: "2px solid #007bff" }}>
                      <td style={{ ...S.std, fontWeight: 800, color: "#007bff" }}>TEAM</td>
                      <td style={{ ...S.std, fontWeight: 800 }}></td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.kill || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.attack_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{(vTotals.kill || 0) + (vTotals.attack_error || 0) + (vTotals.attack_blocked || 0)}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{(() => { const a = (vTotals.kill||0)+(vTotals.attack_error||0)+(vTotals.attack_blocked||0); return a > 0 ? (((vTotals.kill||0)-(vTotals.attack_error||0))/a >= 0 ? "." : "-.") + Math.abs(Math.round(((vTotals.kill||0)-(vTotals.attack_error||0))/a*1000)).toString().padStart(3, "0") : "-"; })()}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.assist || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.ace || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.serve_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.dig || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.cvr || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.block || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.stuff_block || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.ball_error || 0}</td>
                      <td style={{ ...S.std, fontWeight: 800 }}>{vTotals.reception || 0}</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>

            {/* PLAYER IMPACT RANKINGS */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>IMPACT RANKINGS &mdash; {viewLabel}</h3>
              {formulaAnalysis?.hasEnoughData && (
                <div style={{ fontSize: 9, opacity: 0.35, textAlign: "center", marginBottom: 6 }}>
                  {formulaAnalysis.tier === "established" ? "Formula-weighted" : "Formula developing"} | {formulaAnalysis.totalSets} sets
                </div>
              )}
              {rosterPlayers
                .map(p => ({ player: p, pis: viewPIS[p.id] || { total: 0, breakdown: { offense: 0, serving: 0, passing: 0, blocking: 0, defense: 0, cover: 0, setting: 0 } } }))
                .filter(r => r.pis.total !== 0 || Object.values(r.pis.breakdown).some(v => v !== 0))
                .sort((a, b) => b.pis.total - a.pis.total)
                .map((r, i) => {
                  const { player: p, pis } = r;
                  const maxAbs = Math.max(1, ...Object.values(pis.breakdown).map(Math.abs));
                  const cats = [
                    { key: "offense", label: "OFF", color: "#22c55e" },
                    { key: "serving", label: "SRV", color: "#007bff" },
                    { key: "passing", label: "PAS", color: "#eab308" },
                    { key: "blocking", label: "BLK", color: "#a855f7" },
                    { key: "defense", label: "DEF", color: "#60a5fa" },
                    { key: "cover", label: "CVR", color: "#14b8a6" },
                    { key: "setting", label: "SET", color: "#f472b6" },
                  ];
                  return (
                    <div key={p.id} style={{ padding: "6px 0", borderBottom: i < rosterPlayers.length - 1 ? "1px solid #1a1a24" : "none" }}>
                      <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 3 }}>
                        <span style={{ fontWeight: 700, fontSize: 12 }}>#{p.number} {p.name?.split(" ")[0]}</span>
                        <span style={{ fontWeight: 800, fontSize: 14, color: pis.total > 0 ? "#22c55e" : pis.total < 0 ? "#ef4444" : "#6b7280" }}>
                          {pis.total > 0 ? "+" : ""}{pis.total.toFixed(1)}
                        </span>
                      </div>
                      <div style={{ display: "flex", gap: 2, height: 10 }}>
                        {cats.map(c => {
                          const val = pis.breakdown[c.key] || 0;
                          if (val === 0) return null;
                          const w = Math.max(4, Math.abs(val) / maxAbs * 100);
                          return (
                            <div key={c.key} title={`${c.label}: ${val > 0 ? "+" : ""}${val.toFixed(1)}`}
                              style={{ height: "100%", borderRadius: 2, width: `${w}%`, background: val > 0 ? c.color : "#ef4444", opacity: 0.7 }} />
                          );
                        })}
                      </div>
                      <div style={{ display: "flex", gap: 6, marginTop: 2, flexWrap: "wrap" }}>
                        {cats.map(c => {
                          const val = pis.breakdown[c.key] || 0;
                          if (val === 0) return null;
                          return (
                            <span key={c.key} style={{ fontSize: 8, color: c.color, opacity: 0.6 }}>
                              {c.label} {val > 0 ? "+" : ""}{val.toFixed(1)}
                            </span>
                          );
                        })}
                      </div>
                    </div>
                  );
                })}
            </div>

            {/* Passing Stats */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>PASSING &mdash; {viewLabel}</h3>
              <div style={{ overflowX: "hidden" }}>
                <table style={S.statsTable}>
                  <thead>
                    <tr>
                      <th style={S.sth}>Player</th>
                      <th style={S.sth}>Tot</th>
                      <th style={S.sth}>3s</th>
                      <th style={S.sth}>2s</th>
                      <th style={S.sth}>1s</th>
                      <th style={S.sth}>0s</th>
                      <th style={S.sth}>Avg</th>
                      <th style={S.sth}>Wtd</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rosterPlayers.map((p) => {
                      const ps = getViewPassingStats(p.id);
                      if (!ps) return null;
                      const wtdColor = ps.weightedScore >= 2.5 ? "#22c55e" : ps.weightedScore >= 2.0 ? "#007bff" : "#ef4444";
                      return (
                        <tr key={p.id}>
                          <td style={{ ...S.std, fontWeight: 700, whiteSpace: "nowrap" }}>{p.name?.split(" ")[0] || `#${p.number}`}</td>
                          <td style={S.std}>{ps.total}</td>
                          <td style={{ ...S.std, color: "#22c55e" }}>{ps.passes[3]}</td>
                          <td style={{ ...S.std, color: "#007bff" }}>{ps.passes[2]}</td>
                          <td style={{ ...S.std, color: "#ef4444" }}>{ps.passes[1]}</td>
                          <td style={{ ...S.std, color: "#7f1d1d", fontWeight: 700 }}>{ps.passes[0]}</td>
                          <td style={S.std}>{ps.simpleAvg.toFixed(1)}</td>
                          <td style={{ ...S.std, fontWeight: 800, color: wtdColor }}>{ps.weightedScore.toFixed(2)}</td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
              <div style={{ fontSize: 9, opacity: 0.4, marginTop: 6, textAlign: "center" }}>
                Wtd = Weighted score (3&rarr;1.5x, 2&rarr;1.0x, 1&rarr;0.5x, 0&rarr;0x). 2.5+ = elite, 2.0-2.4 = solid, &lt;2.0 = needs work
              </div>
            </div>
          </div>
          );
        })()}

        {/* FORMULA TAB - Dynamic Win/Loss Analysis */}
        {tab === "formula" && (
          <div style={S.matchContent}>
            {/* Dynamic formula from match history */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>YOUR WINNING FORMULA</h3>
              {!formulaAnalysis.hasEnoughData ? (
                <div style={{ textAlign: "center", padding: "16px 8px" }}>
                  <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 12 }}>
                    BUILDING YOUR FORMULA
                  </div>
                  <div style={{ display: "flex", alignItems: "center", gap: 6, justifyContent: "center", marginBottom: 12 }}>
                    {[1,2,3,4,5,6,7,8].map((n) => (
                      <div key={n} style={{
                        width: 28, height: 28, borderRadius: 6,
                        background: n <= (formulaAnalysis.totalSets || 0) ? "#007bff" : "#1e1e28",
                        border: n <= (formulaAnalysis.totalSets || 0) ? "none" : "1px solid #2a2a34",
                        display: "flex", alignItems: "center", justifyContent: "center",
                        fontSize: 11, fontWeight: 800,
                        color: n <= (formulaAnalysis.totalSets || 0) ? "#fff" : "#4b5563",
                      }}>{n}</div>
                    ))}
                  </div>
                  <div style={{ fontSize: 12, opacity: 0.5, marginBottom: 4 }}>
                    {(formulaAnalysis.totalSets || 0)} of 8 sets completed
                  </div>
                  <div style={{ fontSize: 11, opacity: 0.35 }}>
                    {(formulaAnalysis.totalSets || 0) === 0
                      ? "Your Winning Formula is built from patterns in your wins and losses. Keep tracking to unlock it."
                      : (formulaAnalysis.wonSets || 0) === 0 || (formulaAnalysis.lostSets || 0) === 0
                        ? "Need both wins and losses to find the patterns. Keep competing."
                        : `${Math.max(0, 8 - (formulaAnalysis.totalSets || 0))} more set${8 - (formulaAnalysis.totalSets || 0) === 1 ? "" : "s"} to go. The formula learns what separates your wins from your losses.`}
                  </div>
                </div>
              ) : (
                <>
                  <p style={S.cardSub}>
                    {formulaAnalysis.tier === "established"
                      ? `Well-established across ${formulaAnalysis.totalSets} sets. These priorities reflect consistent patterns.`
                      : `Taking shape based on ${formulaAnalysis.totalSets} sets (${formulaAnalysis.wonSets}W / ${formulaAnalysis.lostSets}L). Priorities are becoming clearer as more data comes in.`}
                    {" "}Strength: {formulaAnalysis.formulaStrength}%
                  </p>
                  {formulaAnalysis.narrative && (
                    <div style={{ fontSize: 11, fontStyle: "italic", opacity: 0.6, textAlign: "center", marginBottom: 10, padding: "0 8px" }}>
                      {formulaAnalysis.narrative}
                    </div>
                  )}

                  {/* Priority variables with current set comparison */}
                  {formulaAnalysis.variables.filter(v => v.priorityZone !== "low_relationship").map((v) => {
                    const currentSetVal = setProgress.currentVars[v.name] ?? 0;
                    const isInverse = v.name === "reception_error_rate";
                    const onTarget = v.threshold !== null && (isInverse ? currentSetVal <= v.threshold : currentSetVal >= v.threshold);
                    const zoneColor = v.priorityZone === "high_impact" ? "#ef4444" : v.priorityZone === "moderate_impact" ? "#eab308" : "#22c55e";
                    const zoneLabel = v.priorityZone === "high_impact" ? "PRIORITY" : v.priorityZone === "moderate_impact" ? "SECONDARY" : "ON TARGET";
                    const pct = v.threshold ? Math.min(Math.max((isInverse ? (v.threshold / Math.max(currentSetVal, 0.001)) : (currentSetVal / Math.max(v.threshold, 0.001))) * 100, 0), 100) : 0;
                    const trendIcon = v.trend === "improving" ? "↑" : v.trend === "declining" ? "↓" : "→";
                    const trendColor = v.trend === "improving" ? "#22c55e" : v.trend === "declining" ? "#ef4444" : "#9ca3af";

                    return (
                      <div key={v.name} style={{ marginBottom: 10 }}>
                        <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginBottom: 3 }}>
                          <div style={{ display: "flex", alignItems: "center", gap: 6 }}>
                            <span style={{ fontWeight: 700, fontSize: 12 }}>{v.displayName}</span>
                            <span style={{ fontSize: 7, fontWeight: 800, color: zoneColor, background: zoneColor + "22", padding: "1px 4px", borderRadius: 3, letterSpacing: 0.5 }}>{zoneLabel}</span>
                          </div>
                          <div style={{ display: "flex", alignItems: "center", gap: 4 }}>
                            <span style={{ fontSize: 11, fontWeight: 800, color: onTarget ? "#22c55e" : "#ef4444" }}>{v.format(currentSetVal)}</span>
                            {v.threshold !== null && <span style={{ opacity: 0.4, fontSize: 10 }}>/ {v.format(v.threshold)}</span>}
                          </div>
                        </div>
                        {v.threshold !== null && (
                          <div style={{ background: "#1a1a24", borderRadius: 6, height: 12, overflow: "hidden" }}>
                            <div style={{ height: "100%", borderRadius: 6, background: zoneColor, width: `${pct}%`, opacity: 0.75 }} />
                          </div>
                        )}
                        <div style={{ display: "flex", justifyContent: "space-between", fontSize: 9, marginTop: 2 }}>
                          <div style={{ display: "flex", gap: 6, opacity: 0.4 }}>
                            <span>{v.domain}</span>
                            <span>Avg: {v.format(v.currentAvg)}</span>
                            <span style={{ color: trendColor }}>{trendIcon} {v.trend}</span>
                          </div>
                          {v.winAbove !== null && v.winBelow !== null && (
                            <span style={{ opacity: 0.35 }}>Win: {v.winAbove}% above / {v.winBelow}% below</span>
                          )}
                        </div>
                        {/* Zone-specific guidance per spec */}
                        {v.priorityZone === "high_impact" && v.totalGain > 0 && (
                          <div style={{ fontSize: 9, color: "#ef4444", opacity: 0.7, marginTop: 2, fontStyle: "italic" }}>
                            Pushing above {v.format(v.threshold)} is worth ~{v.totalGain} win% pts
                          </div>
                        )}
                      </div>
                    );
                  })}

                  {/* Low relationship variables (collapsed) */}
                  {formulaAnalysis.variables.filter(v => v.priorityZone === "low_relationship").length > 0 && (
                    <div style={{ marginTop: 8, padding: "6px 8px", background: "#0d0d14", borderRadius: 6 }}>
                      <div style={{ fontSize: 9, fontWeight: 700, opacity: 0.3, letterSpacing: 1, marginBottom: 4 }}>LOW RELATIONSHIP</div>
                      <div style={{ fontSize: 10, opacity: 0.3 }}>
                        {formulaAnalysis.variables.filter(v => v.priorityZone === "low_relationship").map(v => v.displayName).join(", ")}
                      </div>
                    </div>
                  )}

                  {/* Headline insight */}
                  {formulaAnalysis.headline && (
                    <div style={{ ...S.insightBox, marginTop: 10 }}>
                      <span style={S.insightLabel}>TOP OPPORTUNITY</span>
                      <p style={S.insightText}>{formulaAnalysis.headline.message}</p>
                    </div>
                  )}
                </>
              )}
            </div>

            {/* Current set scoring progress */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>SET {set?.number} SCORING</h3>
              <p style={S.cardSub}>{setProgress.totalScored} points scored</p>
              <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, margin: "10px 0" }}>
                {setProgress.stats.filter((s) => s.scoring).map((s) => (
                  <div key={s.key} style={{ textAlign: "center" }}>
                    <div style={{ fontSize: 22, fontWeight: 800, color: s.actual > 0 ? "#22c55e" : "#4b5563" }}>{s.actual}</div>
                    <div style={{ fontSize: 9, opacity: 0.5 }}>{s.label}</div>
                  </div>
                ))}
              </div>
              {setProgress.totalScored > setProgress.eventScored && (
                <div style={{ fontSize: 9, opacity: 0.3, textAlign: "center", marginBottom: 4 }}>
                  {setProgress.totalScored - setProgress.eventScored} point{setProgress.totalScored - setProgress.eventScored !== 1 ? "s" : ""} not categorized (use OPP ERR or stat buttons)
                </div>
              )}
              <div style={S.remainingBox}>
                <span style={{ fontSize: 28, fontWeight: 800, color: setProgress.remaining <= 5 ? "#22c55e" : "#007bff" }}>
                  {setProgress.remaining}
                </span>
                <span style={{ fontSize: 12, opacity: 0.6 }}>points to go</span>
              </div>
            </div>

            {/* Serve Risk */}
            <div style={S.card}>
              <h3 style={S.cardTitle}>SERVE RISK</h3>
              <div style={{ display: "flex", gap: 16, justifyContent: "center", margin: "12px 0" }}>
                <div style={S.statCol}>
                  <span style={{ color: "#007bff", fontSize: 22, fontWeight: 800 }}>{serveRisk.aces}</span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Aces</span>
                </div>
                <div style={S.statCol}>
                  <span style={{ color: "#ef4444", fontSize: 22, fontWeight: 800 }}>{serveRisk.errors}</span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Errors</span>
                </div>
                <div style={S.statCol}>
                  <span style={{ color: serveRisk.net > 0 ? "#22c55e" : "#ef4444", fontSize: 22, fontWeight: 800 }}>
                    {serveRisk.net > 0 ? "+" : ""}{serveRisk.net}
                  </span>
                  <span style={{ fontSize: 10, opacity: 0.5 }}>Net</span>
                </div>
              </div>
              <p style={{ fontSize: 13, textAlign: "center", opacity: 0.7, fontStyle: "italic", margin: 0 }}>
                {serveRisk.recommendation}
              </p>
            </div>

            {/* Serve-to-Rally Correlation */}
            {(() => {
              const corr = getServeCorrelation();
              const hasData = Object.values(corr.ourServes).some((v) => v.total > 0) || Object.values(corr.theirServes).some((v) => v.total > 0);
              if (!hasData) return null;
              return (
                <div style={S.card}>
                  <h3 style={S.cardTitle}>SERVE &rarr; RALLY CORRELATION</h3>
                  {Object.values(corr.ourServes).some((v) => v.total > 0) && (
                    <div style={{ marginBottom: 16 }}>
                      <span style={S.corrLabel}>OUR SERVE &mdash; Win % by forced pass</span>
                      <div style={{ display: "flex", gap: 12, marginTop: 8 }}>
                        {[1, 2, 3].map((q) => {
                          const d = corr.ourServes[q];
                          const winPct = d.total > 0 ? Math.round((d.won / d.total) * 100) : 0;
                          return (
                            <div key={q} style={S.corrCol}>
                              <span style={{ fontSize: 11, opacity: 0.5 }}>{q}-pass</span>
                              <span style={{ fontSize: 20, fontWeight: 800, color: winPct >= 60 ? "#22c55e" : winPct >= 40 ? "#007bff" : "#ef4444" }}>
                                {d.total > 0 ? `${winPct}%` : "-"}
                              </span>
                              <span style={{ fontSize: 10, opacity: 0.4 }}>{d.total} rallies</span>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}
                  {Object.values(corr.theirServes).some((v) => v.total > 0) && (
                    <div>
                      <span style={S.corrLabel}>OUR RECEIVE &mdash; Win % by our pass</span>
                      <div style={{ display: "flex", gap: 12, marginTop: 8 }}>
                        {[1, 2, 3].map((q) => {
                          const d = corr.theirServes[q];
                          const winPct = d.total > 0 ? Math.round((d.won / d.total) * 100) : 0;
                          return (
                            <div key={q} style={S.corrCol}>
                              <span style={{ fontSize: 11, opacity: 0.5 }}>{q}-pass</span>
                              <span style={{ fontSize: 20, fontWeight: 800, color: winPct >= 60 ? "#22c55e" : winPct >= 40 ? "#007bff" : "#ef4444" }}>
                                {d.total > 0 ? `${winPct}%` : "-"}
                              </span>
                              <span style={{ fontSize: 10, opacity: 0.4 }}>{d.total} rallies</span>
                            </div>
                          );
                        })}
                      </div>
                    </div>
                  )}
                </div>
              );
            })()}

            {/* Set history */}
            {((currentMatch.sets||[])).filter((s) => s.complete).length > 0 && (
              <div style={S.card}>
                <h3 style={S.cardTitle}>SET HISTORY</h3>
                {((currentMatch.sets||[])).filter((s) => s.complete).map((s, i) => {
                  const st = getSetTotals(s);
                  return (
                    <div key={i} style={S.setHistoryRow}>
                      <div style={{ display: "flex", justifyContent: "space-between" }}>
                        <span style={{ fontWeight: 700 }}>Set {s.number}</span>
                        <span style={{ color: s.ourScore > s.theirScore ? "#22c55e" : "#ef4444", fontWeight: 700 }}>
                          {s.ourScore}-{s.theirScore}
                        </span>
                      </div>
                      <div style={{ fontSize: 11, opacity: 0.6, marginTop: 4 }}>
                        K:{st.kill || 0} SB:{st.stuff_block || 0} A:{st.ace || 0} OE:{st.opponent_error || 0} SE:{st.serve_error || 0}
                      </div>
                    </div>
                  );
                })}
              </div>
            )}
          </div>
        )}

        {/* OFFENSE TAB */}
        {tab === "offense" && (
          <div style={S.matchContent}>
            <div style={S.card}>
              <h3 style={S.cardTitle}>OFFENSE</h3>
              <p style={S.cardSub}>Set {set?.number} &bull; {totalSwings} total attacks</p>
              {swingDist.filter((d) => d.attacks > 0).length === 0 ? (
                <p style={{ textAlign: "center", opacity: 0.4, padding: 24, fontSize: 14 }}>No attacks yet</p>
              ) : (
                swingDist.filter((d) => d.attacks > 0).map((d, i) => {
                  const pct = totalSwings > 0 ? (d.attacks / totalSwings) * 100 : 0;
                  return (
                    <div key={i} style={{ marginBottom: 12 }}>
                      <div style={{ display: "flex", justifyContent: "space-between", marginBottom: 3 }}>
                        <span style={{ fontWeight: 600 }}>
                          {d.player.name?.split(" ")[0] || `#${d.player.number}`}
                          <span style={{ fontSize: 10, opacity: 0.4, marginLeft: 4 }}>{d.player.position}</span>
                        </span>
                        <span style={{ fontSize: 12 }}>
                          {d.attacks}att ({d.kills}K/{d.errors}E/{d.blocked}B) {d.killPct !== null ? (d.killPct >= 0 ? "." : "-.") + Math.abs(Math.round(d.killPct * 1000)).toString().padStart(3, "0") : "-"}
                        </span>
                      </div>
                      <div style={S.progressBg}>
                        <div style={{ ...S.progressFill, width: `${pct}%`, background: pct > 30 ? "#007bff" : "#3b82f6" }} />
                      </div>
                    </div>
                  );
                })
              )}
            </div>
          </div>
        )}

        {/* SCOUT TAB - Opponent Shot Chart */}
        {tab === "scout" && (() => {
          const shots = set?.shots || [];
          const ZONES = [
            { id: 1, label: "Z1" }, { id: 6, label: "Z6" }, { id: 5, label: "Z5" },
            { id: 2, label: "Z2" }, { id: 3, label: "Z3" }, { id: 4, label: "Z4" },
          ];
          const outcomeColor = { kill: "#ef4444", dug: "#007bff", error: "#3b82f6" };
          const COURT_H = 200;

          const handleCourtTap = (e, manualX, manualY) => {
            if (!scoutPending) return;
            let x, y;
            if (e && e.currentTarget) { const rect = e.currentTarget.getBoundingClientRect(); x = ((e.clientX - rect.left) / rect.width) * 100; y = ((e.clientY - rect.top) / rect.height) * 100; }
            else { x = manualX; y = manualY; }
            const shot = { id: Date.now().toString(), originZone: scoutPending.originZone, outcome: scoutPending.outcome, x: Math.round(x * 10) / 10, y: Math.round(y * 10) / 10, timestamp: Date.now() };
            updateCurrentSet((s) => ({ ...s, shots: [...(s.shots || []), shot] }));
            const isOOB = x < 0 || x > 100 || y < 0 || y > 100;
            showToast(`${({ kill: "KILL", dug: "DUG", error: "ERR" })[scoutPending.outcome]}${isOOB ? " (OUT)" : ""} from Z${scoutPending.originZone}`);
            setScoutPending(null);
          };
          const undoLastShot = () => { updateCurrentSet((s) => ({ ...s, shots: (s.shots || []).slice(0, -1) })); showToast("Shot removed"); };

          const getOriginStats = () => { const stats = {}; for (const z of ZONES) { const zs = shots.filter((s) => s.originZone === z.id); stats[z.id] = { kills: zs.filter((s) => s.outcome === "kill").length, dug: zs.filter((s) => s.outcome === "dug").length, errors: zs.filter((s) => s.outcome === "error").length, total: zs.length }; } return stats; };
          const originStats = getOriginStats();
          const filteredShots = scoutOriginFilter !== null ? shots.filter((s) => s.originZone === scoutOriginFilter) : shots;

          const courtSvg = (shotList, interactive) => {
            const W = 300, H = COURT_H, PAD = 14, TW = W + PAD * 2, TH = H + PAD * 2;
            const inB = shotList.filter((s) => s.x >= 0 && s.x <= 100 && s.y >= 0 && s.y <= 100);
            const oob = shotList.filter((s) => s.x < 0 || s.x > 100 || s.y < 0 || s.y > 100);
            const handleSvgClick = (e) => { if (!scoutPending) return; const rect = e.currentTarget.getBoundingClientRect(); const rx = (e.clientX-rect.left)/rect.width*TW, ry = (e.clientY-rect.top)/rect.height*TH; handleCourtTap(null, ((rx-PAD)/W)*100, ((ry-PAD)/H)*100); };
            const COLS = 20, ROWS = 14, cellW = W / COLS, cellH = H / ROWS, RAD = 3.5;
            const heatCells = [];
            if (!interactive && inB.length > 0) {
              const grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
              let maxD = 0;
              for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
                let d = 0;
                for (const s of inB) { const dist = Math.sqrt(((s.x/100*COLS)-c)**2+((s.y/100*ROWS)-r)**2); if (dist < RAD) d += Math.exp(-(dist*dist)/(RAD*0.7)); }
                grid[r][c] = d; if (d > maxD) maxD = d;
              }
              const hc = (val) => {
                if (maxD === 0) return "transparent";
                const t = val / maxD;
                if (t < 0.05) return "transparent";
                const st = [[0.05,0,0,180,0.3],[0.2,0,100,255,0.45],[0.35,0,200,200,0.55],[0.5,0,220,0,0.65],[0.65,180,220,0,0.7],[0.8,255,180,0,0.8],[1.0,255,40,0,0.9]];
                let lo = st[0], hi = st[st.length-1];
                for (let i = 0; i < st.length-1; i++) { if (t >= st[i][0] && t <= st[i+1][0]) { lo = st[i]; hi = st[i+1]; break; } }
                const f = (t-lo[0])/(hi[0]-lo[0]||1), lerp = (a,b) => Math.round(a+(b-a)*f);
                return `rgba(${lerp(lo[1],hi[1])},${lerp(lo[2],hi[2])},${lerp(lo[3],hi[3])},${(lo[4]+(hi[4]-lo[4])*f).toFixed(2)})`;
              };
              for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) { if (grid[r][c] > maxD * 0.05) heatCells.push(<rect key={`h${r}-${c}`} x={PAD+c*cellW} y={PAD+r*cellH} width={cellW+0.5} height={cellH+0.5} fill={hc(grid[r][c])} />); }
            }
            return (
              <div style={{ position: "relative", width: "100%", cursor: interactive && scoutPending ? "crosshair" : "default", userSelect: "none", touchAction: "none", borderRadius: 8, overflow: "hidden" }}
                onClick={interactive ? handleSvgClick : undefined}>
                <svg width="100%" viewBox={`0 0 ${TW} ${TH}`} style={{ display: "block" }}>
                  <rect x="0" y="0" width={TW} height={TH} fill="#0a0a0f" />
                  <rect x={PAD} y={PAD} width={W} height={H} fill="#0d1118" stroke="#2a2a34" strokeWidth="2" />
                  {interactive && scoutPending && <><text x={TW/2} y={PAD/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text><text x={TW/2} y={TH-PAD/2+4} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700" letterSpacing="2">OUT</text><text x={PAD/2} y={TH/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text><text x={TW-PAD/2} y={TH/2+3} fill="#ef444460" fontSize="8" textAnchor="middle" fontWeight="700">OUT</text></>}
                  {heatCells}
                  <line x1={PAD} y1={PAD+H*0.33} x2={PAD+W} y2={PAD+H*0.33} stroke={interactive?"#2a2a34":"#ffffff33"} strokeWidth="2" strokeDasharray="8,4" />
                  <line x1={PAD+100} y1={PAD} x2={PAD+100} y2={PAD+H} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  <line x1={PAD+200} y1={PAD} x2={PAD+200} y2={PAD+H} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  <line x1={PAD} y1={PAD+H*0.5} x2={PAD+W} y2={PAD+H*0.5} stroke={interactive?"#1a1a24":"#ffffff15"} strokeWidth="0.5" />
                  {interactive && inB.map((s, i) => (<circle key={s.id||i} cx={PAD+s.x*W/100} cy={PAD+s.y*H/100} r={5} fill={outcomeColor[s.outcome]||"#999"} opacity={0.9} stroke="#000" strokeWidth="0.5" />))}
                  {interactive && oob.map((s, i) => { const ox = Math.max(3,Math.min(TW-3,PAD+s.x*W/100)), oy = Math.max(3,Math.min(TH-3,PAD+s.y*H/100)); return <circle key={`o${i}`} cx={ox} cy={oy} r={4} fill={outcomeColor[s.outcome]||"#999"} opacity={0.7} stroke="#ef4444" strokeWidth="0.5" />; })}
                  {!interactive && inB.map((s, i) => (<circle key={s.id||i} cx={PAD+s.x*W/100} cy={PAD+s.y*H/100} r={2} fill="#fff" opacity={0.7} />))}
                </svg>
                {interactive && scoutPending && shotList.length === 0 && (<div style={{ position: "absolute", top: "50%", left: "50%", transform: "translate(-50%,-50%)", pointerEvents: "none", fontSize: 11, fontWeight: 700, color: "#007bff", opacity: 0.4, letterSpacing: 1, textAlign: "center" }}>TAP EXACT SPOT<br/>BALL LANDED</div>)}
              </div>
            );
          };

          return (
          <div style={S.matchContent}>
            <div style={{ display: "flex", gap: 4, marginBottom: 8 }}>
              <button style={{ ...S.gb, flex: 1, background: scoutView === "input" ? "#007bff" : "#1a1a24", color: scoutView === "input" ? "#000" : "#fff" }} onClick={() => { setScoutView("input"); setScoutPending(null); setScoutOriginFilter(null); }}>+ Log</button>
              <button style={{ ...S.gb, flex: 1, background: scoutView === "heatmap" ? "#007bff" : "#1a1a24", color: scoutView === "heatmap" ? "#000" : "#fff" }} onClick={() => { setScoutView("heatmap"); setScoutPending(null); setScoutOriginFilter(null); }}>Heat Map ({shots.length})</button>
            </div>

            {scoutView === "input" && (
              <div>
                <div style={{ fontSize: 10, fontWeight: 700, color: "#007bff", letterSpacing: 1, textAlign: "center", marginBottom: 6 }}>
                  {!scoutPending ? "STEP 1: TAP ORIGIN + OUTCOME" : "STEP 2: TAP WHERE BALL LANDED"}
                </div>
                <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "1fr 1fr", gap: 2, background: "#0f1218", borderRadius: "8px", overflow: "hidden", border: "2px solid #2a2a34"}}>
                  {ZONES.map((z) => {
                    const os = originStats[z.id];
                    const isPending = scoutPending?.originZone === z.id;
                    return (
                      <div key={z.id} style={{ background: isPending ? "#0a1929" : "#0d0d14", padding: 4, minHeight: 54, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", opacity: scoutPending ? (isPending ? 1 : 0.25) : 1, position: "relative", border: isPending ? "2px solid #007bff" : "1px solid transparent" }}>
                        <span style={{ fontSize: 8, opacity: 0.3, position: "absolute", top: 2, left: 4 }}>{z.id}</span>
                        <div style={{ display: "flex", gap: 4 }}>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #ef4444", background: isPending && scoutPending.outcome === "kill" ? "#ef4444" : "transparent", color: isPending && scoutPending.outcome === "kill" ? "#000" : "#ef4444", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "kill" })}>K</button>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #007bff", background: isPending && scoutPending.outcome === "dug" ? "#007bff" : "transparent", color: isPending && scoutPending.outcome === "dug" ? "#000" : "#007bff", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "dug" })}>D</button>
                          <button style={{ width: 28, height: 28, borderRadius: "50%", border: "2px solid #3b82f6", background: isPending && scoutPending.outcome === "error" ? "#3b82f6" : "transparent", color: isPending && scoutPending.outcome === "error" ? "#000" : "#3b82f6", fontSize: 12, fontWeight: 900, cursor: scoutPending ? "default" : "pointer", display: "flex", alignItems: "center", justifyContent: "center" }} disabled={!!scoutPending} onClick={() => setScoutPending({ originZone: z.id, outcome: "error" })}>E</button>
                        </div>
                        {os.total > 0 && !scoutPending && (<div style={{ display: "flex", gap: 3, marginTop: 2, fontSize: 7 }}>{os.kills > 0 && <span style={{ color: "#ef4444" }}>{os.kills}K</span>}{os.dug > 0 && <span style={{ color: "#007bff" }}>{os.dug}D</span>}{os.errors > 0 && <span style={{ color: "#3b82f6" }}>{os.errors}E</span>}</div>)}
                      </div>
                    );
                  })}
                </div>
                <div style={{ background: scoutPending ? "#007bff" : "#2a2a34", textAlign: "center", fontSize: 9, fontWeight: 900, color: scoutPending ? "#000" : "#9ca3af", padding: "4px 0", letterSpacing: 3, margin: "4px 0", borderRadius: 4 }}>
                  {scoutPending ? "\u25bc TAP EXACT LANDING SPOT \u25bc" : "\u2500\u2500\u2500 NET \u2500\u2500\u2500"}
                </div>
                {courtSvg(shots, true)}
                <div style={{ display: "flex", justifyContent: "space-between", alignItems: "center", marginTop: 8 }}>
                  <span style={{ fontSize: 11, opacity: 0.5 }}>{shots.length} shots</span>
                  <div style={{ display: "flex", gap: 6 }}>
                    {scoutPending && <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} onClick={() => setScoutPending(null)}>Cancel</button>}
                    <button style={{ ...S.gb, background: "#2a2a34", padding: "4px 12px", fontSize: 10 }} disabled={shots.length === 0} onClick={undoLastShot}>Undo</button>
                  </div>
                </div>
                <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                  <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                </div>
              </div>
            )}

            {scoutView === "heatmap" && (
              <div>
                {shots.length === 0 ? (<div style={{ textAlign: "center", padding: 32, opacity: 0.4 }}>No shots yet.</div>) : (
                  <>
                    <div style={{ fontSize: 10, fontWeight: 700, color: "#9ca3af", letterSpacing: 1, textAlign: "center", marginBottom: 4 }}>FILTER BY ATTACK ORIGIN</div>
                    <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridTemplateRows: "auto auto", gap: 2, background: "#0f1218", border: "2px solid #2a2a34", borderRadius: "8px", overflow: "hidden", marginBottom: 4 }}>
                      {ZONES.map((z) => { const os = originStats[z.id]; const isActive = scoutOriginFilter === z.id; return (
                        <button key={z.id} style={{ background: isActive ? "#0a1929" : "#0d0d14", padding: 5, border: "none", color: "#fff", cursor: "pointer", textAlign: "center", borderBottom: isActive ? "2px solid #007bff" : "2px solid transparent" }} onClick={() => setScoutOriginFilter(isActive ? null : z.id)}>
                          <div style={{ fontSize: 8, opacity: 0.4 }}>Z{z.id}</div>
                          {os.total > 0 && <div style={{ fontSize: 10, fontWeight: 700 }}>{os.total} <span style={{ fontSize: 7, opacity: 0.5 }}>({os.kills}K)</span></div>}
                        </button>); })}
                    </div>
                    {scoutOriginFilter !== null && (<button style={{ ...S.gb, background: "#2a2a34", width: "100%", marginBottom: 4, fontSize: 10 }} onClick={() => setScoutOriginFilter(null)}>Zone {scoutOriginFilter} filter &mdash; tap to clear</button>)}
                    <div style={{ background: "#007bff", textAlign: "center", fontSize: 9, fontWeight: 900, color: "#000", padding: "3px 0", letterSpacing: 3, margin: "2px 0", borderRadius: 4 }}>{"\u2500\u2500\u2500"} NET {"\u2500\u2500\u2500"}</div>
                    {courtSvg(filteredShots, false)}
                    <div style={{ ...S.card, marginTop: 8 }}>
                      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr 1fr 1fr", gap: 8, textAlign: "center" }}>
                        <div><div style={{ fontSize: 20, fontWeight: 800 }}>{filteredShots.length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Attacks</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#ef4444" }}>{filteredShots.filter((s) => s.outcome === "kill").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Kills</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#22c55e" }}>{filteredShots.filter((s) => s.outcome === "dug").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Digs</div></div>
                        <div><div style={{ fontSize: 20, fontWeight: 800, color: "#3b82f6" }}>{filteredShots.filter((s) => s.outcome === "error").length}</div><div style={{ fontSize: 9, opacity: 0.5 }}>Errors</div></div>
                      </div>
                    </div>
                    <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 6 }}>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#ef4444", marginRight: 3, verticalAlign: "middle" }}></span>Kill</span>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#007bff", marginRight: 3, verticalAlign: "middle" }}></span>Dug</span>
                      <span style={{ fontSize: 9 }}><span style={{ display: "inline-block", width: 8, height: 8, borderRadius: "50%", background: "#3b82f6", marginRight: 3, verticalAlign: "middle" }}></span>Error</span>
                    </div>
                  </>
                )}
              </div>
            )}
          </div>
          );
        })()}

        {/* ── SUBS TAB ──────────────────────────── */}
        {tab === "subs" && (
          <div style={S.matchContent}>
            <div style={S.card}>
              <h3 style={S.cardTitle}>SUBSTITUTIONS</h3>
              <p style={S.cardSub}>{set?.subCount || 0} subs used this set</p>

              {/* Make a sub */}
              <SubManager
                onCourt={Object.entries(set?.currentLineup || {}).map(([pos, id]) => ({
                  pos: parseInt(pos),
                  player: getPlayerById(id),
                  id,
                }))}
                bench={benchPlayers}
                onSub={(inId, outId) => makeSub(inId, outId)}
              />

              {/* Sub history */}
              {(set?.subs || []).length > 0 && (
                <div style={{ marginTop: 16 }}>
                  <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4 }}>HISTORY</span>
                  {[...(set?.subs || [])].reverse().map((sub, i) => {
                    const inP = getPlayerById(sub.inPlayer);
                    const outP = getPlayerById(sub.outPlayer);
                    return (
                      <div key={i} style={{ padding: "8px 0", borderBottom: "1px solid #1a1a24", fontSize: 13 }}>
                        R{sub.rotation}: {inP?.name?.split(" ")[0]} in → {outP?.name?.split(" ")[0]} out
                      </div>
                    );
                  })}
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    );
  }

  return null;
}

// ── SUB MANAGER COMPONENT ─────────────────────────────
function SubManager({ onCourt, bench, onSub }) {
  const [subOut, setSubOut] = useState(null);
  const [subIn, setSubIn] = useState(null);

  return (
    <div>
      <div style={{ marginTop: 12 }}>
        <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
          PLAYER OUT
        </span>
        <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
          {sortByPosition(onCourt.filter((c) => c.player).map((c) => ({ ...c.player, _courtId: c.id }))).map((p) => (
            <button key={p._courtId} style={{
              ...S.pickerPlayer,
              ...(subOut === p._courtId ? { borderColor: "#ef4444", background: "#1a0a0a" } : {}),
            }}
              onClick={() => setSubOut(p._courtId)}>
              <span style={{ fontWeight: 800 }}>{p.name?.split(" ")[0]}</span>
              <span style={{ fontSize: 9, opacity: 0.5 }}>#{p.number}</span>
            </button>
          ))}
        </div>
      </div>

      {subOut && bench.length > 0 && (
        <div style={{ marginTop: 12 }}>
          <span style={{ fontSize: 11, fontWeight: 700, letterSpacing: 1.5, opacity: 0.4, display: "block", marginBottom: 6 }}>
            PLAYER IN
          </span>
          <div style={{ display: "flex", flexWrap: "wrap", gap: 6 }}>
            {sortByPosition(bench).map((p) => (
              <button key={p.id} style={{
                ...S.pickerPlayer,
                ...(subIn === p.id ? { borderColor: "#22c55e", background: "#0a1a0a" } : {}),
              }}
                onClick={() => setSubIn(p.id)}>
                <span style={{ fontWeight: 800 }}>{p.name?.split(" ")[0]}</span>
                <span style={{ fontSize: 9, opacity: 0.5 }}>#{p.number}</span>
              </button>
            ))}
          </div>
        </div>
      )}

      {subOut && subIn && (
        <button style={{ ...S.primaryBtn, marginTop: 12, fontSize: 14 }} onClick={() => {
          onSub(subIn, subOut);
          setSubOut(null);
          setSubIn(null);
        }}>
          Confirm Sub
        </button>
      )}
    </div>
  );
}

// ═════════════════════════════════════════════════════
// STYLES
// ═════════════════════════════════════════════════════
const S = {
  container: { minHeight: "100vh", minHeight: "100dvh", height: "100vh", height: "100dvh", background: "#0a0a0f", color: "#e2e8f0", fontFamily: "'SF Pro Display',-apple-system,BlinkMacSystemFont,sans-serif", maxWidth: 480, margin: "0 auto", position: "relative", overflowX: "hidden", overflowY: "auto", WebkitOverflowScrolling: "touch" },
  loading: { textAlign: "center", padding: 48, fontSize: 16, opacity: 0.5 },
  header: { padding: "16px 16px 12px", display: "flex", alignItems: "center", gap: 10, borderBottom: "1px solid #1a1a24" },
  logoRow: { display: "flex", alignItems: "center", gap: 10 },
  logoIcon: { width: 40, height: 40, borderRadius: 10, background: "#111118", display: "flex", alignItems: "center", justifyContent: "center" },
  logoTitle: { fontSize: 22, fontWeight: 800, letterSpacing: 3, margin: 0, color: "#ffffff" },
  logoSub: { fontSize: 10, opacity: 0.5, margin: 0, letterSpacing: 1, color: "#ffffff" },
  headerTitle: { fontSize: 17, fontWeight: 700, margin: 0 },
  pad: { padding: "16px 16px 180px" },
  backBtn: { background: "none", border: "none", color: "#e2e8f0", fontSize: 26, cursor: "pointer", padding: "4px 8px", lineHeight: 1 },
  // Home
  newMatchBtn: { width: "100%", padding: 14, background: "none", border: "2px dashed #2a2a34", borderRadius: 14, color: "#6b7280", fontSize: 14, fontWeight: 700, display: "flex", alignItems: "center", justifyContent: "center", gap: 8, cursor: "pointer" },
  sectionTitle: { fontSize: 11, fontWeight: 700, letterSpacing: 1.5, textTransform: "uppercase", opacity: 0.4, marginBottom: 10 },
  matchCard: { width: "100%", padding: 14, background: "#111118", border: "1px solid #1e1e28", borderRadius: 12, marginBottom: 8, textAlign: "left", cursor: "pointer", color: "#e2e8f0" },
  setScoreBadge: { background: "#1a1a24", padding: "2px 10px", borderRadius: 6, fontSize: 12, fontWeight: 600 },
  clearBtn: { background: "none", border: "1px solid #2a2a34", borderRadius: 8, color: "#6b7280", padding: "8px 16px", fontSize: 12, cursor: "pointer", width: "100%", marginTop: 24 },
  // Teams
  addTeamBtn: { background: "none", border: "1px solid #007bff", borderRadius: 8, color: "#007bff", padding: "5px 12px", fontSize: 12, fontWeight: 700, cursor: "pointer" },
  emptyTeam: { background: "#0d0d14", borderRadius: 12, padding: 24, textAlign: "center", border: "1px dashed #1e1e28" },
  teamCard: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 12, padding: 14, marginBottom: 8 },
  rosterChip: { background: "#1a1a24", padding: "2px 8px", borderRadius: 6, fontSize: 11, fontWeight: 600 },
  teamActionBtn: { padding: "8px 14px", background: "#007bff", border: "none", borderRadius: 8, color: "#fff", fontSize: 12, fontWeight: 700, cursor: "pointer" },
  // Form
  label: { display: "block", fontSize: 11, fontWeight: 700, letterSpacing: 1, textTransform: "uppercase", opacity: 0.4, marginBottom: 4 },
  input: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", padding: "10px 12px", fontSize: 14, outline: "none", width: "100%", boxSizing: "border-box" },
  primaryBtn: { width: "100%", padding: 14, background: "#007bff", border: "none", borderRadius: 12, color: "#ffffff", fontSize: 15, fontWeight: 800, cursor: "pointer" },
  // Lineup
  courtSetup: { background: "#0d0d14", borderRadius: 14, padding: 16, border: "1px solid #1a1a24" },
  netLabel: { textAlign: "center", fontSize: 11, fontWeight: 700, letterSpacing: 3, opacity: 0.3, marginBottom: 8 },
  courtGrid: { display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gap: 8 },
  courtSlot: { padding: "12px 8px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, position: "relative" },
  courtSlotActive: { borderColor: "#007bff", background: "#0a1525" },
  courtSlotFilled: { background: "#0a1525", borderColor: "#007bff" },
  courtPosLabel: { fontSize: 10, fontWeight: 800, color: "#64748b", position: "absolute", top: 3, left: 6 },
  courtPlayerNum: { fontSize: 18, fontWeight: 800 },
  courtPlayerName: { fontSize: 10, opacity: 0.6, maxWidth: "100%", overflow: "hidden", textOverflow: "ellipsis", whiteSpace: "nowrap" },
  pickerBox: { background: "#0d0d14", borderRadius: 12, padding: 14, border: "1px solid #1e1e28", marginBottom: 12 },
  pickerLabel: { fontSize: 12, fontWeight: 700, opacity: 0.6, display: "block", marginBottom: 8 },
  pickerPlayer: { padding: "10px 14px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, minWidth: 56 },
  optionBtn: { flex: 1, padding: 16, background: "#111118", border: "2px solid #1e1e28", borderRadius: 12, color: "#e2e8f0", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 6 },
  optionBtnActive: { borderColor: "#007bff", background: "#0a1525" },
  infoCard: { background: "#111118", borderRadius: 12, padding: 16, border: "1px solid #1e1e28", textAlign: "center" },
  // Match
  matchHeader: { display: "flex", alignItems: "center", justifyContent: "space-between", padding: "10px 10px 6px", borderBottom: "1px solid #1a1a24" },
  scoreBoard: { display: "flex", alignItems: "center", gap: 14 },
  teamCol: { display: "flex", flexDirection: "column", alignItems: "center" },
  teamLabel: { fontSize: 9, fontWeight: 700, letterSpacing: 1.5, opacity: 0.5 },
  bigScore: { fontSize: 30, fontWeight: 800, lineHeight: 1 },
  setChip: { background: "#007bff", color: "#ffffff", fontSize: 11, fontWeight: 800, padding: "4px 10px", borderRadius: 16, textAlign: "center", lineHeight: 1.3 },
  undoBtn: { background: "#111118", border: "1px solid #1e1e28", borderRadius: 8, color: "#e2e8f0", fontSize: 18, padding: "6px 10px", cursor: "pointer" },
  serveIndicator: { textAlign: "center", padding: "6px 12px", fontSize: 13, fontWeight: 600 },
  tabs: { display: "flex", borderBottom: "1px solid #1a1a24" },
  tab: { flex: 1, padding: "9px 0", background: "none", border: "none", borderBottom: "2px solid transparent", color: "#64748b", fontSize: 12, fontWeight: 700, cursor: "pointer", letterSpacing: 0.5, position: "relative" },
  tabActive: { color: "#007bff", borderBottomColor: "#007bff" },
  badge: { position: "absolute", top: 2, right: "calc(50% - 20px)", background: "#ef4444", color: "#fff", fontSize: 9, fontWeight: 800, padding: "1px 5px", borderRadius: 8 },
  matchContent: { padding: "10px 10px 120px", overflowY: "auto" },
  toast: { position: "fixed", top: 10, left: "50%", transform: "translateX(-50%)", background: "#007bff", color: "#ffffff", padding: "7px 18px", borderRadius: 18, fontSize: 13, fontWeight: 700, zIndex: 999, pointerEvents: "none" },
  // Court
  courtMatch: { background: "#0d0d14", borderRadius: 14, padding: "10px 10px 14px", border: "1px solid #1a1a24", marginBottom: 10 },
  netBar: { textAlign: "center", fontSize: 10, fontWeight: 700, letterSpacing: 3, opacity: 0.3, marginBottom: 6, borderBottom: "2px solid #1e1e28", paddingBottom: 4 },
  courtPlayer: { padding: "8px 4px", background: "#111118", border: "2px solid #1e1e28", borderRadius: 10, color: "#e2e8f0", display: "flex", flexDirection: "column", alignItems: "center", gap: 1, position: "relative", cursor: "pointer", minHeight: 60, justifyContent: "center" },
  courtPlayerServing: { borderColor: "#007bff", background: "#0a1525" },
  courtPlayerLibero: { borderColor: "#22c55e", background: "#0a1a0a" },
  courtPlayerPasser: { borderColor: "#22c55e", background: "#0a1a0f" },
  courtPlayerSelected: { borderColor: "#007bff", background: "#0a1525" },
  rallyStartBtn: { width: "100%", padding: 16, background: "#007bff", border: "none", borderRadius: 12, color: "#ffffff", fontSize: 16, fontWeight: 800, cursor: "pointer", marginBottom: 8 },
  theirPointBtn: { width: "100%", padding: 12, background: "none", border: "1px solid #991b1b", borderRadius: 10, color: "#ef4444", fontSize: 13, fontWeight: 700, cursor: "pointer", marginBottom: 12 },
  endSetBtn: { width: "100%", padding: 12, background: "none", border: "2px solid #007bff", borderRadius: 12, color: "#007bff", fontSize: 13, fontWeight: 700, cursor: "pointer", marginTop: 8 },
  // Player list rows
  pRow: { display: "flex", alignItems: "center", gap: 6, padding: "7px 8px", background: "#0d0d14", borderRadius: 8, marginBottom: 5, borderLeft: "3px solid #1e1e28" },
  pId: { minWidth: 62, flexShrink: 0 },
  pName: { fontSize: 13, fontWeight: 700 },
  pBtns: { display: "flex", gap: 4, flexWrap: "wrap", flex: 1, justifyContent: "flex-end" },
  ib: { padding: "6px 8px", border: "none", borderRadius: 6, color: "#fff", cursor: "pointer", fontWeight: 800, fontSize: 11, minWidth: 34, textAlign: "center" },
  cb: { padding: "7px 8px", border: "none", borderRadius: 5, color: "#fff", cursor: "pointer", fontWeight: 800, fontSize: 11, minWidth: 34, textAlign: "center", background: "#581c87" },
  mSt: { fontSize: 8, color: "#9ca3af", fontWeight: 700 },
  rowDivider: { fontSize: 8, color: "#4b5563", textAlign: "center", letterSpacing: 2, fontWeight: 700, margin: "1px 0", opacity: 0.4 },
  gb: { padding: "9px 6px", border: "none", borderRadius: 6, color: "#fff", cursor: "pointer", fontWeight: 700, fontSize: 11, textAlign: "center", background: "#065f46" },
  // Overlay + popup
  overlay: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, background: "rgba(0,0,0,0.7)", display: "flex", alignItems: "center", justifyContent: "center", zIndex: 100 },
  popup: { background: "#15151f", borderRadius: 16, padding: 20, maxWidth: 320, width: "90%", border: "1px solid #007bff" },
  // Stats table
  statsTable: { width: "100%", borderCollapse: "collapse", fontSize: 11 },
  sth: { padding: "4px 3px", textAlign: "center", color: "#9ca3af", fontWeight: 700, fontSize: 9, letterSpacing: 1, borderBottom: "1px solid #1e1e28" },
  std: { padding: "5px 3px", textAlign: "center", color: "#d1d5db", fontSize: 11, borderBottom: "1px solid #1a1a24" },
  // Phases
  phaseBox: { background: "#0d0d14", borderRadius: 14, padding: 16, border: "1px solid #1a1a24" },
  phaseTitle: { fontSize: 14, fontWeight: 800, letterSpacing: 1.5, color: "#007bff", margin: "0 0 4px", textAlign: "center" },
  phaseDesc: { fontSize: 12, opacity: 0.5, textAlign: "center", margin: "0 0 12px" },
  phaseGrid: { display: "grid", gridTemplateColumns: "1fr 1fr", gap: 8 },
  phaseBtnLg: { padding: 20, border: "none", borderRadius: 12, color: "#fff", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 4 },
  passRow: { display: "flex", gap: 8, justifyContent: "center" },
  passBtn: { padding: "12px 16px", border: "none", borderRadius: 10, color: "#fff", cursor: "pointer", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, flex: 1 },
  cancelBtn: { width: "100%", padding: 10, background: "none", border: "1px solid #2a2a34", borderRadius: 8, color: "#6b7280", fontSize: 12, cursor: "pointer", marginTop: 12 },
  rallyBtn: { padding: 14, border: "none", borderRadius: 10, color: "#fff", cursor: "pointer", fontWeight: 800, fontSize: 13, letterSpacing: 0.5 },
  // Cards
  card: { background: "#111118", borderRadius: 14, padding: 16, marginBottom: 10, border: "1px solid #1e1e28" },
  cardTitle: { fontSize: 12, fontWeight: 800, letterSpacing: 2, color: "#007bff", margin: "0 0 4px" },
  cardSub: { fontSize: 11, opacity: 0.4, margin: "0 0 14px" },
  formulaRow: { display: "flex", alignItems: "center", gap: 10, marginBottom: 10 },
  progressBg: { flex: 1, height: 7, background: "#1a1a24", borderRadius: 4, overflow: "hidden" },
  progressFill: { height: "100%", borderRadius: 4, transition: "width 0.3s" },
  remainingBox: { display: "flex", flexDirection: "column", alignItems: "center", padding: "14px 0 4px", borderTop: "1px solid #1a1a24", marginTop: 8 },
  statCol: { display: "flex", flexDirection: "column", alignItems: "center" },
  insightBox: { background: "#1a1a24", borderRadius: 10, padding: 12, marginTop: 12, borderLeft: "3px solid #007bff" },
  insightLabel: { fontSize: 9, fontWeight: 800, letterSpacing: 2, color: "#007bff", display: "block", marginBottom: 4 },
  insightText: { fontSize: 12, margin: 0, lineHeight: 1.5, opacity: 0.8 },
  setHistoryRow: { padding: "8px 0", borderBottom: "1px solid #1a1a24" },
  // Correlation
  corrLabel: { fontSize: 11, fontWeight: 700, letterSpacing: 1, opacity: 0.5, display: "block" },
  corrCol: { display: "flex", flexDirection: "column", alignItems: "center", flex: 1 },
};

ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(VolleyballStats));
</script>
</body>
</html>